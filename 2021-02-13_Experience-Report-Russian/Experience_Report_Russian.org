# -*- mode: org; -*-
# Time-stamp: <2021-02-09 17:54:06 lockywolf>
#+BLOG: wordpress
#+POSTID: 428
#+date: 2021-02-08 Mon 9:30
# Created   : [2020-05-11 Mon 21:01]
# Author    : lockywolf gmail.com
#+AUTHOR: Vladimir Nikishkin
#+TITLE: Solving SICP
#+category: development,
#+tags: science, computer-literacy, computers, engineering, lisp, scheme, software, 

#+STARTUP: inlineimages
#+STARTUP: latexpreview
#+HTML_MATHJAX: align: left indent: 5em tagside: left font: Neo-Euler
#+HTML_MATHJAX: cancel.js noErrors.js
# +OPTIONS: tex:imagemagick
#+OPTIONS: toc:nil
#+LANGUAGE: en
#+LATEX_CLASS: acmart
# +LATEX_CLASS_OPTIONS: [letterpaper]
#+latex_header: \usepackage{float}
#+latex_header: \usepackage[utf8]{inputenc}
#+latex_header: \usepackage[T1]{fontenc}
#+latex_header: \usepackage{supertabular}

#+latex_header: \usepackage{polyglossia}
# the safeinputenc option to biblatex seems to be dangerous, but I had to use it for (R) to be displayed. 
# be careful
#+latex_header: \usepackage[backend=biber,style=ACM-Reference-Format,backref=true,citestyle=authoryear,safeinputenc]{biblatex}
#+latex_header: \addbibresource{bibliography-bib.bib}
#+latex_header: \setdefaultlanguage[variant=british]{english}
#+latex_header: \defcounter{biburlnumpenalty}{1}

#+latex_header: \DeclareBibliographyCategory{badbreaks}
#+latex_header: %\addtocategory{badbreaks}{sicsc,software_plantuml}
#+latex_header: %\AtEveryCitekey{%
#+latex_header: %  \ifcategory{badbreaks}
#+latex_header: %    {\defcounter{biburlnumpenalty}{9}}
#+latex_header: %    {}}
# test  hardlinks 1

#+begin_export latex
\title{Solving SICP}
\settopmatter{printfolios}
\subtitle{Отчёт по решению самого известного в мире задачника по программированию}

\acmConference{Scheme Workshop 2020}{2020-09}{Online}

# \affiliation{Unaffiliated}
\email{wladimir.nikishkin@gmail.com}
\keywords{scheme, r7rs, teaching, programming, literate programming, fortran, reproducible research, emacs lisp}
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10003456.10003457.10003527.10003531</concept_id>
       <concept_desc>Social and professional topics~Computing education programs</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003456.10003457.10003527.10003531.10003533.10011595</concept_id>
       <concept_desc>Social and professional topics~CS1</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003456.10003457.10003527.10003531.10003533</concept_id>
       <concept_desc>Social and professional topics~Computer science education</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003456.10003457.10003527.10003531.10003751</concept_id>
       <concept_desc>Social and professional topics~Software engineering education</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003456.10003457.10003527.10003531.10003537</concept_id>
       <concept_desc>Social and professional topics~Computational science and engineering education</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10010147.10010148</concept_id>
       <concept_desc>Computing methodologies~Symbolic and algebraic manipulation</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10010147.10010178.10010216</concept_id>
       <concept_desc>Computing methodologies~Philosophical/theoretical foundations of artificial intelligence</concept_desc>
       <concept_significance>300</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10010940</concept_id>
       <concept_desc>Software and its engineering~Software organization and properties</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10010940.10010971</concept_id>
       <concept_desc>Software and its engineering~Software system structures</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10010940.10010971.10011682</concept_id>
       <concept_desc>Software and its engineering~Abstraction, modeling and modularity</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10010940.10010971.10010972</concept_id>
       <concept_desc>Software and its engineering~Software architectures</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Social and professional topics~Computing education programs}
\ccsdesc[500]{Social and professional topics~CS1}
\ccsdesc[500]{Social and professional topics~Computer science education}
\ccsdesc[500]{Social and professional topics~Software engineering education}
\ccsdesc[500]{Social and professional topics~Computational science and engineering education}
\ccsdesc[500]{Computing methodologies~Symbolic and algebraic manipulation}
\ccsdesc[300]{Computing methodologies~Philosophical/theoretical foundations of artificial intelligence}
\ccsdesc[500]{Software and its engineering~Software organization and properties}
\ccsdesc[500]{Software and its engineering~Software system structures}
\ccsdesc[500]{Software and its engineering~Abstraction, modeling and modularity}
\ccsdesc[500]{Software and its engineering~Software architectures}

#+end_export

#+latex: \def\hyph{-\penalty0\hskip0pt\relax}

Эта статья -- своего рода "отчёт" по самому большому проекту, который я сделал в своей жизни по собственной инициативе. Я сделал полное и всеобъемлющее решение всех задач из одной из самых извесных книг по программированию в мире "Структура и Интерпретация Компьютерных Программ", за авторством Абельсона, Сассмана и Сассман. 

В ходе  выполнения проекте я собрал довольно много данных о том, как человек решает решает задания в частности, и выполняет проекты вообще, в частности:
- Измерил полную трудоёмкость SICP (729 часов, 19 минут (больше  8 месяцев работы), распределённых по 292 учебным сессиям) 
- Сколько компьютерных языков потребовалось выучить (6)
- Сколько программ потребовалось использовать (9)
- В какой степени требовалась внешняя помощь.

В этой статье предлагается:
- Практичный, поддерживаемый программно, протокол для решения любого вида домашней работы в электронном виде.
- Несколько предложений по улучшению процесса преподавания любого вида технических навыков.
- Несколько улучшений для процесса преподавания любых навыков в принципе.

Решебник доступен онлайн (в виде исходного кода, а также скомпилированного pdf):
- [[http://gitlab.com/Lockywolf/chibi-sicp]] ([[cite:chibi-sicp]])

В практическом смысле, результаты этой статьи (в частности, данные в приложении) могут быть востребованы прямо сейчас в качестве:
- Точечной оценки трудоёмкости набора задач SICP.
- Раздаточный материал для студентов-первокурсников, служащий повышению мотивации к учёбе.
- Набора данных для изучения поведенческих паттернов характерных для взрослых, занимающихся самообразованием.
- "Практически готового" протокола для выполнения любого представимого в виде дерева подзадач курсового задания, допускающего применение данного решения при трудоустройстве в качестве портфолио. 
- "Практически готового" и "почти удобного" протокола для измерения трудоёмкости любого набора задач, представимого в цифровом виде.

Данный отчёт подготовлен таким образом, чтобы анализ данный, произведенный по результатами измерения времени, был воспроизводим на машинах, поддерживающих org-mode.
(См приложение: "Код для анализа данных на Emacs Lisp".)

#+end_abstract

@@html:<!--more Read full paper-->@@

#+begin_export latex
\maketitle
\raggedbottom
\pagebreak
#+end_export

* Введение

Учебники программирования не часто сами становятся предметом изучения. Их задача -- обучать, а не  быть изучаемыми. С другой стороны, преподавателям часто требуется разрабатывать курсы для своих учебных заведений, и им требуется на что-то опираться. Чаще всего, в качестве начального курса программирования выбирается изучение синтаксиса какого-нибудь одного языка программирования, выбранного случайно или согласно веяниям моды. 

Однако, были попытки сделать дизайн вводного курса в программирование более систематическим. "Структура и Интерпретация Компьютерных Программ" была написана в результате одной из таких попыток. SICP был революционным уже в годы написания первого издания, и можно сказать, что остаётся революционным до сих пор. Через двадцать лет после выхода первого издания, его практическая применимость книги была проанализирована Маттиасом Феллейсеном в статье "Stucture and Interpretation of Computer Science Curriculum". (См библиграфию) В ней рассматриваются плюсы и минусы курса, целенаправленно разработанного по всем правилам педагогического подхода. В ней же он предлагает то, что по его мнению, является "вторым поколением", продолжающим развитие этого "педагогического подхода". (См "How To Design Programs" (@@latex:\emph{@@HTDP@@latex:}@@) [[cite:felleisen2018how]])

Оставляя в стороне дидактическое качестве курса (автор сам не преподаватель), в этом отчёте рассматривается другая, намного реже анализируемая сторона обучения программированию (и вообще любому предмету) -- трудоёмкость. Сколько именно времени, рабочих часов, требуется для того, чтобы успешно завершить какой-либо курс? 

Этот проект в каком-то смысле является продолжением предыдущего, во время которого автор сего текста учил уравнения математической физики традиционным методом, при помощи бумаги и карандаша, и механического таймера. Тот проект был плохо формализован, и на него невозможно сослаться. Однако, даже грубые измерения настолько тривиальным инструментом как таймер, выявили колоссальную разницу между тем, что заявляется в качестве трудоёмкости курса его создателями, и тем, что получается на самом деле. 

Автор сего текста решил методически продолжить свой предыдущий опыт, и разработать процедуру, позволяющую контролируемым и не мешающим основной задаче способом измерять трудоёмкость. Программирование предоставлялось здесь очевидным местом для "входа в область". Компьютерные навыки, как кажется интуитивно, и измеряться должны проще всего.

Решебник был структурирован, разбит на части, оснащён программной системой для решения задач, и написан автором сего текста в полном объёме. Тем самым, декларируемая цель была достигнута, а трудоёмкость измерена. 
Данные по измерениям находятся в общем доступе. (Прим. к русскому переводу: поскольку данные очень объёмны, в русском переводе они отсутствуют. Предлагается обратиться к английской версии.) Читателям, занимающимся преподаванием профессионально, предлагается в будущем разрабатывать курсы с учётом результатов, полученных в этой работе.

Если подходить к вопросу более широко, автор предлагает в целом осуществить переоценку процесса преподавания в специализированных институтах, и сформировать новую парадигму, основанную на эмпирических исследованиях. Необходимо точно понимать, что именно, в каком объёме, где и когда осуществляет каждая сторона, участвующая в образовательном процессе. Это необходимо, в частности, для того, чтобы понимать, где у системы слабые места и бутылочные горлышки, и для применения оптимизационных процедур. В программировании данный подход называется "профайлингом".

* Подход к решению

 Автор считает, что хороший решебник должен удовлетворять следующим принципам:

 1. Быть полным.
 2. Представлять собой достаточно реалистичную модель процесса решения задач, как будто бы если она осуществлялась целевой аудиторией курса: студентами начальных курсов высшего учебного заведения с небольшим опытом программирования, скорее всего, полученного в школе.
 3. Быть полностью цифровым, написанным в цифровом субстрате изначально.
 4. Быть измеримым.

В следующем параграфе рассмотрим подробнее, что имеется в виду. 

** Что имеется в виду под полнотой?

*** Что значит "решить все задачи курса"?

Автор этих строк считает, что полнота освоения материала -- необходимое условие прохождения любого курса обучения чему-либо.

Но как выразить на бытовом языке, что вообще такое "пройти курс" или "выучить предмет"?
Как можно, например, формализовать для проверки утверждением "я знаю математический анализ"?
Или, подходя в вопросу проще, что именно позволяет студенту, нормально освоившему материал, сказать "я выучил всё, что должен был выучить в рамках университетского курса математического анализа"? 

Конечно, неплохо было бы провести исследование мнений всех заинтересованных сторон: учителей, учеников, работодателей, политиков, и абстрактных представителей "общества в целом", что _для них_ значит фраза "знаю предмет хорошо".

Ниже представлены потенциальные ответы на этот вопрос, как они придуманы автором этого текста:

- Сдать устный экзамен.
- Сдать письменный экзамен.
- Пройти процедуру защиты проекта перед советом (научным, диссертационным).
- Успешно выполнить требуемое количество задач в рамках системы непрерывной оценки. (Примерно так, как это делается в начальной школе.)
- Решить "большое домашнее задание". (Как это принято в МФТИ.)
- Посетить определённое количество учебных сессий (лекций или семинаров).
- Прочесть определённое количество учебного материала. 

Всё вышеперечисленное, в некой комбинации, может быть объявлено "достаточным" для признания курса "освоенным", то есть перед нами задача из класса "goal attainment". (См: Gembicki 1975) Такие задачи, однако, всё равно решаются путём сведения многих целей к некоторой обобщённой "единой" цели.

Если посмотреть на задачу построения такой цели отстранённым взглядом (на жаргоне такая позиция иногда называется "точкой зрения марсианина", см Э.Берн "Люди, которые играют в игры"), то покажется возможным свести все вышеперечисленные критерии к единому "выполнение большого домашнего задания". Грубо говоря, посещение лекции тоже можно в каком-то смысле считать "решаемой задачей из задачника". "Выполнение большого домашнего задания", в свою очередь, крайне трудно свести к другим видам целей, без потери внутренней структуры. Таковая внутренняя структура представляет собой древовидный список задач/подзадач, часть из которых искусственные. "Искусственные" задачи -- это как раз задачи вида "сходить на лекцию".

Если подходить к процессу обучения более прагматично, то самостоятельное выполнение больших домашних заданий -- это наиболее реалистичный способ обучения для взрослых людей, трудоустроенных на полную ставку, и не имеющих достаточно свободного времени для посещения очных занятий.

Выбор книги, посвящённой программированию, которая обязана своей известностью включённому в неё задачнику даже более, чем основному тексту, был довольно естественным.

Однако, нельзя сказать, что "решить все задачки из книжки" -- это достаточное условие для того, чтобы утверждать, что "материал освоен".

Поскольку автор хотел "сделать", а не "отделаться", то есть выучить предмет, а не просто решить задачки, то в изначальный план включал в себя придумывание новых задачек, для покрытия тех мест курса, для которых  штатные задачи отсутствуют.

Эта часть плана не удалась, в первую очередь потому, что предъявить разбивку имеющегося курса по времени выполнения в какой-то момент показалось автору сего текста более важным. Тем не менее, при применении текущего подхода к другим курсам, с возможно более низким качеством составленных авторами задач, такую необходимость стоит иметь в виду.

Автор, однако, перерисовал несколько иллюстраций из книги, а именно те, которые _не_ требовались для выполнения задач из задачника.

Сделано это было для того, чтобы получить ощущение, что автор (играющий роль студента) может при необходимости написать аналогичную книжку "из головы" и "по имеющимся материалам". Перерисовка осуществлялась для иллюстраций, покрывающих материал, по мнению автора, недостаточно представленный в задачах. Эти дополнительные иллюстрации не заняли слишком большого количества времени, и не повлияли на полную оценку трудоёмкости по порядку величины.

*** Качественная имитация университетского опыта.

Одним из главных критических замечаний к настоящему проекту, может звучать следующим образом: В большинстве университетов (если не во всех) вообще-то, не требуется прорешать прямо уж все задачи из задачника, чтобы завершить курс успешно. Зачастую это верно, и в особенности в математических курсах. (Задачники по математике обычно включают в несколько раз больше задач, чем требуется для покрытия материала курса "в один слой".) Автор, однако, не считает, что таковая критика применима к задачнику из SICP. Задачи покрывают материал курса с минимальным пересечением, и автор (как указывалось выше), даже рассматривал возможность добавить собственных задач.

Другим важным критически замечанием является утверждение, что самостоятельное изучение предмета вообще принципиально не может качественно симулировать университетский опыт, ибо семинары и презентации являются его неотъемлимой частью. Предполагается, что методы решения задач приготовляются семинаристами согласованно с индивидуальными паттернами поведения студентов, и подаются в персонализированной манере.  

Это валидное возражение. С другой стороны, несмотря на валидность, оно несколько идеализирует ситуацию в университетской среде. Семинаристы зачастую рекрутируются из имеющегося "пула", чаще всего, аспирантов, и не имеют ни необходимых знаний, ни педагогической подготовки. В таких случаях, настоящий отчёт может служить реперной точкой уже для семинаристов, для оценки времени, необходимого для подготовки к семинарам.

Более того, зачастую студенты не посещают большую часть занятий, либо из-за чрезмерной уверенности в себе, либо из-за конфликтов в расписании. Для таковых студентов настоящий отчёт также является возможной оценкой времени, необходимого для самостоятельной работы. 

Более того, имеющиеся данные подсказывают, что для студентов в верхней квартили успеваемости, корреляция посещаемости с оценкой невелика. ([[cite:St_Clair_1999_a_case_agains_compulsory_class_attendance_policies_in_higher_education]] и [[cite:Kooker:1975:Changes_in_grade_distributions_associated_with_changes_in_class_attendance_policies]])

Для студентов же, которые занятия посещают, настоящий отчёт может быть выдан в качестве рекомендованного чтения на первом занятии, для стимуляции посещения занятий.

Более того, самостоятельное выполнение курса не противоречит записи семинаров на видео и предоставления этих видео студентам для последующего ознакомления.
Недостаток интерактивности в записанных видео может бы скомпенсирован большим количеством материала, накапливаемым за годы проведения семинаров разными людьми для разных групп. 

*** Мета-когнитивные упражнения

Мы часто недооцениваем степень неравенства в отношениях между учителем и учеником. Учитель не просто лучше знает предмет обучения -- это нормально -- но ещё и зачастую играет определяющую роль в том, как и когда студент будет учиться. (Автор не исключил бы, хотя это и требует дополнительного исследования, что курсы, преподаваемые по понедельникам, осваиваются лучше курсов, преподаваемых поп пятницам.)
Часто преподаватели игнорируют этот факт, и рассматривают себя исключительно как источник знаний, или, что ещё хуже, только как экзаменаторов.
Следовательно, стоит рассматривать весь эффект, который оказывает учитель на ученика, целиком.
На практике, чаще всего у ученика нет иного выбора, кроме как доверять учителю вы выборе упражнений.
Ученик также склонен выбирать такие же инструменты для выполнения задачи, как и те, что выбираются учителем.

Основная мысль этого абзаца в том, что преподавание -- это не просто процесс передачи данных.
Это еще и процесс передачи метаданных, и развития метакогнитивных навыков. (See [[cite:Ku2010]])
Следовательно, передача метакогнитивных навыков, хотя она и является важной составляющей частью обучения, и выполняет важную роль в обучении студента "думать", заслуживает отдельного рассмотрения при написании курсов.  

Примерами метакогнитивных упражнений являются:

- Предъявление материала не согласно "естественному порядку", таким образом, чтобы более ранние (по порядовому номеру) задачи были неразрешимы без предварительного разрешения задач, более поздних по номеру или номеру главы.
- Сознательная неполнота изложения материала.
- Немногословность изложения, отсутствие предварительно заложенного дублирования материала во имя повторения пройденного.
- Отсутствие готового предложения программного обеспечения, поддерживающего излагаемый материал.
- Отсутствие оценки сложности или трудоёмкости для предлагаемых задач.
- Демонстративно неравномерное распределение сложности задач.

Дополнительным вызовом гладкости и непрерывности процесса обучения является отсутствие поддержки среди людей занимающихся тем же самым делом.
Учебные заведения предпринимают попытки стимулировать взаимопомощь среди студентов, но насколько эти попытки успешны, не очень понятно.
Помогают ли в самом деле студенты друг другу в искусственно созданных группах поддержки и в учебных группах вообще?
Естественно, общение в учебных группах не ограничивается общением по теме предмета обучения.
До какой степени "непрофильное" общение влияет на учеников?  Может, быть, оно более отвлекает от учёбы, нежели помогает учиться?

Способы поддержки важнее для взрослых, которые учатся самостоятельно, поскольку даже искусственных групп поддержки, созданных по разнарядке университетскими чиновниками, у них нет, как нет никакой регулярной учебной поддержки вообще.

Здесь надо заметить, что платформа, на которой осуществляется поддержка -- платформа для групповых чатов, или список рассылки, -- это важный социальный фактор, каким бы он не казался не имеющим отношения к предмету обучения.
Это не значит, что учитель должен создать группу поддержки обучения в той социальной сети, которая является модной на момент проведения курса.
Это значит, что вопрос о методе осуществления поддержки должен рассматриваться внимательно в каждом конкретном случае.

Личный опыт автора был таков:

- IRC-канал [[irc:irc.freenode.org/#scheme][#scheme Freenode channel]] был основным местом для задавания вопросов в режиме реального времени. Канал #emacs также был очень полезен.
- http://StackOverflow.com использовался для задавания вопросов асинхронно.
- The Scheme Community Wiki http://community.schemewiki.org активно использовалась как дополнительный учебный материал.
- Автор так же напрямую посылал сообщения по электронной почте многим участникам сообщества Scheme.
- Автор нашёл некоторое количество ошибок в документах, созданных в рамках процесса по работе с сообществом Scheme.
- Автор задавал вопросы в списке рассылки Chibi-Scheme.
- Автор получил некоторое количество помощи на Slack-чате Open Data Science.
- Автор получил некоторую помощь от членов сообщества Closed-Circles.
- Автор получил помощь от сообщества rulinux@conference.jabber.ru.
- Автор получил помощь от членов Shanghai Linux User Group.
- Автор получил помощь от участников онлайн-сообщества "научный форум" http://www.dxdy.ru.
- Автор получил помощь от группы в Telegram, посвящённой изучению Haskell.

Следует заметить, что среди вышеперечисленных средств поддержки, только Open Data Science и группа, посвящённая Haskell, хостятся на "модных" платформах.

Взаимодействие с сообществом приведено в настоящем отчёте в подглаве "метакогнитивные упражнения", потому что навык поиска людей, которые могут тебе помочь, без сомнения, является метакогнитивным навыком, и более того, одним из самых сложных для преподания.
Более того, даже если знающие люди находятся, и могут дать ответы на вопросы студент, они, в большинстве ситуаций, совершенно не обязаны это делать. Таким образом, автор считает, что навык общения с некооперирующимися людьми должен рассматриваться на лекциях специально.

Повторяя главную мысль предыдущего абзаца: человеческие сообщества состоят из грубых людей. Естественно, нельзя заставить людей терпеть грубость, но нельзя также и заставить людей быть вежливыми.
Метакогнитивный навык извлечения ценных знаний из кооперативных, но грубых людей, также очень важен, и так же редко преподаётся.

Автор также считает важным довести до студентов и учителей следующую мысль: не мода, популярность, лёгкая доступность, реклама, или социальная приемлемость, не являются важными факторами при выборе медиа для группы поддержки.
К сожалению, технологические преимущества, современность или удобство, также не являются важными факторами при выборе медиа. Важным является наличие информации, и наличие людей, способных помочь с задачами, решаемыми в рамках курса. 

Помощь и поддержка, требуемые проектом по написанию решебника для  SICP в цифрах:

- Email-цепочек в списках рассылки, посвящённых компиляторам и интерпретаторам Scheme: 28.
- Email-цепочек в списках рассылок, посвящённые IDE, текстовым редакторам и сообщениям об ошибках в них: 16.
- Email-цепочек, посвящённых форматированию и оформлению: 20.
- Email-цепочек, посвящённых непосредственно задачнику: 3.
- Цепочек, посвящённых документации и ошибкам не в ней (а также отчётам от битых ссылках): 16.
- Сообщений в IRC: 2394 сообщений, написанных автором на профильном канале.
- Проектов, восстановленных на Software Forges (таких как Github), из архивов исходных авторов: 2.

В силу закрытости, идиосинкратичности, и нестандартизированности иных средств общения, таких как Slack, статистика по иным каналам общения не собиралась, но общение в них не было очень объёмным.

*** Перерисованные иллюстрации

Несколько иллюстраций из SICP были перерисованы с помощью языков программирования или генерации изображений.
Как было упомянуто выше, перерисовывались те иллюстрации, которые, как кажется, человек, освоивший курс, должен уметь рисовать для анализа своей ежедневной рабочей деятельности.
Также иллюстрации перерисовывались для покрытия тем, недостаточно покрытых задачами основного набора.

Список иллюстраций:
- 1.1 Древовидное изображение формулы, включая значение всех под-комбинаций.
- 1.2 Разбиение программы, вычисляющей квадратный корень, на процедуры.
- 1.3 Линейный рекуррентный процесс.
- 2.2 Box-and-pointer представление ~(cons 1 2)~.
- 2.8 Решение задачи о восьми ферзях.
- 3.32 Процедура интегрирования, представленная как система обработки сигналов.
- 3.36 RLC схема.
- 5.1 Пути распространения данных в регистровой машине.
- 5.2 Контроллер для машины, вычисляющей НОД.

** Моделирование поведения, "вроливание" и выбор инструментов

*** Биография автора сего текста

Перед началом выполнения настоящего проекта, у автора уже была степень кандидата наук в Информатике, хотя и не в промышленном программировании.
Без сомнения, у автора было преимущество перед первокурсником.
Тем не менее, в значительно степени, опыт представляется релевантным, поскольку до момента начала выполнения задач, автор никогда не пользовался функциональными языками программирования, и редакторами программного кода более совершенными, чем Notepad++. Другим важным отличием от типичного первокурсника было то, что автор уже умел печатать десятью пальцами (так называемым, слепым десятипальцевым методом). Этот навык преподаётся в средних школах в США однако, всё ещё не является обязательным в большей части мира.  

Замечание: данные, представленные в данном отчёте в большой степени зависят от навыка скоропечати слепым методом, и скорее всего, итоговая трудоёмкость для студентов, не владеющих методом слепой печати, окажется в константу раз выше. При отсутствии у студентов навыка скоропечати, измерения из данного отчёта невозможно брать за основу при оценке сложности разрабатываемого курса, а выбор инструментов может показаться странным. 

Цель, которую автор поставил перед собой, была в какой-то степени противоречива, так как "модельный" студент, поведения которого автор старался придерживаться, не существует. Таковое поведение заключается в:

- Выполнении всех упражнений честно, не обращая внимания на то, сколько времени они потребуют.
- Не жульничать при выполнении упражнений (однако, консультироваться с решениями других студентов не запрещалось в той степени, в которой это не было прямым списыванием).
Использовать инструменты, которые могли бы быть доступны студенту в 1987 году, хотя, возможно в современных версиях.
- По возможности, следовать методологии "Свободного программного обеспечения, Программного обепечения с открытым кодом, и Unix-way", в формулировке широко известных организаций. 
- Попытаться подготовить "решение задач" в формате, потенциально применимом для "сдачи" в университете.

Первые три принципа не требовали больших сознательных усилий для соблюдения, последний же потребовал некоторой аккуратности выполнения и выбора инструментов.

Интересно, что личный опыт автора в университетском программировании большей частью был посвящён отладке процедур ввода-вывода.
На втором месте по трудозатратности была задача написания тестов.
Собственно решение программистских задач было только на третьем месте по трудоёмкости.

Широко известно утверждение, что SICP был целенаправленно разработан в качестве вводного курса. Автор предположил, что значительная часть программы будет посвящена первым двум задачам, указанным выше.
Выяснилось, что это не так.
Вместо того, чтобы решать эти две задачи, SICP игнорирует их, взамен предлагая очень жёсткий формат входных данных, в тоже время способный описать большую часть входящих данных.

Несмотря на то, что SICP совершенно не предполагался быть решённым в формате, в котором его решил автор, то есть в виде "весь решебник -- один файл, в котором входные данные, код, решающий задачу, и выходные данные включены в виде блоков интерактивной электронной тетради", (так называемый notebook-формат), тот факт, что SICP ограничивает возможные структуры, подаваемые на вход интерпретатора, сильно упрощает решение в вышеуказанном формате. 

Противоречивость модели "идеального студента" выражается в необходимости сочетать две модели поведения, характерные для студентов. Одна представляет собой "ленивого" студента, который работал бы в той степени, в которой это необходимо, для того, чтобы "сделать курс", и не более того. Эта модель отвечает за то, чтобы затратить на проект минимально возможное время, и за то, чтобы выбрать такие инструменты, которые сделают процесс "сдачи задания" минимально времязатратным. Другая же модель отвечала "трудолюбивому" студенту, который был бы счастлив изучить материал настолько глубоко, насколько это возможно, и возможно, никогда курс не закончить, "потерявшись" в какой-нибудь наиболее интересной задаче, и должна была отвечать за качество работы, и за выбор наиболее "правильных" инструментов. 
Таковые две модели студенческой мотивации в каком-то смысле отвечают концепции "Theory X and theory Y", предложенными McGregor ([[cite:mcgregor:1960:theory_x_and_theory_y]]).

Попытаемся представить себе "идеального студента", смесь двух вышеуказанных моделей, и попробуем принимать решения так же, как это делал бы он.
Неформально говоря, попробуем вести себя как "Я выучу все инструменты, которые потребуются для того, чтобы сделать работу, в том объёме, который потребуется, но не более того".
(Существуют намного более качественные модели поведения студентов, многие с применением математического моделирования (например [[cite:hlosta:2018:modelling_student_online_behaviour_in_a_virtual_learning_environment]]), однако данная простая модель казалась достаточной при выполнении данного проекта.

*** Выбор инструментов

Конечный набор инструментов, применявшийся при выполнении проекта, следующий:

#+latex: \bigskip

- Chibi-Scheme :: реализация языка Scheme
  - srfi-159 :: инструмент для pretty-printing
  - srfi-27 :: библиотека случайных чисел
  - srfi-18 :: библиотека для работы с потоками
  - (chibi time) :: библиотека для работы с временем и датой
  - (chibi ast) :: (строго говоря, не требующаяся для решения) библиотека для работы с абстрактным синтаксическим деревом языка и экспансии макросов
  - (chibi process) :: вызова ImageMagick
- GNU Emacs :: в качестве IDE
  - org-mode :: в качестве основного носителя рабочих данных и в качестве основного инструмента для управления проектом
  - f90-mode :: как IDE для низкоуровнего языка
  - geiser :: расширение для Emacs для работы с Scheme, оказался неготовым к серьёзному применению, однако, оказался также полезен для выполнения небольших кусков кода
  - magit :: как графический инструмен для git
- gfortran :: как низкоуровневый язык
- PlantUML :: как язык рисования диаграмм первого выбора
- TikZ + luaLaTeX :: как язык рисования диаграмм "второго выбора"
- Graphviz :: как язык рисования диаграмм "третьего выбора"
- ImageMagick :: как основной бэкэнд для написания реализации графической библиотеки
- git :: как инструмент для контроля версий
- GNU diff, bash, grep :: как инструменты для работы с текстом
#+latex: \vspace{-5mm}
#+begin_export latex
\begin{figure}[H]
\caption{Список инструментов, который потребовалось освоить для решения SICP}
\end{figure}
#+end_export

*Chibi-Scheme* была, по сути, единственной реализацией Scheme, поддерживающей самый свежий стандарт языка, r7rs-large (Red Edition), так что выбор был очевиден.
Выбор становится ещё более очевиден, если представить себя на месте студента, не желающего вдаваться в особенности тех школ мысли, которые привели к созданию огромного разнообразия различных реализаций Scheme, не до конца совместимых со стандартом.
Несколько библиотек, три из который стандартизированы, а три нет, потребовались для полного решения всех задач.
Невозможно решить все упражнения из задачника, пользуясь _только_ стандартным языком Scheme.
Даже Scheme, вместе со всеми возможными расширениями языка, всё ещё недостаточно.
За пределами стандартных инструментов, потребовалась одна нестандартная библиотека, (chibi process), послужившая мостом к графическому интерфейсу. 

*git* не часто преподаётся в школах.
Причиной тому может послужить то, что учителя могут не хотеть заниматься тем, что им самим кажется тривиальным, или, тем более, жизненно необходимым ("вы же не можете заниматься программированием без системы контроля версий?"), или перегрузка иными задачами.
Однако, практика показывает, что очень часто студенты ухитряются выпуститься из института, защитив диплом, и так и не выучив основных концепций управления версиями документов, что значительно тормозит рабочий процесс впоследствии.
Git был выбран в связи с тем, что это самая широко используемая система контроля версий.

*ImageMagick* оказалась самым простым способом создания изображений, состоящих их простых прямых линий.
Не существует стандартного способа связать приложения на Scheme с приложениями, написанными на других языках.
Согласно принципу минимального выхода за пределы курса, ImageMagick был выбран, как требующий одной-единственной нестандартной процедуры.
Более того, эта процедура, (простой синхронный вызов другой программы), вероятно вообще самый простой примитив для кооперации программ из когда-либо изобретённых.
Практически все операционные системы поддерживают запуск одними программами других программ.

*PlantUML* -- это реализация международного стандарта визуализации программ. 
Её синтаксис незамысловат и хорошо документирован.
Интерфейс PlantUML-Emacs существует и относительно надёжен.
Текстовое представление воплощает в себе дух хакерства, и сильно упрощает контроль версий.
UML практически полностью доминирует на рынке визуализации программ, и практически любая университетская программа включает его, до какой-то степени.
Соответственно, автору показалось очень естественным решать те диаграммные задачи из SICP, которые допускали представление в виде UML, в PlantUML. 

Применение *Graphviz* также являлось попыткой использовать (на этот раз уже другой) индустриальный стандарт для решения тех графических задач, которые не допускали решения в виде UML.
Язык ~dot~ хорошо разбирается машинным способом, и даже менее зависит от контекста, чем UML. Однако, на практике он оказался менее удобным. 

*TikZ* -- это практически единственный язык рисования общего назначений.
В тех задачах, в которых общность модели изображений была шире, чем позволяют нарисовать UML и Graphviz, автор использовал TikZ.
Довольно естественным выбором было бы рисовать требуемые изображения при помощи инструмета с графическим интерфейсом, такого как Inkscape или Adobe Illustrator.
Однако, одна из проблем с изображениями, создаваемыми при помощи таких инструментов состоит в том, что они плохо обрабатываются системами контроля версий.
Вторая проблема заключается в том, что автору хотелось сохранить все результаты курса в одном цифровом артефакте (грубо говоря, в одном файле). Упаковка решения в один файл уменьшает путаницу, вызываемую большим количеством версий одного кода, делает поиск в коде намного более простой задачей, а также упрощает презентацию решения потенциальному экзаменатору.

*gfortran*, он же GNU Fortran, был выбран в качестве низкоуровнего языка для решения последних двух задач в задачнике. 
Причины выбрать такой не самый популярный язык были следующими:
- Автор уже знал язык Си, то есть имел преимущество перед гипотетическим "студентом-первокурсником".
- Фортран достаточно низкоуровневый для решения низкоуровневых задач из SICP.
- Существует свободная реализация Фортрана.
- Фортран 90 уже существовал во время выпуска второго издания SICP. was published.

*GNU Unix Utilities* автор изначально не планировал использовать, однако~diff~ оказался очень полезным для иллюстрации разницы между двумя кусками кода в Главе 5. Они так же оказались полезными в качестве "клея", для соединения разных программ в единую систему.

*GNU Emacs* де факто является самой популярной IDE среди пользователей Scheme, это IDE используемая основателями Free Software Foundation, среди которых и авторы SICP, и, вероятно, использовался в качестве текстого редактора для написания SICP, также с большой вероятностью может быть выбран студентом-первокурсником из-за его ассоциации с "хакерской" субкультурой.
Это, вероятно, не очевидный выбор, поскольку на протяжении многих лет одной из самых популярных сред разработки среди первокурсников являлась Microsoft Visual Studio.
Другим возможным выбором был бы Dr. Racket, в который библиотеки, необходимые для прохождения SICP включены в поставку по-умолчанию.
Однако, для любителей Lisp, и для продвинутых студентов, Emacs всё ещё является популярным выбором, и поддержка Lisp в нём хороша, хотя для Scheme и не так хороша, как можно было бы подумать.
Наличие org-mode оказало решающее влияние на выбор Emacs, и она заслуживает отдельной подглавы.
Говоря неформально, выбор платформы Emacs в качестве главной операционной среды для работы на ЭВМ, оказался настолько важным, что полностью преобразил вообще всю парадигму в которой автор этого отчёта работает с вычислительными устройствами.
Кривая обучения для Emacs, без сомнения, очень крута.

Как было описано выше, одним из главных достижений этого отчёта является публикация данных, "профилирующих" выполнение задачника по временным ресурсам. В подолжении статьи будет рассказано, как именно данные собирались, при помощи механизмов учёта времени, встроенных в org-mode. Собранные данные включены в настящий отчёт в приложении, и не включают время, затраченное на изучение Emacs или org-mode. Однако, некоторое количество (менее надёжных) данных было собрано всё равно.

Прочтение руководства пользователя Emacs Liso потребовало *10* учебных сессий общей трудоёмкостью в 32 часа 40 минут.
Изучение Emacs в дополнение к прочтению руководства потребовало 59 часов 14 минут.


** Org-mode как универсальный носитель документов, поддерживающий парадигму reproducible research.

Org-mode помогла автору разрешать зависимости между упражнениями.
Одно из мета-когнитивных упражений SICP -- это высокая степень зависимости упражнений друг от друга. 
Например, упражнения из Главы 5 требуют наличия исходного кода, написанного в ходе решения задач Главы 1.
В современных учебных заведениях стандартной практикой является разделяемого кода между упражнениями при помощи операций "копировать" и "вставить".
Однако, в более поздние упражнения из задачника SICP, потребовали бы копирования десятков фрагментов кода, написанных в предыдущих главах.
Простое копирование привело бы к немедленному раздуванию файлов с решениями в несколько раз, и сделало бы поиск по файлу очень сложным. Более того, оно бы сильно усложнило пропагацию исправлений ошибок в более раннем коде, найденных во время решения задач из более поздних глав.

Люди, знакомые с работой Дональда Кнута могут узнать в org-mode идеи, впервые предложенные им в реализации системы WEB, в частности, программой web2c.
Другой крайне популярной WEB-образной системой является Jupyter Notebook, уже упоминавшаяся выше. (См [[cite:software_jupyter]])

Org-mode помогает упаковать целый решебник в один файл.
Представим ситуацию, в которой студенту требуется отослать решение задач преподавателю на проверку.
Каждый дополнительный файл, который студент посылает -- потенциальный источник ошибок.
Даже если правильно и детально именовать файлы согласно их функции, что требует определённой мыслительной дисциплины, от преподавателя всё равно будет требоваться вникнуть в детали сборки проекта, которые станут бесполезными ровно в тот момент, когда он подпишет сдачу задания.
Ситуация выглядит ещё хуже, когда от преподавателя требуется не только оценить работу студента, но и протестировать, что часто случается с программистскими курсами.

Org-mode файлы могут быть экспортированы в форматы, которые удобны для применение в отдалённом будущем.
Представим иную ситуацию: применение студентом решённого задания для улучшения собственных перспектив трудоустройства.
Эта задача хорошо известна в области искусств. Студенты художественных и журналистских специальностей начинают собирать портфолио часто ещё до поступления в ВУЗ. 
Однако студентам технических специальностей важность наличия портфолио ясна ещё не в полной мере.
Один из самых частых вопросов, который задаётся на собеседовании при трудоустройстве: "покажите нам, что вы уже сделали примечательного".
Наличие портфолио, в форме, которая легко предъявима на собеседовании, может быть невероятно полезной собеседуемому.

С высокой вероятностью, у потенциального работодателе не будет ни оборудования, ни желания запускать код вчерашнего студента.
Даже у студента самого, скорее всего, уже не будет в наличии отлаженной программной системы, в которой писался код на начальных курсах.
Следовательно, студенческая работа должна архивироваться в "переносимом" формате, и быть настолько устойчивой к эффектам течения времени и эволюции вычислительных систем, насколько это возможно.

Естественным образом, самый переносимый и устойчивый к влиянию времени формат -- это простая белая бумага.
В идеале, работа, после визирование преподавателем, должна быть форматируема в виде печатаемого отчёта.
Относительно небольшой объём работы (в сравнении с полной трудоёмкостью SICP), позволяющий конвертировать программный код в пригодный для печати отчёт, должен служить эмоциональным стимулом для студента проделать этот небольшой объём работы и получить элемент портфолио.
Естественно, "бумага" -- это не очень удобный формат для работы в 21 веке.
Однако, существует относительно удобное к нему приближение, формат PDF.
Таким образом, "исходный код" решения должен быть сравнительно легко и без повреждений экспортироваться в PDF.
Org-mode позволяет таковую конвертацию через PDF преобразователь, при помощи типографского пакета LaTeX.

У org-mode практически неограниченная применимость.
В частности, этот отчёт написан в org-mode.
Основными положительными сторонами применения org-mode для форматирования решебника можно считать интерактивность выполнения кода и лёгкость экспорта в печатные форматы. Однако, для данного отчёта ключевой возмжностью оказалась подсистема учёта времени с минимальными трудозатратами.

Как именно данные были собраны, описано в следующей подглаве. Также приведена статистическая выжимка этих данных, которую, однако, не в коем случае нельзя считать всеобъемлющей.

** Разные виды задач

Задачи из SICP можно грубо разделить на следующие классы:

- Задачи, решаемые на Scheme, без ввода.
- Задачи, решаемые на Scheme с вводом, который, возможно, является выводом других программ.
- Задачи, решаемые на Scheme с графическим выводом.
- Задачи, решаемые на "языке низкого уровня по выбору студента".
- Математические задачи.
- Задачи, требующие рисования диаграмм, подчиняющихся какому-либо стандарту технических иллюстраций.
- Нестандартные упражнения, требующие рисования.
- Эссе.

Примечательно, что совершенно отсутствуют задачи по анализу данных.

В этой подглаве будет рассмотрено, как эти классы задач разрешимы модели "единого документа". 

*Эссе* представляют собой самый простой класс. Студент может писать соответсвующее эссе прямо под заголовком, соответствующим решаемой задаче.
Org-mode предоставляет минимальные возможности для форматирования текста, которых, однако, достаточно для реализации всех потребностей SICP.

*Математические задачи* требуют наличия системы TeX на машине студента, и используют возможности org-mode по встраиванию математических формул прямо в текст. Автору не потребовалось практически никаких вычислений с карандашом и бумагой для решения математических упражнений SICP.

*Упражнения, решаемые на Scheme*, то есть, большая часть задач, форматируются в качестве babel-блоков, вывод которых внедряется непосредственно под те блоки, в которых написан код, и обновляется по мере решения.

*Упражнения, решаемые на Scheme с вводом* требуют несколько больше работы для корректной организации. Не всегда очевидно, когда ввод является абстрактным простым текстом, и когда он должен быть проинтерпретирован как исполняемый код. 
В итоге оказалось, что возможно представить код в качестве либо блоков "example", либо "code" с отключённым автоматическим выполнением, и указать их в качестве входных блоков при помощи директивы :stdin. Таким образом, и условия тестов, и результаты тестов оказалось возможным включить непосредственно в документ.

*Упражнения, решаемые на языке низкого уровня*, требовали оборачивания низкоуровнего кода в babel-блоки, и комбинирования этих блоков в единый файл при помощи блока типа shell. 
В этом месте в решебник пришлось привнести зависимость от средств операционной системы. Однако, GNU Unix Utilities достаточно широко распространены, чтобы не считать это ограничение чрезмерным.

*Задачи по программированию, с графическим выводом*, оказались самой нетривиальной частью системы.
В итоге, автору пришлось написать специализированную библиотеку для Chibi-Scheme, использующую функционал ImageMagick. 
Org-mode предоставляет специальные средства для вставки изображений прямо в файл. Решения задач таким образом выглядели как программы, генерирующие графические файлы, и подставляющие ссылки на эти файлы в тело документа для отображения средствами Emacs.

*Упражнения, решаемые с помощью стандартных диаграмм*, представляют собой часть проблемы, которая крайне широко распространения, но часто плохо понимается, быть может, потому, что люди, решающие её, происходят обычно не из программистского сообщества.
Есть несколько стандартный соглашений по технической визуализации и созданию иллюстраций и диаграмм, включая UML, ArchiMate, SDL и другие.
Когда иллюстрация, требуемая для решения задачи из SICP, допускала стандартизированное представление, автор старался предоставить таковое представление.
Для генерации диаграмм чаще всего использовался инструмент PlantUML,  поддерживающий большой количество диаграмм, и с отличной поддержкой UML.
Система, org-plantuml, позволяющая связать её с Emacs, позволяла решать диаграммные задачи в такой же манере, как и программистские задачи -- при помощи babel-блоков. 

*Нестандартные диаграммные упражнения*, самыми частыми из которых были упражнения, требующие изобразить диаграммы окружений (в каком-то смысле, интерфейс отладчика), оказались намного технически нетривиальными.
Когда заранее известная абстрактная модель (язык диаграмм) отсутствовал, диаграмму приходилось реализовывать "с нуля".
Для этого самым подходящим оказался язык TikZ.
Его применение потребовало больших временных затрат для прочтения руководства, и определённых уровень квалификации при работе с TeX.

* Анализ трудоёмкости, профилирование эффективности, и графики

В этой подглаве мы рассмотрим как именно рабочий процесс был организован, и также покажет, некоторую аггрегированную статистику трудозатрат.

** Детали рабочего процесса и профилирование

Задачи выполнялись в следующей манере: 

В начале работ, дерево заголовков, соответствующее дереву глав/параграфов книги было приготовлено в org-mode.
Большая часть заголовков -- это TODO-заголовки.
(За исключением небольшого количества заголовков, соответствующих параграфам без задач.)

TODO-заголовок -- это специальный вид заголовка в org-mode, экспортирующий своё состояние (завершено/не завершено) в простую базу данных, что позволяет мониторить долю выполненных задач в документе, главе, подглаве.

Промежуточные уровни (главы) не являются TODO-заголовками, однако, они содержат индикаторы, позволяющие узнать долю выполненных задач.

Самый верхний уровень дерева, таким образом, соответствует степени завершённости всего проекта.

Ниже представлен фрагмент дерева, в качестве примера:

#+begin_export latex
\begin{figure}[H]
#+end_export

#+begin_example
 * SICP [385/404]
 ** Chapter 1: Building abstractions ... [57/61]
 *** DONE Exercise 1.1 Interpreter result
     CLOSED: [2019-08-20 Tue 14:23]...
 *** DONE Exercise 1.2 Prefix form
     CLOSED: [2019-08-20 Tue 14:25]
  #+begin_src scheme :exports both :results value
   (/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) 
      (* 3 (- 6 2) (- 2 7)))
  #+end_src

  [fuzzy]Results
  : -37/150
 ...
#+end_example
#+begin_export latex
\caption{Пример файла решебника}
\end{figure}
#+end_export

Когда работа очевидно разделена на подзадачи, и для каждой единицы разбивки очевидна степень её завершённости, это создаёт в студенте ощущение контроля над выполняемым процессом. 
Степень завершённости всего проекта, доступная в любой момент, создаёт важный эмоциональный стимул, ощущение приближения к желаемой цели с каждым решённым упражнением.

Требуются дополнительные исследования того, насколько это эмоциональный эффект устойчив, и насколько он зависит от неравномерной сложности задач, или от полной трудоёмкости задачника.
Есть однако, исследования, которые утверждают, что наличие даже очень грубых KPI положительно сказывается на вероятности завершения проекта.
(См: [[cite:VanWormer2008]]) 

Согласно опыту автора, неравномерное распределение сложности по задачам нижнего уровня -- это огромный демотивирующий фактор.
С другой стороны, задачи, встречаемые в реальной жизни, не являются равномерно сложными, а значит возможность справляться с таковыми задачами являтся важным метакогнитивным навыком. Умение разделять большие задачи на малые, быть может, не в том, виде, который предлагается книгой или преподавателем, может являться одним из способов управления такими видами сложности. Следы такого подхода можно видеть в PDF решения, сделанном автором.

Проблемы решались практически последовательно. 
Работа над следующей задачей начиналась в тот же момент, когда работа над текущей  заканчивалась. 

Из более чем 350 упражнений, только 13 были решены вне линейного порядка.  (См подглаву [[* Задачи, решённые не по порядку и иные измерения]]) Последовательность решения задач важна для качественного профилирования времени, поскольку полным временем, отвечающим одной задаче, признавалась сумма продолжительностей учебных сессий между завершением предыдущей задачи и завершением текущей. Строгое соответствие последовательности решения задач последовательности из книги не требуется, однако в случае, когда задача откладывается на будущее, требуется удалить из базы сессий те сессии, соответствующие этой задаче, которые уже были проведены. Иными словами, задачи можно решать непоследовательно, но нельзя перемешивать сессии двух и более задач. 

В этом отчёте "неудачные" подходы к задачам игнорируются. Это игнорирование не оказало сильного влияния на профайлинг, потому что неудачные подходы были очень короткими. 

Необходимость последовательного решение -- это самая слабая точка настоящего отчёта. Обычно студенту трудно найти в себе мотивацию для последовательной работы. SICP требует строгой последовательности для некоторых подмножеств задач, зависящих друг от друга, однако, это "покрытие зависимостями" не всеобъемлюще. 

В качестве самого простого способа справиться с нелинейностью при применении данного протокола к другим задачникам, автор может только предложить такой же подход -- выбрасывать неудачные сессии за базы данных. Это кажется всё-таки не самым большим ограничением, потому что зачастую довольно несложно понять, является ли задача "крайне трудной". Учебную сессию, на которую пришлась "очень трудная" задача, можно искусственно укоротить.

Автор прочитал всю книгу перед тем как начать проект по решению. Соответственно, время, затраченное на решение, не было учтено в оценке полного времени решения задач. Дело в том, что когда автор подошёл к прохождению курса с точки зрения решения задач, простое чтение текста оказалось практически бесполезным, и текст выглядел так, как будто он совершенно новый.

Автор приложил сознательные усилия для того, чтобы учебная сессия не закрывалась в тот же момент, когда и задача объявлялась решённой.

 Причина этому -- применение хорошо известных трюков (См: [[cite:adler_factors_1939]]):
- Когда что-то не доделано, вернуться к выполнению проекта проще, чем если выполнение было приостановлено в момент завершения чётко выделенной фазы.
- Само прочтение условия задачи уже заставляет читателя начать решать задачу в бессознательном.

Данные представлены двумя наборами данные, тесно связанных друг с другом.
 
*Набор данных 1:* Времена завершения работы над каждыйм упражнением. (См [[*Приложение: Данные по временам завершений решений задач.][Приложение: Данные по временам завершений решений задач.]]) Для каждого упражнения, время его завершения было записано как временная метка org-mode, с точностью до минуты.

*Набор данных 2:* Учебные сессии записывались в отдельный org-mode файл в виде стандартного описания временного интервала (две верменные метки): 
#+begin_example
"BEGIN_TIME -- END_TIME".
#+end_example
(See [[*Приложение: Данные по учебным сессиям.][Приложение: Данные по учебным сессиям.]])

Во время каждой учебной сессии автор старался уделять всё своё внимание выполнению проекта, и не тратить время ни на что больше. Выполнение задач не ограничивается исключительно написанием кода и настройкой программной системы. Оно требует целого "пакета" действий по изучению предмета, ведущих к решению задачи. Таковые действия включают чтение и просмотр дополнительных материалов, задавание вопросов, исправление ошибок в программных инструментах, и подобные вещи, но не ограничиваются ими.

Несколько крупных ошибок в популярный программных продуктах были найдены во время написания решебника.
Эти ошибки были доложены авторам данных программных продуктов.
Некоторые ошибки были исправлены в течение короткого времени, тем самым позволив автору продолжить работу над решебником.
Для некоторых ошибок были найдены обходные пути.
Ни одна из ошибок в итоге не оказалась критической, мешающей завершить работу.

Очень удобным оказалось наличие инструмента по разрешению зависимостей.
Как было упомянуто выше, задачи из SICP используют друг друга.
Оказалось важным найти способ повторного использован я кода в рамках одного org-документа.
Возможности org-mode в части работы по принципу WEB (<<noweb>>-ссылок) оказалось достаточными для того, чтобы реализовать повторное использование всего кода, для которого это потребовалось.
Noweb-ссылки -- это всего лишь способ включения блоков кода в другие блоки кода, без каких-либо преобразований.
В частности, Упражнение 5.48 потребовало включения *58* различных блоков в блок, соответствующий окончательному решению.
Даже копирование в данном случае не подошло бы, так как задача требовала исполнения кода, полученного в результате _выполнения_ кода, написанного в предыдущих упражнениях. (Кодогенерация.) Как уже упоминалось, последующие упражнения помогают находить ошибки в предыдущих.

# +latex: \raggedbottom

# +latex: \pagebreak

** Задачи, решённые не по порядку и иные измерения

На следующей иллюстрации представлены некоторые статистические метрики, посчитанные по собранным данным.

#+latex: \bigskip

- *729* часов полная трудоёмкость написания решебника.
- *2.184* часов в среднем на одну задачу.
- *0.96* потребовалось на решение медианной задачи.
- *94.73* часов потребовалось на решение самой сложной задачи: написания интерпретатора Scheme на языке низкого уровня.
- *652* учебных сессей.
- *1.79* учебных сессий было затрачено в среднем на одну задачу.
- *>78000*-строк в итоговом файле с решебником. Это более 2.6 мегабайт, или 5300 страниц в PDF.
- *1* учебная сессия потребовалась для решения медианной задачи. Из разницы в два раза  между средним значением статистик и медианным, можно сделать вывод, что самые сложные задачи требуют существенно больше времени, чем "типичные".
- *13* задач были решены не по порядку:
  - "Figure 1.1 Tree representation..."
  - "Exercise 1.3 Sum of squares."
  - "Exercise 1.9 Iterative or recursive?"
  - "Exercise 2.45 Split."
  - "Exercise 3.69 Triples."
  - "Exercise 2.61 Sets as ordered lists."
  - "Exercise 4.49 Alyssa's generator."
  - "Exercise 4.69 Great-grandchildren."
  - "Exercise 4.71 Louis' simple queries."
  - "Exercise 4.79 Prolog environments."
  - "Figure 5.1 Data paths for a Register Machine."
  - "Exercise 5.17 Printing labels."
  - "Exercise 5.40 Maintaining a compile-time environment."
#+begin_export latex
\begin{figure}[H]
\caption{Метрики процесса выполнения процесса решения задач}
\end{figure}
#+end_export

Тринадцать задач были решены не по порядку:
Возможно, эти задачи можно считать самыми заковыристыми, хотя и не самыми сложными.

# +latex: \raggedbottom
# +latex: \pagebreak

** Десят самых трудоёмких задач

#+latex: \bigskip

#+ATTR_LATEX: :center :environment supertabular :align p{4cm}|p{1cm}|p{0.9cm}|p{0.9cm} :float nil
| Exercise                                          | Days Spent | Spans Sessions | Minutes Spent |
|---------------------------------------------------+------------+----------------+---------------|
| Exercise 2.46 ~make-vect~.                        |      2.578 |              5 |           535 |
| Exercise 4.78 Non-deterministic queries.          |      0.867 |              6 |           602 |
| Exercise 3.28 Primitive or-gate.                  |      1.316 |              2 |           783 |
| Exercise 4.79 Prolog environments.                |      4.285 |              5 |           940 |
| Exercise 3.9 Environment structures.              |     21.030 |             10 |          1100 |
| Exercise 4.77 Lazy queries.                       |      4.129 |              9 |          1214 |
| Exercise 4.5 ~cond~ with arrow.                   |     12.765 |              7 |          1252 |
| Exercise 5.52 Making a compiler for Scheme.       |     22.975 |             13 |          2359 |
| Exercise 2.92 Add, mul for different variables.   |      4.556 |             11 |          2404 |
| Exercise 5.51 EC-evaluator in low-level language. |     28.962 |             33 |          5684 |
#+begin_export latex
\begin{figure}[H]
\caption{Десять самых сложных задач}
\end{figure}
#+end_export

Не противоречит бытовой интуиции тот факт, что написание интерпретатора Scheme на низкоуровневом языке (Упражнение 5.51) оказалось самым трудоёмким.
В конце концов, оно потребовало изучения совсем нового языка с нуля.
В данном проекте этим низкоуровневым языком оказался Fortran 2018.
Изучение Фортрана оказалось довольно незамысловатым, хотя и требующим времени процессом. 

*Exercise 5.52*, компилятор Scheme, подразумевало наличие уже решённого упражнения 5.51, потому что библиотека времени выполнения в этих упражнениях применялась общая. Скомпилированный EC-evaluator оказалсь одной (очень длинной) Fortran-функцией.

*Exercise 2.29* доказывает, что даже при отсутствии в вашем языке программирования мутации (изменения значения переменной), можно сделать очень сложные задачи. 
У этой задачи есть комментарий от авторов SICP: "Эта задача непростая." 
И в самом деле, решение потребовало написания более 800 строк кода, разработки алгоритма нормализации символьных выражений с нуля, и потребовало написания 28 тестов.
Это просто очень большая задача.

*Exercise 4.5* -- это задача, в которой наличие семинариста помогло бы больше всего.  
Сама задача довольно простая. 
Трудоёмкость происходит из-за того, что для того, чтобы проверить, что решение корректно, требуется собрать полностью рабочий интерпретатор Scheme.
То есть, упражнение предполагает прочтение всей главы 4, и сборку интерпретатора из фрагментов.
Более того, оно требует большого количества работы со списками, что само по себе непросто, если пользоваться только функциями, про которые рассказывается в SICP.

*Exercise 4.77* требует большого количества модификаций наработанной кодовой базы, в разных местах. Пожалуй, это упражнение более всего нацеленное на преподавание "архитектуры ПО", за исключением, может быть, переписывания алгоритма раскручивания вычислений (backtracking) из Пролога. 
Такого вида код очень трудно реализовать инкрементально и сложно проверить его работоспособность практически до самого завершения. 
Более того, это упражнение требует модификации структуры данных самого нижнего уровня, и соответственно, пропагации изменения на все уровни абстракции выше.

*Exercise 4.79*, по существую, является плохо определённой задачей. 
Автор считает её завершённой, однако задание сформулировано настолько размыто, что трудно определить, что именно точно требуется. Следовательно данная задача может потребить произвольное количество времени.

*Exercise 3.9* предполагало реализацию библиотеки для построения диаграмм окружений. 
Казалось бы, задача тривиальна, и должна решаться снимком экрана отладочной программы. 
Однако, стандарт Scheme не предполагает никакого отладочного интерфейса.
Функционал для поддержки отладки кода отличается от реализации к реализации, и большинство не имеет никакой визуальной составляющей.
Существует библиотека EnvDraw (и её ответвления), но автор не нашёл лёгкого способа экспорта результатов её работы.
Оказалось проще реализовать построение диаграмм в TikZ и встроенных LaTeX-блоках.

Время, потраченное на *Упражнение 3.28" по большей части израсходовалось на сборку системы моделирования цифровых схем из фрагментов. Время, потраченное на решение самой задачи, было сравнительно невелико.

То же самое можно сказать про *Упражнение 2.46*, большая часть времени из которого была потрачена на написание моста между интерпретатором и графической системой. Само упражнение довольно простое.

Суммируя, самые трудные в книге упражнения -- это те, которые требуют от студента:
- реализовать тот функционал, который книга использует так, как будто он имеется в наличии, но стандарт его не поддерживает.
- собрать разрозненные фрагменты кода в работающую программу.
- решить задачи по темам, не покрытым материалом из книги.

Все вместе, десять самых сложных задач требуют 280 часов, что больше трети всего затраченного времени.

** Поминутная разбивка трудоёмкости

#+ATTR_LATEX: :width 245pt :float nil
#+caption: Поминутная разбивка задачника
[[./experience-report-minutes-per-problem.png]]

Вышеуказанный график, пожалуй, лучше всего иллюстрирует распределение трудоёмкости задачника.
Ожидаемо, несколько последних по порядковому номеру задач оказались самыми сложными.
Вторая часть курса оказалась более трудоёмкой, чем первая.




** Дни, затраченные на задачи

На этом графике можно видеть, какое количество дней (на оси ординат), задача под номером Х (ось абсцисс), была загружена в мозг автора. 
Простыми словами, сколько дней потребовалось на решение "задачи номер Х". 

Эта метрика менее репрезентативна, чем "трудоёмкость задачи Х в часах", на предыдущем графике. Она, однако может служить в качестве способа побуждения студентов к дальнейшей работе, в случаях, когда штурм задачи не приносит быстрых результатов. Естественным образом, большинство задач (но не все), решаемы за одну сессию, или один день.

#+ATTR_LATEX: :width 245pt :float nil
#+caption: Дни, затраченные на каждую задачу
[[file:experience-report-days.png]]

Второй пик в распределении, вероятно отвечает за общую усталость и потребность в отдыхе, и не связан со сложностью самой задачи. 
Соответствующий пик на графике часов менее заметен.

** Учебных сессий на задачу

#+ATTR_LATEX: :width 245pt :float nil
#+caption: Количество учебных сессих, затраченных на решение каждой задачи
[[file:experience-report-study-sessions.png]]

"Учебная сессия" -- это период высокой концентрации внимания, во время которого ученик активно пытается решить задачу, написать код или эссе. На данном графике отложена зависимость количества затраченных сессий от номера задачи, вне зависимости от длинны сессии.

Почему этот график имеет смысл? Когда ученик уходит на отдых, или каникулы, задача остаётся загруженной в мозг. Таким образом, периодические "штурмы", или учебные сессии могут быть полезными для поставки рабочих данных в бессознательное.

Во время отдыха, должен наблюдаться пик на графике "дней потраченных на задачу", но не "сессий, потраченных на задачу". Этот эффект, собственно, виден на втором пике на графике "дней, затраченных на задачу", и, соответственно, его пару на графике "сессий, затраченных на задачу". Его пара значительно короче.

** Гистограмма сложности (линейная)

На линейной гистограмме отложено количество задач, требующих "размер корзины" часов на решение.
Логично, что большинство задач разрешими за один-три часа. 

#+ATTR_LATEX: :width 245pt :float nil
#+caption: Гистограмма трудоёмоксти (линейная)
[[file:experience-report-hardness-histogram-linear.png]]


** Гистограмма сложности (логарифмическая)

[fuzzy]На линейной гистограмме отложено количество задач, требующих   e^"размер корзины" часов на решение.
Интересно, что в логарифмическом масштабе наблюдается "купол", одномодального распределения.
Трудно понять, почему именно такая форма у графика.
Есть, однако, эмпирические результаты, показывающие, что такое лог-нормальное распределение сложности вообще характерно для задачников в целом. 
(См [[cite:crow2018lognormal]])


#+ATTR_LATEX: :width 245pt :float nil
#+caption: Диаграмма трудоёмкости (логарифмическая)
[[file:experience-report-hardness-histogram-logarithmic.png]]


* Заключение и возможные направления работы в будущем

** Заключение

Как следует непосредственно из введения, этот отчёт представляет собой точечную оценку трудоёмкости задачника по программированию университетского уровня.

Насколько автору известно, это первый случай такого детального анализа университетского задачника.

Как было отмечено в параграфе [[Задачи решённые не по порядку и другие измерения]], полная трудоёмкость задачника составляет 729 часов.
Попросту -- это  очень много.
Если считать, что в стандартном рабочем дне 8 часов, то полное решение требует 91 день, или 14 недель, или три с половиной месяца.

В предисловии ко второму изданию, авторы утверждают, что урезанная версия курса (с выброшенной главой, посвящённой логическому программированию, главой, посвящённой регистровым машинам, и большинству тем, посвящённых компиляции), курс можно провести за один семестр.
Это утверждение не противоречит данным, полученным во время подготовки данного отчёта. (Если предполагать работу в течение полного дня.)
Тем не менее, скорее всего преподаватели не будут включать вообще все задачи в "большое домашнее задание" по курсу, а будут делать какую-то подвыборку из задачника. Автор надеется, что этот отчёт может им в этом помочь, при оценке сложности. 

С другой стороны, автор рекомендовал бы рассмотреть возможность организации двухсеместрового курса. Если убрать самые сложные задачи (те, что рассмотрены в параграфе [[*Десять самых трудоёмких задач]]), курс может быть вмещён в два 300-часовых односеместровых модуля. Триста часов на один курс в одном семестре -- это совпадает с похожими наблюдениями, сделанными автором в отношении курса уравнений математической физики, преподаваемого в Московском Физико-Техническом Институте.

Ещё одной частью курса, требующей отдельного внимания, является время, затрачиваемое преподавателями на проверку заданий, на оценку студентов и на написание фидбека.
Логично предположить, что проверка решений и написание фидбека должны занимать по порядку величины то же самое время, что и решение самого задачника, потому что каждую решённую задачу потребуется также проверить. Для простоты можно предположить, что проверка в десять раз проще решения, значит для полного курса она потребует 72 часа на работу одного студента.

Можно предположить, что в одной учебной группе 5 студентов (обычно больше, но для простоты посчитаем, что 5).
Значит, время, затрачиваемое на оценку будет 72*5=360 часов, или 45 полных рабочих дней.
Маловероятно, чтобы один преподаватель мог найти столько времени в семестре, или даже в двух. С другой стороны, если допустить возможность найма людей, в чьи должностные обязанности входила бы помощь семинаристам в проверке работ, проблема становится более реалистичной. 
Ещё одним практическим приложением данного отчёта может быть его применение в качестве довода, которые профессора могли бы применить для обоснования потребности в найме дополнительного учебного персонала перед администрациями университетов.

** Дальнейшая работа

Широкомасштабной оценки сложности (особенно с применением вычислительных инструментов) университетских предметов не проводится.
Данные отчёт является первым настолько подробным сложностным анализом университетского курса.
(Конечно, SICP успешно полностью решался в прошлом, однако без детальной оценки трудозатрат.
Различные подходы к решению, разной степени завершённости, можно найти на Software Forges, таких как SourceForge.

Одним из естественных продолжений данного направления исследования было бы применение этого же подхода к другим задачникам и другим предметным областям.

С другой стороны, данный отчёт представляет собой лишь точечную оценку, и тем самым крайне несостоятелен статистически. Его можно было бы качественно улучшить, организовав применение текущего протокола к тому же самому задачнику (SICP), разными людьми, вероятно, студентами целой группы или целого потока в высшем учебном заведении. 

Представление детального описания протокола, а также описаний системы программной поддержки решения, автор считает важным достижением данного отчёта.

Преподавателям, преподающим такой или похожие курсы в высших учебных заведения, предлагается продемонстрировать настоящий отчёт своим студентом и предложить оформить решение по аналогии с описанным методом.

Другим направлением исследований может быть предложение модели разработки курсов за пределами предметов, преподаваемых в рамках SICP. 
Достаточно ожидаемо, что студенты отказываются принимать участие в курсах, которые им кажутся чрезмерно сложными.
Иными словами вполне понятно, когда студент чувствует отчаяние от отсутствия прогресса в течение слишком долгого времени, и выбирает другой курс.

Было бы интересно измерить, какой уровень сложности является "чрезмерным" для каких студентов, и с чем это связано.
Не исключено, что "моменты отсечения" можно уловить, если измерять внутреннюю мотивацию каким-то образом (пока непонятно, каким), или правильно подбирать внешнюю мотивацию (правильно выбирать KPI, поощрения и штрафы, или применять какие-то иные средства).

Было бы интересно сравнить успешность завершения курса среди студентов, которые следуют протоколу, описанному в настоящем отчёте, с таковой у студентов, от него отказавшихся. 
Возможно, это такой эксперимент мог бы реализовать "тест самоопределения"  по Deci and Ryan. (См [[cite:ryan:2017:self_determination_theory]])

Ещё одним направлением исследования может быть разработка и формализация форматов подготовки "больших домашних задания", упрощающая сбор похожих данных по другим предметам. 

** Неформальный обзор

В этой подглаве предлагаются субъективные ощущения автора от завершённого проекта.

Автору проект показался интересным.
С другой стороны, автор ни на секунду не готов поверить, что найдётся статистически значимое количество студентов-первокурсников, способных его повторить.
Крайне маловероятно, что живой человек сможет посвятить семьсот часов решению задач по  одному предмету, пусть даже этот предмет разбит на два семестра. Также следует учитывать, что с момента выхода SICP прошло 25 лет, и технологии программирования сделали огромный шаг вперёд. Даже если найти такого целеустремлённого студента, у него скорее всего будут в семестре иные курсы, а также ему будет требоваться время для посещения лекций и семинаров.

С другой стороны, автор не может найти среди 353 упражнений ни одного лишнего. Более того, по некоторым темам автору пришлось самому добавить несколько упражнений.
Каждая задача раскрывает какую-то важную концепцию, и стимулирует студента мыслить глубже.  

Курс можно было бы расширить в сторону более широкого обзора систем сборки мусора и иного управления памятью.
Основной сборщик ~cons~-памяти описан хотя и сухо, но в деталях достаточных для его реализации. Другие же компоненты модели памяти не описаны никак. Ничего не сказано об эффективных механизмах хранения чисел, строк и иных объектов.

Очень мало внимания посвящено описанию эвристик, полезных при решении задач разработки ПО.
Эвристики, вероятно, нельзя назвать фундаментальным знанием, но трудно переоценить их полезность для профессионального программиста.

Последние два упражнения занимают две трети всего времени, требуемого для завершения проекта. 
Оказалось крайне неожиданным увидеть в самом конце задачи, которые требуется решать на языке, отличном от Scheme, применяющемся для большинства упражнений.

Пожалуй, самый большой недостаток -- это отсутствие какого-либо заключения и предложений возможных путей продолжения образования, например, в области строгой типизации, моделирования физических систем, или обработки данных.
Книга предлагает обширный список литературы, и теоретически, работу можно продолжить путём прохода по ссылкам оттуда.
Автору, однако, хотелось бы видеть более заключение более нарративного формата, включая высокоуровневый обзор всей области искусственного интеллекта.

** Неформальные рекомендации

Автор хотел бы позволить себе смелость дать несколько технических рекомендаций разработчикам ВУЗовских программ обучения. Эти рекомендации менее фундаментальны, однако автору кажутся сильно упрощающими жизнь.

 - Уделить отдельное внимание преподаванию ТеХа в своих курсах, и не просто ТеХа как программы, а всей инфраструктуры типографики и компьютерной графики. Мы живём в электронном мире, и логично создавать контент университетского уровня в формате, родном для электронных медиа. 
Эта область знаний часто оставляется студентам в качестве "внеклассного чтения", однако опыт автора показывает, что степень проникновения ТеХ всё ещё слишком мала. Крайне мало студентов, да и профессионалов, применяют ТеХ эффективно, и почти никто не пишет своих стилевых файлов. Автору потребовалось более *50* часов на то, чтобы обновить навыки \TeX{} для написания диссертации, при том, что ещё до этого автор уже использовал ТеХ в институтские годы. ТеХ дожен преподаваться на первом курсе.
 - Учите студентов слепому десятипальцевому методу печати. Это может показаться избыточным в тех частях Земли, где слепой метод печати входит в школьную программу, однако в большей части мира это всё ещё не так.
 - Научите студентов читать руководства к ПО.  В последние 30 лет наблюдается тенденция к написанию "дружелюбного" ПО, которое либо не требует освоения, либо имеет руководства, встроенные в интерфейс. Часто, прочтение руководства не требуется для успешного решения задачи. Однако, опыт прочтения хотя бы одного руководства от первой страницы до последней так, как будто это литературное произведение (технической литературы), -- это очень просветляющий опыт, как минимум очень полезный в деле структурирования ментальной модели навыков построения технических систем, а также крайне полезный в деле понимания, как именно авторы представляли себе применение их программного продукта. Навыкам чтения длинных текстов обычно обучают в средней школе на уроках литературы, и достаточно приятно осознавать небесполезность этих навыков после выпуска. В качестве побочного эффекта, опыт прочтения руководства может помочь студентам самим писать более грамотные и приятные для прочтения руководства.
 - Научите ваших студентов делать домашние задания с таймером, пусть даже не с полноценным профилировщиком, таким как org-mode. Реалистичная оценка трудоёмкости заданий очень хорошо лишает иллюзии всемогущества сильных студентов, а также помогает студентам послабее планировать свою работу.
 - Когда вы пишете учебное пособие, начинайте писать его с составления упражнение, и уже затем пишите текст, склеивающий эти упражнения в единую концепцию и предоставляющий навыки, необходимые для решения. Прочтение SICP без решения задач оказалось практически бесполезным для выполнения этого проекта.
 - Рассмотрите возможность ознакомления студентов со стандартами индустриальных диаграмм (UML, ArchiMate), в рамках своих вводных курсов программирования. Курсы, которые специально разработаны как "курсы по UML", чаще всего страдают оторванностью от реальности. (Мало кому нравится рисовать миллионную вариацию на тему UML-модели банкомана.) Вводное программирование предоставляет намного более близкую студенту предметную область, которую, соответственно, проще отрисовать.

* Материалы

В данной подглаве представлен полный список материало, использованных при написании решебника. (Это _не_ список литературы, использованный для написания настоящего отчёта.)

** Книги

- Structure and Interpretation of Computer Programs 2nd Ed. ([[cite:Abelson1996]])
- Structure and Interpretation of Computer Programs 1st Ed. ([[cite:DBLP:books_mit_AbelsonS85]])
- Modern Fortran Explained 2018. ([[cite:Metcalf_2018_fortran]])
- Revised\(^7\) Report on Algorithmic Language Scheme. ([[cite:shinn2013revised]])
- Logic Programming: A Classified Bibliography. ([[cite:Balbin_1985_logic_programming_bibliography]])
- Chibi-Scheme Manual. ([[cite:chibi_manual]])
- TikZ Manual. ([[cite:tikz_manual]])
- PlantUML Manual. ([[cite:plantuml_manual]])
- UML Weekend Crash Course. ([[cite:pender2002uml]])
- GNU Emacs Manual. ([[cite:stallman_emacs_manual]])
- GNU Emacs Lisp Reference Manual. ([[cite:emacs_lisp_manual]])
- GNU Emacs Org-Mode Manual. ([[cite:Dominik2010orgmode]])
- Debugging With GDB. ([[cite:debugging_with_gdb]])
- Implementations of Prolog. ([[cite:DBLP_books_eh_campbell84_C1984]])

** Программы
- GNU Emacs. ([[cite:software_gnu_emacs]])
- Org-mode for Emacs. ([[cite:software_org_mode]])
- Chibi-Scheme. ([[cite:software_chibi_scheme]])
- MIT/GNU Scheme. [For for portability checks]. ([[cite:software_mit_scheme]])
- Geiser. ([[cite:software_geiser]])
- GNU Debugger (GDB). ([[cite:software_gnu_gdb]])
- luaLaTeX/TeX Live. ([[cite:software_tex_texlive]])
- TikZ/PGF. ([[cite:software_tex_tikz]])
- PlantUML. ([[cite:software_plantuml]])
- Graphviz. ([[cite:software_graphviz]])
- Slackware Linux 14.2-current. ([[cite:software_slackware_linux]])


#+latex: \nocite{Schulte:Davison:Dye:Dominik:2011:JSSOBK:v46i03}

** Статьи

- Revised Report on the Propagator Model. ([[cite:radul_2011_propagator]])
- On Implementing Prolog In Functional Programming. ([[cite:DBLPjournals_ngc_Carlsson84]])
- eu-Prolog, Reference Manual. ([[cite:kohlbecker1984eu]])


#+bibliography: bibliography-bib plain limit:t
#+latex: \printbibliography


* Приложение: Проанализированные данные о сложности задач
Код, для анализа этих данных представлен в приложении:  
[[*Приложение: Код на Emacs Lisp для анализа данных][Приложение: Код на Emacs Lisp для анализа данных]].
** Проанализированная трудоёмкость


# +PLOT: title:"Number of study sessions" ind:1 deps:(4) Type:2d with:lines file:"./experience-report-study-sessions.png" set:"xlabel 'Problem #'" set:"ylabel 'Sessions'"
# +PLOT: title:"Days spent per problem" ind:1 deps:(3) Type:2d with:lines file:"./experience-report-days.png" set:"xlabel 'Problem #'" set:"ylabel 'Days'"
#+PLOT: title:"Minutes spent per problem" ind:1 deps:(5) Type:2d with:lines file:"./experience-report-minutes-per-problem.png" set:"xlabel 'Problem #'" set:"ylabel 'Minutes'"
#+ATTR_LATEX: :center :environment supertabular :align l|p{3.5cm}|p{1cm}|p{0.9cm}|p{0.9cm}
|  No | Exercise Name                                                 | Days Spent | Spans Sessions | Minutes Spent |
|-----+---------------------------------------------------------------+------------+----------------+---------------|
|   1 | Exercise 1.1 Interpreter result                               |      1.211 |              2 |           459 |
|   2 | Exercise 1.2 Prefix form                                      |      0.001 |              1 |             2 |
|   3 | Figure 1.1 Tree representation, showing the value of each su  |      0.007 |              1 |            10 |
|   4 | Exercise 1.4 Compound expressions                             |      0.003 |              1 |             4 |
|   5 | Exercise 1.5 Ben's test                                       |      0.008 |              1 |            11 |
|   6 | Exercise 1.6 If is a special form                             |      0.969 |              2 |           118 |
|   7 | Exercise 1.7 Good enough?                                     |      0.949 |              3 |           436 |
|   8 | Exercise 1.8 Newton's method                                  |      0.197 |              2 |           193 |
|   9 | Exercise 1.10 Ackermann's function                            |      3.038 |              2 |           379 |
|  10 | Exercise 1.11 Recursive vs iterative                          |      0.037 |              1 |            54 |
|  11 | Exercise 1.12 Recursive Pascal's triangle                     |      0.012 |              1 |            17 |
|  12 | Exercise 1.13 Fibonacci                                       |      0.092 |              1 |           132 |
|  13 | Exercise 1.9 Iterative or recursive?                          |      3.722 |              2 |            65 |
|  14 | Exercise 1.14 count-change                                    |      1.038 |              2 |            50 |
|  15 | Exercise 1.15 sine                                            |      0.267 |              2 |           195 |
|  16 | Exercise 1.16 Iterative exponentiation                        |      0.032 |              1 |            46 |
|  17 | Exercise 1.17 Fast multiplication                             |      0.019 |              1 |            28 |
|  18 | Exercise 1.18 Iterative multiplication                        |      0.497 |              2 |            23 |
|  19 | Exercise 1.19 Logarithmic Fibonacci                           |      1.374 |              2 |            93 |
|  20 | Exercise 1.20 GCD applicative vs normal                       |      0.099 |              1 |           142 |
|  21 | Exercise 1.21 smallest-divisor                                |      0.027 |              1 |            39 |
|  22 | Exercise 1.22 timed-prime-test                                |      0.042 |              1 |            61 |
|  23 | Exercise 1.23 (next test-divisor)                             |      0.383 |              2 |             5 |
|  24 | Exercise 1.24 Fermat method                                   |      0.067 |              1 |            96 |
|  25 | Exercise 1.25 expmod                                          |      0.051 |              1 |            74 |
|  26 | Exercise 1.26 square vs mul                                   |      0.003 |              1 |             4 |
|  27 | Exercise 1.27 Carmichael numbers                              |      0.333 |              2 |           102 |
|  28 | Exercise 1.28 Miller-Rabin                                    |      0.110 |              1 |           158 |
|  29 | Exercise 1.29 Simpson's integral                              |      0.464 |              2 |            68 |
|  30 | Exercise 1.30 Iterative sum                                   |      0.030 |              2 |            10 |
|  31 | Exercise 1.31 Product                                         |      0.028 |              1 |            40 |
|  32 | Exercise 1.32 Accumulator                                     |      0.017 |              1 |            24 |
|  33 | Exercise 1.33 filtered-accumulate                             |      0.092 |              1 |           133 |
|  34 | Exercise 1.34 lambda                                          |      0.006 |              1 |             8 |
|  35 | Exercise 1.35 fixed-point                                     |      0.265 |              2 |            87 |
|  36 | Exercise 1.36 fixed-point-with-dampening                      |      0.035 |              1 |            50 |
|  37 | Exercise 1.37 cont-frac                                       |      0.569 |              2 |           348 |
|  38 | Exercise 1.38 euler constant                                  |      0.000 |              1 |             0 |
|  39 | Exercise 1.39 tan-cf                                          |      0.025 |              1 |            36 |
|  40 | Exercise 1.40 newtons-method                                  |      0.205 |              2 |             6 |
|  41 | Exercise 1.41 double-double                                   |      0.010 |              1 |            15 |
|  42 | Exercise 1.42 compose                                         |      0.004 |              1 |             6 |
|  43 | Exercise 1.43 repeated                                        |      0.019 |              1 |            27 |
|  44 | Exercise 1.44 smoothing                                       |      0.099 |              2 |           142 |
|  45 | Exercise 1.45 nth-root                                        |      0.056 |              1 |            80 |
|  46 | Exercise 1.46 iterative-improve                               |      0.033 |              1 |            48 |
|  47 | Exercise 2.1 make-rat                                         |      1.608 |              2 |           109 |
|  48 | Exercise 2.2 make-segment                                     |      0.024 |              1 |            34 |
|  49 | Exercise 2.3 make-rectangle                                   |      2.183 |              2 |           174 |
|  50 | Exercise 2.4 cons-lambda                                      |      0.007 |              1 |            10 |
|  51 | Exercise 2.5 cons-pow                                         |      0.041 |              1 |            59 |
|  52 | Exercise 2.6 Church Numerals                                  |      0.024 |              1 |            34 |
|  53 | Exercise 2.7 make-interval                                    |      0.019 |              1 |            28 |
|  54 | Exercise 2.8 sub-interval                                     |      0.124 |              1 |            58 |
|  55 | Exercise 2.9 interval-width                                   |      0.006 |              1 |             8 |
|  56 | Exercise 2.10 div-interval-better                             |      0.010 |              1 |            15 |
|  57 | Exercise 2.11 mul-interval-nine-cases                         |      0.052 |              1 |            75 |
|  58 | Exercise 2.12 make-center-percent                             |      0.393 |              2 |            43 |
|  59 | Exercise 2.13 formula for tolerance                           |      0.003 |              1 |             5 |
|  60 | Exercise 2.14 parallel-resistors                              |      0.047 |              1 |            68 |
|  61 | Exercise 2.15 better-intervals                                |      0.007 |              1 |            10 |
|  62 | Exercise 2.16 interval-arithmetic                             |      0.002 |              1 |             3 |
|  63 | Exercise 2.17 last-pair                                       |      0.966 |              2 |            89 |
|  64 | Exercise 2.18 reverse                                         |      0.006 |              1 |             9 |
|  65 | Exercise 2.19 coin-values                                     |      0.021 |              1 |            30 |
|  66 | Exercise 2.20 dotted-tail notation                            |      0.311 |              2 |           156 |
|  67 | Exercise 2.21 map-square-list                                 |      0.013 |              1 |            19 |
|  68 | Exercise 2.22 wrong list order                                |      0.007 |              1 |            10 |
|  69 | Exercise 2.23 for-each                                        |      0.006 |              1 |             9 |
|  70 | Exercise 2.24 list-plot-result                                |      0.111 |              2 |            75 |
|  71 | Exercise 2.25 caddr                                           |      0.037 |              1 |            54 |
|  72 | Exercise 2.26 append cons list                                |      0.011 |              1 |            16 |
|  73 | Exercise 2.27 deep-reverse                                    |      0.433 |              2 |            40 |
|  74 | Exercise 2.28 fringe                                          |      0.026 |              1 |            37 |
|  75 | Exercise 2.29 mobile                                          |      0.058 |              1 |            83 |
|  76 | Exercise 2.30 square-tree                                     |      0.100 |              2 |           122 |
|  77 | Exercise 2.31 tree-map square tree                            |      0.019 |              1 |            27 |
|  78 | Exercise 2.32 subsets                                         |      0.010 |              1 |            15 |
|  79 | Exercise 2.33 map-append-length                               |      0.375 |              2 |            96 |
|  80 | Exercise 2.34 horners-rule                                    |      0.006 |              1 |             8 |
|  81 | Exercise 2.35 count-leaves-accumulate                         |      0.011 |              1 |            16 |
|  82 | Exercise 2.36 accumulate-n                                    |      0.006 |              1 |             9 |
|  83 | Exercise 2.37 matrix-*-vector                                 |      0.017 |              1 |            24 |
|  84 | Exercise 2.38 fold-left                                       |      0.372 |              2 |            65 |
|  85 | Exercise 2.39 reverse fold-right fold-left                    |      0.005 |              1 |             7 |
|  86 | Exercise 2.40 unique-pairs                                    |      0.029 |              1 |            42 |
|  87 | Exercise 2.41 triple-sum                                      |      2.195 |              2 |            57 |
|  88 | Figure 2.8 A solution to the eight-queens puzzle.             |      0.001 |              1 |             2 |
|  89 | Exercise 2.42 k-queens                                        |      3.299 |              2 |           122 |
|  90 | Exercise 2.43 slow k-queens                                   |      0.019 |              1 |            28 |
|  91 | Exercise 2.46 make-vect                                       |      2.578 |              5 |           535 |
|  92 | Exercise 2.47 make-frame                                      |      0.083 |              1 |            10 |
|  93 | Exercise 2.48 make-segment                                    |      0.054 |              1 |            78 |
|  94 | Exercise 2.49 segments->painter applications                  |      0.294 |              2 |           139 |
|  95 | Exercise 2.50 flip-horiz and rotate270 and rotate180          |      0.019 |              1 |            27 |
|  96 | Exercise 2.51 below                                           |      1.801 |              4 |           524 |
|  97 | Exercise 2.44 up-split                                        |      1.169 |              2 |            89 |
|  98 | Exercise 2.45 split                                           |      0.113 |              2 |            23 |
|  99 | Exercise 2.52 modify square-limit                             |      0.450 |              2 |            58 |
| 100 | Exercise 2.53 quote introduction                              |      0.008 |              1 |            11 |
| 101 | Exercise 2.54 equal? implementation                           |      0.050 |              1 |            72 |
| 102 | Exercise 2.55 quote quote                                     |      0.000 |              1 |             0 |
| 103 | Exercise 2.56 differentiation-exponentiation                  |      0.393 |              2 |            65 |
| 104 | Exercise 2.57 differentiate-three-sum                         |      0.560 |              3 |           147 |
| 105 | Exercise 2.58 infix-notation                                  |      0.112 |              1 |           161 |
| 106 | Exercise 2.59 union-set                                       |      0.277 |              2 |             6 |
| 107 | Exercise 2.60 duplicate-set                                   |      0.012 |              1 |            17 |
| 108 | Exercise 2.62 ordered-union-set (ordered list)                |      0.973 |              2 |            14 |
| 109 | Exercise 2.61 sets as ordered lists                           |      0.004 |              1 |             6 |
| 110 | Exercise 2.63 tree->list (binary search tree)                 |      0.078 |              1 |           113 |
| 111 | Exercise 2.64 balanced-tree                                   |      2.740 |              3 |           106 |
| 112 | Exercise 2.65 tree-union-set                                  |      9.785 |              2 |            47 |
| 113 | Exercise 2.66 tree-lookup                                     |      0.035 |              1 |            50 |
| 114 | Exercise 2.67 Huffman decode a simple message                 |      0.303 |              3 |           108 |
| 115 | Exercise 2.68 Huffman encode a simple message                 |      0.023 |              1 |            33 |
| 116 | Exercise 2.69 Generate Huffman tree                           |      0.608 |              2 |           160 |
| 117 | Exercise 2.70 Generate a tree and encode a song               |      0.072 |              2 |            57 |
| 118 | Exercise 2.71 Huffman tree for frequencies 5 and 10           |      0.258 |              2 |           202 |
| 119 | Exercise 2.72 Huffman order of growth                         |      0.050 |              2 |            26 |
| 120 | Exercise 2.73 data-driven-deriv                               |      0.605 |              2 |           189 |
| 121 | Exercise 2.74 Insatiable Enterprises                          |      0.410 |              4 |           171 |
| 122 | Exercise 2.75 make-from-mag-ang message passing               |      0.019 |              1 |            28 |
| 123 | Exercise 2.76 types or functions?                             |      0.003 |              1 |             5 |
| 124 | Exercise 2.77 generic-algebra-magnitude                       |      0.772 |              3 |           190 |
| 125 | Exercise 2.78 Ordinary numbers for Scheme                     |      0.212 |              2 |            67 |
| 126 | Exercise 2.79 generic-equality                                |      1.786 |              2 |            28 |
| 127 | Exercise 2.80 Generic arithmetic zero?                        |      0.056 |              1 |            80 |
| 128 | Exercise 2.81 coercion to-itself                              |      0.749 |              3 |           330 |
| 129 | Exercise 2.82 three-argument-coercion                         |      0.433 |              2 |           230 |
| 130 | Exercise 2.83 Numeric Tower and (raise)                       |      0.717 |              3 |           116 |
| 131 | Exercise 2.84 Using ~raise~ (~raise-type~) in ~apply-generic~ |      0.865 |              2 |           135 |
| 132 | Exercise 2.85 Dropping a type                                 |      3.089 |              5 |           507 |
| 133 | Exercise 2.86 Compound complex numbers                        |      0.274 |              2 |           108 |
| 134 | Exercise 2.87 Generalized zero?                               |      0.919 |              4 |           389 |
| 135 | Exercise 2.88 Subtraction of polynomials                      |      0.646 |              3 |            50 |
| 136 | Exercise 2.89 Dense term-lists                                |      0.083 |              1 |           120 |
| 137 | Exercise 2.90 Implementing dense polynomials as a separate p  |      0.400 |              2 |           148 |
| 138 | Exercise 2.91 Division of polynomials                         |      0.111 |              2 |           103 |
| 139 | Exercise 2.92 Ordering of variables so that addition and mul  |      4.556 |             11 |           964 |
| 140 | Exercise 2.93 Rational polynomials                            |      0.378 |              3 |           198 |
| 141 | Exercise 2.94 Greatest-common-divisor for polynomials         |      0.091 |              1 |           131 |
| 142 | Exercise 2.95 Illustrate the non-integer problem              |      0.450 |              2 |           149 |
| 143 | Exercise 2.96 Integerizing factor                             |      0.325 |              2 |           275 |
| 144 | Exercise 2.97 Reduction of polynomials                        |      0.201 |              1 |           140 |
| 145 | Exercise 3.1 accumulators                                     |      0.425 |              2 |            53 |
| 146 | Exercise 3.2 make-monitored                                   |      0.027 |              1 |            39 |
| 147 | Exercise 3.3 password protection                              |      0.010 |              1 |            14 |
| 148 | Exercise 3.4 call-the-cops                                    |      0.010 |              1 |            15 |
| 149 | Exercise 3.5 Monte-Carlo                                      |      0.528 |              2 |            98 |
| 150 | Exercise 3.6 reset a prng                                     |      0.479 |              2 |            68 |
| 151 | Exercise 3.7 Joint accounts                                   |      0.059 |              1 |            85 |
| 152 | Exercise 3.8 Right-to-left vs Left-to-right                   |      0.026 |              1 |            38 |
| 153 | Exercise 3.9 Environment structures                           |     21.030 |             10 |          1100 |
| 154 | Exercise 3.10 Using ~let~ to create state variables           |      4.933 |              2 |           138 |
| 155 | Exercise 3.11 Internal definitions                            |      0.994 |              2 |           219 |
| 156 | Exercise 3.12 Drawing ~append!~                               |      2.966 |              3 |           347 |
| 157 | Exercise 3.13 ~make-cycle~                                    |      0.010 |              1 |            14 |
| 158 | Exercise 3.14 ~mystery~                                       |      0.385 |              2 |            77 |
| 159 | Exercise 3.15 ~set-to-wow!~                                   |      1.942 |              3 |           117 |
| 160 | Exercise 3.16 ~count-pairs~                                   |      0.171 |              1 |           118 |
| 161 | Exercise 3.17 Real ~count-pairs~                              |      0.029 |              1 |            42 |
| 162 | Exercise 3.18 Finding cycles                                  |      0.012 |              1 |            17 |
| 163 | Exercise 3.19 Efficient finding cycles                        |      0.934 |              2 |           205 |
| 164 | Exercise 3.20 Procedural ~set-car!~                           |      0.633 |              2 |           121 |
| 165 | Exercise 3.21 queues                                          |      0.021 |              1 |            30 |
| 166 | Exercise 3.22 procedural queue                                |      0.294 |              2 |            67 |
| 167 | Exercise 3.23 dequeue                                         |      0.049 |              2 |            71 |
| 168 | Exercise 3.24 tolerant tables                                 |      0.780 |              3 |            33 |
| 169 | Exercise 3.25 multilevel tables                               |      2.103 |              2 |           486 |
| 170 | Exercise 3.26 binary tree table                               |      0.013 |              1 |            18 |
| 171 | Exercise 3.27 memoization                                     |      0.802 |              2 |             2 |
| 172 | Exercise 3.28 primitive or-gate                               |      1.316 |              2 |           783 |
| 173 | Exercise 3.29 Compound or-gate                                |      0.001 |              1 |             2 |
| 174 | Exercise 3.30 ripple-carry adder                              |      0.009 |              1 |            13 |
| 175 | Exercise 3.31 Initial propagation                             |      0.013 |              1 |            18 |
| 176 | Exercise 3.32 Order matters                                   |      0.007 |              1 |            10 |
| 177 | Exercise 3.33 averager constraint                             |      9.460 |              3 |           198 |
| 178 | Exercise 3.34 Wrong squarer                                   |      0.042 |              1 |            61 |
| 179 | Exercise 3.35 Correct squarer                                 |      0.012 |              1 |            17 |
| 180 | Exercise 3.36 Connector environment diagram                   |      3.319 |              3 |           263 |
| 181 | Exercise 3.37 Expression-based constraints                    |      0.037 |              1 |            53 |
| 182 | Exercise 3.38 Timing                                          |      0.061 |              1 |            88 |
| 183 | Exercise 3.39 Serializer                                      |      1.266 |              4 |           269 |
| 184 | Exercise 3.40 Three parallel multiplications                  |      5.973 |              3 |           332 |
| 185 | Exercise 3.41 Better protected account                        |      4.229 |              2 |            97 |
| 186 | Exercise 3.42 Saving on serializers                           |      0.023 |              1 |            33 |
| 187 | Exercise 3.43 Multiple serializations                         |      0.040 |              1 |            58 |
| 188 | Exercise 3.44 Transfer money                                  |      0.005 |              1 |             7 |
| 189 | Exercise 3.45 new plus old serializers                        |      0.004 |              1 |             6 |
| 190 | Exercise 3.46 broken test-and-set!                            |      0.007 |              1 |            10 |
| 191 | Exercise 3.47 semaphores                                      |      1.044 |              2 |            53 |
| 192 | Exercise 3.48 serialized-exchange deadlock                    |      0.022 |              1 |            31 |
| 193 | Exercise 3.49 When numbering accounts doesn't work            |      0.008 |              1 |            11 |
| 194 | Exercise 3.50 stream-map multiple arguments                   |      0.317 |              3 |            96 |
| 195 | Exercise 3.51 stream-show                                     |      0.007 |              1 |            10 |
| 196 | Exercise 3.52 streams with mind-boggling                      |      0.034 |              1 |            49 |
| 197 | Exercise 3.53 stream power of two                             |      0.016 |              1 |            23 |
| 198 | Exercise 3.54 mul-streams                                     |      0.005 |              1 |             7 |
| 199 | Exercise 3.55 streams partial-sums                            |      0.013 |              1 |            18 |
| 200 | Exercise 3.56 Hamming's streams-merge                         |      0.015 |              1 |            21 |
| 201 | Exercise 3.57 exponential additions fibs                      |      0.007 |              1 |            10 |
| 202 | Exercise 3.58 Cryptic stream                                  |      0.010 |              1 |            14 |
| 203 | Exercise 3.59 power series                                    |      0.422 |              2 |            30 |
| 204 | Exercise 3.60 mul-series                                      |      0.048 |              1 |            69 |
| 205 | Exercise 3.61 power-series-inversion                          |      0.087 |              1 |           126 |
| 206 | Exercise 3.62 div-series                                      |      0.006 |              1 |             8 |
| 207 | Exercise 3.63 sqrt-stream                                     |      0.299 |              2 |             8 |
| 208 | Exercise 3.64 stream-limit                                    |      1.546 |              2 |            55 |
| 209 | Exercise 3.65 approximating logarithm                         |      0.039 |              1 |            56 |
| 210 | Exercise 3.66 lazy pairs                                      |      0.515 |              2 |           107 |
| 211 | Exercise 3.67 all possible pairs                              |      0.010 |              1 |            14 |
| 212 | Exercise 3.68 pairs-louis                                     |      0.012 |              1 |            17 |
| 213 | Exercise 3.70 merge-weighted                                  |      0.522 |              2 |           188 |
| 214 | Exercise 3.71 Ramanujan numbers                               |      0.035 |              1 |            51 |
| 215 | Exercise 3.72 Ramanujan 3-numbers                             |      0.901 |              2 |           187 |
| 216 | Figure 3.32                                                   |      0.022 |              1 |            32 |
| 217 | Exercise 3.73 RC-circuit                                      |      0.090 |              1 |           130 |
| 218 | Exercise 3.74 zero-crossings                                  |      0.153 |              1 |           221 |
| 219 | Exercise 3.75 filtering signals                               |      0.056 |              1 |            81 |
| 220 | Exercise 3.76 stream-smooth                                   |      0.073 |              2 |            36 |
| 221 | Exercise 3.77                                                 |      0.038 |              1 |            55 |
| 222 | Exercise 3.78 second order differential equation              |      0.039 |              1 |            56 |
| 223 | Exercise 3.79 general second-order ode                        |      0.007 |              1 |            10 |
| 224 | Figure 3.36                                                   |      0.058 |              1 |            84 |
| 225 | Exercise 3.80 RLC circuit                                     |      0.013 |              1 |            19 |
| 226 | Exercise 3.81  renerator-in-streams                           |      0.040 |              1 |            57 |
| 227 | Exercise 3.82 streams Monte-Carlo                             |      0.378 |              2 |            57 |
| 228 | Exercise 4.1 list-of-values ordered                           |      0.437 |              2 |            14 |
| 229 | Exercise 4.2 application before assignments                   |      0.021 |              1 |            30 |
| 230 | Exercise 4.3 data-directed eval                               |      0.030 |              1 |            43 |
| 231 | Exercise 4.4 eval-and and eval-or                             |      0.035 |              1 |            50 |
| 232 | Exercise 4.5 cond with arrow                                  |     12.765 |              7 |          1252 |
| 233 | Exercise 4.6 Implementing let                                 |      0.019 |              1 |            27 |
| 234 | Exercise 4.7 Implementing let*                                |      0.046 |              1 |            66 |
| 235 | Exercise 4.8 Implementing named let                           |      0.070 |              1 |           101 |
| 236 | Exercise 4.9 Implementing until                               |      0.928 |              3 |           102 |
| 237 | Exercise 4.10 Modifying syntax                                |     14.168 |              3 |           462 |
| 238 | Exercise 4.11 Environment as a list of bindings               |      4.368 |              2 |           194 |
| 239 | Exercise 4.12 Better abstractions for setting a value         |      0.529 |              2 |           120 |
| 240 | Exercise 4.13 Implementing ~make-unbound!~                    |      0.550 |              2 |           149 |
| 241 | Exercise 4.14 meta map versus built-in map                    |      0.004 |              1 |             6 |
| 242 | Exercise 4.15 The ~halts?~ predicate                          |      0.018 |              1 |            26 |
| 243 | Exercise 4.16 Simultaneous internal definitions               |      0.162 |              2 |           177 |
| 244 | Exercise 4.17 Environment with simultaneous definitions       |      0.036 |              1 |            52 |
| 245 | Exercise 4.18 Alternative scanning                            |      0.018 |              1 |            26 |
| 246 | Exercise 4.19 Mutual simultaneous definitions                 |      0.220 |              2 |            96 |
| 247 | Exercise 4.20 letrec                                          |      0.206 |              2 |           195 |
| 248 | Exercise 4.21 Y-combinator                                    |      0.013 |              1 |            18 |
| 249 | Exercise 4.22 Extending evaluator to support ~let~            |      1.768 |              3 |           144 |
| 250 | Exercise 4.23 Analysing sequences                             |      0.005 |              1 |             7 |
| 251 | Exercise 4.24 Analysis time test                              |      0.022 |              1 |            32 |
| 252 | Exercise 4.25 lazy factorial                                  |      0.034 |              1 |            49 |
| 253 | Exercise 4.26 unless as a special form                        |      0.313 |              1 |           451 |
| 254 | Exercise 4.27 Working with mutation in lazy interpreters      |      0.515 |              2 |           112 |
| 255 | Exercise 4.28 Eval before applying                            |      0.005 |              1 |             7 |
| 256 | Exercise 4.29 Lazy evaluation is slow without memoization     |      0.035 |              1 |            50 |
| 257 | Exercise 4.30 Lazy sequences                                  |      0.153 |              2 |            74 |
| 258 | Exercise 4.31 Lazy arguments with syntax extension            |      0.092 |              2 |           112 |
| 259 | Exercise 4.32 streams versus lazy lists                       |      0.503 |              2 |            87 |
| 260 | Exercise 4.33 quoted lazy lists                               |      0.097 |              2 |           103 |
| 261 | Exercise 4.34 printing lazy lists                             |      0.219 |              3 |           205 |
| 262 | Exercise 4.50 The ~ramb~ operator                             |      0.813 |              4 |           266 |
| 263 | Exercise 4.35 ~an-integer-between~ and Pythagorean triples    |      0.103 |              2 |           138 |
| 264 | Exercise 3.69 triples                                         |      0.115 |              2 |            85 |
| 265 | Exercise 4.36 infinite search for Pythagorean triples         |      0.011 |              1 |            16 |
| 266 | Exercise 4.37 another method for triples                      |      0.035 |              1 |            51 |
| 267 | Exercise 4.38 Logical puzzle - Not same floor                 |      0.027 |              1 |            39 |
| 268 | Exercise 4.39 Order of restrictions                           |      0.003 |              1 |             5 |
| 269 | Exercise 4.40 People to floor assignment                      |      0.019 |              1 |            28 |
| 270 | Exercise 4.41 Ordinary Scheme to solve the problem            |      0.072 |              1 |           103 |
| 271 | Exercise 4.42 The liars puzzle                                |      0.503 |              1 |            81 |
| 272 | Exercise 4.43 Problematical Recreations                       |      0.052 |              1 |            75 |
| 273 | Exercise 4.44 Nondeterministic eight queens                   |      0.074 |              1 |           106 |
| 274 | Exercise 4.45 Five parses                                     |      0.186 |              3 |           145 |
| 275 | Exercise 4.46 Order of parsing                                |      0.007 |              1 |            10 |
| 276 | Exercise 4.47 Parse verb phrase by Louis                      |      0.013 |              1 |            18 |
| 277 | Exercise 4.48 Extending the grammar                           |      0.037 |              1 |             1 |
| 278 | Exercise 4.49 Alyssa's generator                              |      0.031 |              1 |            45 |
| 279 | Exercise 4.51 Implementing ~permanent-set!~                   |      0.030 |              1 |            43 |
| 280 | Exercise 4.52 ~if-fail~                                       |      0.063 |              1 |            91 |
| 281 | Exercise 4.53 test evaluation                                 |      0.005 |              1 |             7 |
| 282 | Exercise 4.54 ~analyze-require~                               |      0.468 |              2 |            31 |
| 283 | Exercise 4.55 Simple queries                                  |      0.258 |              2 |           372 |
| 284 | Exercise 4.56 Compound queries                                |      0.018 |              1 |            26 |
| 285 | Exercise 4.57 custom rules                                    |      0.147 |              3 |           112 |
| 286 | Exercise 4.58 big shot                                        |      0.025 |              1 |            36 |
| 287 | Exercise 4.59 meetings                                        |      0.031 |              1 |            45 |
| 288 | Exercise 4.60 pairs live near                                 |      0.016 |              1 |            23 |
| 289 | Exercise 4.61 next-to relation                                |      0.008 |              1 |            11 |
| 290 | Exercise 4.62 last-pair                                       |      0.033 |              1 |            48 |
| 291 | Exercise 4.63 Genesis                                         |      0.423 |              2 |            40 |
| 292 | Figure 4.6 How the system works                               |      0.022 |              1 |            31 |
| 293 | Exercise 4.64 broken outranked-by                             |      0.065 |              1 |            94 |
| 294 | Exercise 4.65 second-degree subordinates                      |      0.012 |              1 |            17 |
| 295 | Exercise 4.66 Ben's accumulation                              |      0.013 |              1 |            18 |
| 296 | Exercise 4.70 Cons-stream delays its second argument          |      0.167 |              3 |            79 |
| 297 | Exercise 4.72 interleave-stream                               |      0.002 |              1 |             3 |
| 298 | Exercise 4.73 flatten-stream delays                           |      0.006 |              1 |             8 |
| 299 | Exercise 4.67 loop detector                                   |      0.251 |              1 |           361 |
| 300 | Exercise 4.68 reverse rule                                    |      0.686 |              2 |           321 |
| 301 | Exercise 4.69 great grandchildren                             |      0.080 |              2 |            65 |
| 302 | Exercise 4.71 Louis' simple queries                           |      0.134 |              2 |            69 |
| 303 | Exercise 4.74 Alyssa's streams                                |      0.044 |              1 |            64 |
| 304 | Exercise 4.75 ~unique~ special form                           |      0.055 |              1 |            79 |
| 305 | Exercise 4.76 improving ~and~                                 |      0.797 |              2 |           438 |
| 306 | Figure 5.2 Controller for a GCD Machine                       |      0.167 |              3 |           124 |
| 307 | Exercise 5.1 Register machine plot                            |      0.020 |              1 |            29 |
| 308 | Figure 5.1 Data paths for a Register Machine                  |      0.599 |              2 |           115 |
| 309 | Exercise 5.2 Register machine language description of Exerci  |      0.006 |              1 |             8 |
| 310 | Exercise 5.3 Machine for ~sqrt~ using Newton Method           |      0.306 |              2 |           286 |
| 311 | Exercise 5.4 Recursive register machines                      |      1.001 |              4 |           274 |
| 312 | Exercise 5.5 Hand simulation for factorial and Fibonacci      |      0.110 |              1 |           158 |
| 313 | Exercise 5.6 Fibonacci machine extra instructions             |      0.011 |              1 |            16 |
| 314 | Exercise 5.7 Test the 5.4 machine on a simulator              |      0.458 |              2 |           133 |
| 315 | Exercise 5.8 Ambiguous labels                                 |      0.469 |              1 |           160 |
| 316 | Exercise 5.9 Prohibit (op)s on labels                         |      0.017 |              1 |            25 |
| 317 | Exercise 5.10 Changing syntax                                 |      0.011 |              1 |            16 |
| 318 | Exercise 5.11 Save and restore                                |      0.619 |              3 |           186 |
| 319 | Exercise 5.12 Data paths from controller                      |      0.424 |              2 |           183 |
| 320 | Exercise 5.13 Registers from controller                       |      0.470 |              2 |           101 |
| 321 | Exercise 1.3 Sum of squares                                   |      1.044 |              1 |             6 |
| 322 | Exercise 5.14 Profiling                                       |      0.347 |              2 |            57 |
| 323 | Exercise 5.15 Instruction counting                            |      0.052 |              1 |            75 |
| 324 | Exercise 5.16 Tracing execution                               |      0.058 |              1 |            83 |
| 325 | Exercise 5.18 Register tracing                                |      0.631 |              2 |            90 |
| 326 | Exercise 5.19 Breakpoints                                     |      0.149 |              1 |           215 |
| 327 | Exercise 5.17 Printing labels                                 |      0.001 |              1 |             1 |
| 328 | Exercise 5.20 Drawing a list "~(#1=(1 . 2) #1)~"              |      0.189 |              2 |           139 |
| 329 | Exercise 5.21 Register machines for list operations           |      0.617 |              2 |           115 |
| 330 | Exercise 5.22 ~append~ and ~append!~ as register machines     |      0.047 |              1 |            68 |
| 331 | Exercise 5.23 Extending EC-evaluator with ~let~ and ~cond~    |      0.862 |              4 |           363 |
| 332 | Exercise 5.24 Making ~cond~ a primitive                       |      0.160 |              2 |           199 |
| 333 | Exercise 5.25 Normal-order (lazy) evaluation                  |      1.010 |              4 |           342 |
| 334 | Exercise 5.26 Explore tail recursion with ~factorial~         |      0.195 |              2 |            26 |
| 335 | Exercise 5.27 Stack depth for a recursive factorial           |      0.008 |              1 |            11 |
| 336 | Exercise 5.28 Interpreters without tail recursion             |      0.028 |              1 |            40 |
| 337 | Exercise 5.29 Stack in tree-recursive Fibonacci               |      0.015 |              1 |            21 |
| 338 | Exercise 5.30 Errors                                          |      0.615 |              3 |           147 |
| 339 | Exercise 5.31 a ~preserving~ mechanism                        |      0.417 |              2 |           161 |
| 340 | Exercise 5.32 symbol-lookup optimization                      |      0.052 |              1 |            75 |
| 341 | Exercise 5.33 compiling ~factorial-alt~                       |      0.753 |              2 |           267 |
| 342 | Exercise 5.34 compiling iterative factorial                   |      0.169 |              1 |           243 |
| 343 | Exercise 5.35 Decompilation                                   |      0.022 |              1 |            32 |
| 344 | Exercise 5.36 Order of evaluation                             |      0.845 |              4 |           256 |
| 345 | Exercise 5.37 ~preserving~                                    |      0.135 |              1 |           194 |
| 346 | Exercise 5.38 open code primitives                            |      0.914 |              3 |           378 |
| 347 | Exercise 5.41 ~find-variable~                                 |      0.028 |              1 |            40 |
| 348 | Exercise 5.39 ~lexical-address-lookup~                        |      0.044 |              1 |            64 |
| 349 | Exercise 5.42 Rewrite ~compile-variable~ and ~compile-assign  |      0.679 |              2 |           118 |
| 350 | Exercise 5.40 maintaining a compile-time environment          |      0.085 |              2 |           101 |
| 351 | Exercise 5.43 Scanning out defines                            |      0.249 |              3 |           261 |
| 352 | Exercise 5.44 open code with compile-time environment         |      0.020 |              1 |            29 |
| 353 | Exercise 5.45 stack usage analysis for a ~factorial~          |      0.528 |              1 |            61 |
| 354 | Exercise 5.46 stack usage analysis for ~fibonacci~            |      0.017 |              1 |            25 |
| 355 | Exercise 5.47 calling interpreted procedures                  |      0.049 |              1 |            71 |
| 356 | Exercise 5.48 ~compile-and-run~                               |      1.020 |              3 |           264 |
| 357 | Exercise 5.49 ~read-compile-execute-print~ loop               |      0.015 |              1 |            22 |
| 358 | Exercise 4.77 lazy queries                                    |      4.129 |              9 |          1214 |
| 359 | Exercise 5.50 Compiling the metacircular evaluator            |      0.007 |              1 |            10 |
| 360 | Exercise 4.78 non-deterministic queries                       |      0.867 |              6 |           602 |
| 361 | Exercise 5.51 Translating the EC-evaluator into a low-level   |     28.962 |             33 |          5684 |
| 362 | Exercise 5.52 Making a compiler for Scheme                    |     22.975 |             13 |          2359 |
| 363 | Exercise 4.79 prolog environments                             |      4.285 |              5 |           940 |
#+TBLFM: $1=@#-1

** Гистограмма трудоёмкости линейная

#+PLOT: title:"Difficulty histogram linear" deps:(2) Type:2d with:histograms file:"./experience-report-hardness-histogram-linear.png" set:"ylabel 'Problems in a bin'" set:"xlabel 'Difficulty [hours]'"
| Bin Lower Bound (Minutes) | N. tasks |
|---------------------------+----------|
|                        0. |      301 |
|                   177.625 |       38 |
|                    355.25 |       14 |
|                   532.875 |        2 |
|                     710.5 |        1 |
|                   888.125 |        2 |
|                   1065.75 |        2 |
|                  1243.375 |        1 |
|                     1421. |        0 |
|                  1598.625 |        0 |
|                   1776.25 |        0 |
|                  1953.875 |        0 |
|                    2131.5 |        0 |
|                  2309.125 |        1 |
|                   2486.75 |        0 |
|                  2664.375 |        0 |
|                     2842. |        0 |
|                  3019.625 |        0 |
|                   3197.25 |        0 |
|                  3374.875 |        0 |
|                    3552.5 |        0 |
|                  3730.125 |        0 |
|                   3907.75 |        0 |
|                  4085.375 |        0 |
|                     4263. |        0 |
|                  4440.625 |        0 |
|                   4618.25 |        0 |
|                  4795.875 |        0 |
|                    4973.5 |        0 |
|                  5151.125 |        1 |
#+TBLFM: $1=(@#-2)*177.625

** Гистограмма трудоёмкости логарифмическая

#+PLOT: title:"Difficulty histogram logarithmic" deps:(2) Type:2d with:histograms file:"./experience-report-hardness-histogram-logarithmic.png" set:"ylabel 'Problems in a bin'" set:"xlabel 'Difficulty [log(hours)]'"
| Bin Lower Bound (Minutes) | N. tasks |
|---------------------------+----------|
|                         1 |        2 |
|                         2 |        6 |
|                         4 |       15 |
|                         8 |       41 |
|                        16 |       55 |
|                        32 |       67 |
|                        64 |       85 |
|                       128 |       52 |
|                       256 |       29 |
|                       512 |        6 |
|                      1024 |        3 |
|                      2048 |        1 |
|                      4096 |        1 |
#+TBLFM: $1=pow(2,(@#-2))


* Приложение: данные по учебным сессиям

This section lists the data on each study session in the 
#+latex: \newline
"BEGIN_TIMESTAMP-END_TIMESTAMP:duration" 
#+latex: \newline
format.

The earliest time stamp also marks the beginning of the whole project.

#+attr_latex: :left
#+name: study-sessions-data
#+BEGIN_SRC elisp
[2020-05-10 Sun 14:39]-[2020-05-10 Sun 18:00]|3:21
[2020-05-09 Sat 19:13]-[2020-05-09 Sat 22:13]|3:00
[2020-05-09 Sat 09:34]-[2020-05-09 Sat 14:34]|5:00
[2020-05-08 Fri 21:45]-[2020-05-08 Fri 23:17]|1:32
[2020-05-08 Fri 18:30]-[2020-05-08 Fri 21:18]|2:48
[2020-05-06 Wed 10:12]-[2020-05-06 Wed 11:09]|0:57
[2020-05-05 Tue 12:11]-[2020-05-06 Wed 00:00]|11:49
[2020-05-04 Mon 18:20]-[2020-05-05 Tue 00:30]|6:10
[2020-05-04 Mon 14:02]-[2020-05-04 Mon 17:43]|3:41
[2020-05-03 Sun 21:03]-[2020-05-03 Sun 22:02]|0:59
[2020-04-30 Thu 09:28]-[2020-04-30 Thu 11:23]|1:55
[2020-04-29 Wed 20:00]-[2020-04-29 Wed 23:25]|3:25
[2020-04-28 Tue 22:55]-[2020-04-29 Wed 00:11]|1:16
[2020-04-28 Tue 21:00]-[2020-04-28 Tue 22:50]|1:50
[2020-04-27 Mon 20:09]-[2020-04-27 Mon 22:09]|2:00
[2020-04-26 Sun 20:10]-[2020-04-26 Sun 23:52]|3:42
[2020-04-21 Tue 11:01]-[2020-04-21 Tue 12:26]|1:25
[2020-04-13 Mon 11:40]-[2020-04-13 Mon 11:55]|0:15
[2020-04-11 Sat 11:50]-[2020-04-11 Sat 15:50]|4:00
[2020-04-10 Fri 09:50]-[2020-04-10 Fri 14:26]|4:36
[2020-04-09 Thu 19:50]-[2020-04-09 Thu 23:10]|3:20
[2020-04-09 Thu 09:55]-[2020-04-09 Thu 13:00]|3:05
[2020-04-08 Wed 22:50]-[2020-04-08 Wed 23:55]|1:05
[2020-04-08 Wed 18:30]-[2020-04-08 Wed 21:11]|2:41
[2020-04-08 Wed 09:15]-[2020-04-08 Wed 12:15]|3:00
[2020-04-07 Tue 20:46]-[2020-04-07 Tue 23:37]|2:51
[2020-04-07 Tue 09:41]-[2020-04-07 Tue 11:57]|2:16
[2020-04-06 Mon 18:58]-[2020-04-06 Mon 21:20]|2:22
[2020-04-06 Mon 12:09]-[2020-04-06 Mon 14:15]|2:06
[2020-04-05 Sun 11:30]-[2020-04-05 Sun 15:11]|3:41
[2020-04-04 Sat 22:08]-[2020-04-04 Sat 22:45]|0:37
[2020-04-04 Sat 17:54]-[2020-04-04 Sat 20:50]|2:56
[2020-04-04 Sat 17:24]-[2020-04-04 Sat 17:41]|0:17
[2020-04-04 Sat 15:15]-[2020-04-04 Sat 16:10]|0:55
[2020-04-03 Fri 20:22]-[2020-04-03 Fri 22:21]|1:59
[2020-04-01 Wed 13:05]-[2020-04-01 Wed 15:05]|2:00
[2020-03-29 Sun 13:05]-[2020-03-29 Sun 22:05]|9:00
[2020-03-28 Sat 13:04]-[2020-03-28 Sat 22:04]|9:00
[2020-03-26 Thu 20:20]-[2020-03-26 Thu 23:33]|3:13
[2020-03-26 Thu 10:43]-[2020-03-26 Thu 14:39]|3:56
[2020-03-24 Tue 20:00]-[2020-03-24 Tue 23:50]|3:50
[2020-03-24 Tue 09:10]-[2020-03-24 Tue 12:34]|3:24
[2020-03-23 Mon 19:56]-[2020-03-23 Mon 23:06]|3:10
[2020-03-23 Mon 10:23]-[2020-03-23 Mon 13:23]|3:00
[2020-03-23 Mon 09:06]-[2020-03-23 Mon 10:56]|1:50
[2020-03-22 Sun 18:46]-[2020-03-22 Sun 22:45]|3:59
[2020-03-22 Sun 12:45]-[2020-03-22 Sun 13:46]|1:01
[2020-03-21 Sat 19:07]-[2020-03-21 Sat 21:35]|2:28
[2020-03-17 Tue 19:11]-[2020-03-17 Tue 22:11]|3:00
[2020-03-15 Sun 09:10]-[2020-03-15 Sun 12:41]|3:31
[2020-03-14 Sat 23:01]-[2020-03-14 Sat 23:54]|0:53
[2020-03-14 Sat 20:46]-[2020-03-14 Sat 23:01]|2:15
[2020-03-14 Sat 20:39]-[2020-03-14 Sat 20:46]|0:07
[2020-03-14 Sat 17:23]-[2020-03-14 Sat 20:39]|3:16
[2020-03-14 Sat 12:00]-[2020-03-14 Sat 15:53]|3:53
[2020-03-13 Fri 20:01]-[2020-03-13 Fri 23:01]|3:00
[2020-03-13 Fri 09:20]-[2020-03-13 Fri 11:58]|2:38
[2020-03-12 Thu 20:30]-[2020-03-12 Thu 23:29]|2:59
[2020-03-11 Wed 12:12]-[2020-03-11 Wed 13:18]|1:06
[2020-03-11 Wed 10:45]-[2020-03-11 Wed 11:09]|0:24
[2020-03-11 Wed 09:15]-[2020-03-11 Wed 10:45]|1:30
[2020-03-10 Tue 20:22]-[2020-03-11 Wed 00:09]|3:47
[2020-03-10 Tue 09:08]-[2020-03-10 Tue 13:44]|4:36
[2020-03-09 Mon 22:28]-[2020-03-09 Mon 23:32]|1:04
[2020-03-09 Mon 09:08]-[2020-03-09 Mon 11:59]|2:51
[2020-03-08 Sun 18:30]-[2020-03-08 Sun 21:29]|2:59
[2020-03-08 Sun 16:51]-[2020-03-08 Sun 18:08]|1:17
[2020-03-08 Sun 13:50]-[2020-03-08 Sun 15:36]|1:46
[2020-03-08 Sun 11:56]-[2020-03-08 Sun 13:28]|1:32
[2020-03-07 Sat 18:00]-[2020-03-07 Sat 21:36]|3:36
[2020-03-07 Sat 11:35]-[2020-03-07 Sat 16:09]|4:34
[2020-03-06 Fri 17:37]-[2020-03-06 Fri 21:48]|4:11
[2020-03-06 Fri 13:11]-[2020-03-06 Fri 14:16]|1:05
[2020-03-06 Fri 09:42]-[2020-03-06 Fri 12:39]|2:57
[2020-03-05 Thu 16:54]-[2020-03-05 Thu 21:34]|4:40
[2020-03-05 Thu 08:58]-[2020-03-05 Thu 13:24]|4:26
[2020-03-04 Wed 19:51]-[2020-03-04 Wed 22:51]|3:00
[2020-03-04 Wed 11:33]-[2020-03-04 Wed 12:31]|0:58
[2020-03-04 Wed 09:32]-[2020-03-04 Wed 11:01]|1:29
[2020-03-03 Tue 19:13]-[2020-03-03 Tue 21:46]|2:33
[2020-03-03 Tue 12:20]-[2020-03-03 Tue 14:58]|2:38
[2020-03-03 Tue 09:13]-[2020-03-03 Tue 11:57]|2:44
[2020-03-02 Mon 18:30]-[2020-03-02 Mon 18:50]|0:20
[2020-03-02 Mon 12:01]-[2020-03-02 Mon 14:43]|2:42
[2020-03-02 Mon 09:02]-[2020-03-02 Mon 11:30]|2:28
[2020-03-01 Sun 19:07]-[2020-03-01 Sun 21:25]|2:18
[2020-03-01 Sun 17:50]-[2020-03-01 Sun 18:41]|0:51
[2020-03-01 Sun 11:09]-[2020-03-01 Sun 15:15]|4:06
[2020-02-29 Sat 21:30]-[2020-02-29 Sat 22:16]|0:46
[2020-02-29 Sat 12:48]-[2020-02-29 Sat 19:17]|6:29
[2020-02-28 Fri 20:21]-[2020-02-28 Fri 23:10]|2:49
[2020-02-28 Fri 18:26]-[2020-02-28 Fri 19:22]|0:56
[2020-02-28 Fri 11:55]-[2020-02-28 Fri 12:02]|0:07
[2020-02-27 Thu 09:20]-[2020-02-27 Thu 10:57]|1:37
[2020-02-26 Wed 20:47]-[2020-02-26 Wed 23:44]|2:57
[2020-02-26 Wed 12:07]-[2020-02-26 Wed 13:40]|1:33
[2020-02-26 Wed 09:29]-[2020-02-26 Wed 11:00]|1:31
[2020-02-25 Tue 19:18]-[2020-02-25 Tue 22:51]|3:33
[2020-02-25 Tue 09:01]-[2020-02-25 Tue 10:42]|1:41
[2020-02-24 Mon 19:23]-[2020-02-25 Tue 00:15]|4:52
[2020-02-24 Mon 13:00]-[2020-02-24 Mon 13:36]|0:36
[2020-02-24 Mon 10:08]-[2020-02-24 Mon 12:39]|2:31
[2020-02-23 Sun 19:20]-[2020-02-23 Sun 20:48]|1:28
[2020-02-23 Sun 12:52]-[2020-02-23 Sun 16:45]|3:53
[2020-02-22 Sat 21:35]-[2020-02-23 Sun 00:25]|2:50
[2020-02-22 Sat 19:59]-[2020-02-22 Sat 21:03]|1:04
[2020-02-22 Sat 12:20]-[2020-02-22 Sat 18:35]|6:15
[2020-02-21 Fri 20:55]-[2020-02-22 Sat 00:30]|3:35
[2020-02-21 Fri 17:30]-[2020-02-21 Fri 18:51]|1:21
[2020-02-21 Fri 10:40]-[2020-02-21 Fri 16:40]|6:00
[2020-02-20 Thu 17:00]-[2020-02-20 Thu 23:33]|6:33
[2020-02-20 Thu 14:43]-[2020-02-20 Thu 15:08]|0:25
[2020-02-20 Thu 10:05]-[2020-02-20 Thu 13:54]|3:49
[2020-02-19 Wed 21:35]-[2020-02-20 Thu 00:36]|3:01
[2020-02-19 Wed 19:50]-[2020-02-19 Wed 21:30]|1:40
[2020-02-19 Wed 13:34]-[2020-02-19 Wed 18:15]|4:41
[2020-02-19 Wed 11:10]-[2020-02-19 Wed 13:34]|2:24
[2020-02-18 Tue 21:05]-[2020-02-19 Wed 00:27]|3:22
[2020-02-18 Tue 19:02]-[2020-02-18 Tue 20:13]|1:11
[2020-02-18 Tue 16:58]-[2020-02-18 Tue 18:36]|1:38
[2020-02-18 Tue 10:55]-[2020-02-18 Tue 15:21]|4:26
[2020-02-17 Mon 19:20]-[2020-02-18 Tue 00:12]|4:52
[2020-02-17 Mon 15:20]-[2020-02-17 Mon 18:00]|2:40
[2020-02-17 Mon 14:17]-[2020-02-17 Mon 15:09]|0:52
[2020-02-16 Sun 21:21]-[2020-02-17 Mon 00:52]|3:31
[2020-02-16 Sun 20:03]-[2020-02-16 Sun 20:14]|0:11
[2020-02-16 Sun 19:00]-[2020-02-16 Sun 19:30]|0:30
[2020-02-16 Sun 16:06]-[2020-02-16 Sun 18:38]|2:32
[2020-02-16 Sun 12:59]-[2020-02-16 Sun 14:37]|1:38
[2020-02-16 Sun 10:30]-[2020-02-16 Sun 12:22]|1:52
[2020-02-15 Sat 22:10]-[2020-02-15 Sat 23:52]|1:42
[2020-02-15 Sat 21:01]-[2020-02-15 Sat 21:50]|0:49
[2020-02-15 Sat 15:03]-[2020-02-15 Sat 18:34]|3:31
[2020-02-14 Fri 18:53]-[2020-02-15 Sat 04:33]|9:40
[2020-02-13 Thu 16:15]-[2020-02-13 Thu 17:21]|1:06
[2020-02-13 Thu 00:12]-[2020-02-13 Thu 01:45]|1:33
[2020-02-12 Wed 18:36]-[2020-02-12 Wed 22:30]|3:54
[2020-02-12 Wed 13:16]-[2020-02-12 Wed 14:55]|1:39
[2020-02-12 Wed 08:37]-[2020-02-12 Wed 12:20]|3:43
[2020-02-11 Tue 18:51]-[2020-02-11 Tue 21:54]|3:03
[2020-02-11 Tue 04:30]-[2020-02-11 Tue 08:09]|3:39
[2020-02-10 Mon 06:42]-[2020-02-10 Mon 07:28]|0:46
[2020-02-06 Thu 15:42]-[2020-02-06 Thu 22:08]|6:26
[2020-02-01 Sat 15:05]-[2020-02-01 Sat 15:36]|0:31
[2020-01-23 Thu 17:06]-[2020-01-23 Thu 18:51]|1:45
[2020-01-22 Wed 20:53]-[2020-01-22 Wed 21:05]|0:12
[2020-01-22 Wed 13:40]-[2020-01-22 Wed 20:20]|6:40
[2020-01-21 Tue 15:33]-[2020-01-21 Tue 16:57]|1:24
[2020-01-17 Fri 19:13]-[2020-01-17 Fri 23:00]|3:47
[2020-01-11 Sat 10:56]-[2020-01-11 Sat 18:24]|7:28
[2020-01-10 Fri 22:20]-[2020-01-10 Fri 23:56]|1:36
[2020-01-10 Fri 09:40]-[2020-01-10 Fri 13:20]|3:40
[2020-01-09 Thu 20:10]-[2020-01-09 Thu 22:15]|2:05
[2020-01-09 Thu 08:50]-[2020-01-09 Thu 09:55]|1:05
[2020-01-08 Wed 19:21]-[2020-01-09 Thu 00:42]|5:21
[2020-01-08 Wed 09:20]-[2020-01-08 Wed 18:12]|8:52
[2020-01-07 Tue 16:31]-[2020-01-07 Tue 18:31]|2:00
[2020-01-07 Tue 08:55]-[2020-01-07 Tue 12:49]|3:54
[2020-01-06 Mon 22:30]-[2020-01-06 Mon 23:31]|1:01
[2020-01-06 Mon 09:20]-[2020-01-06 Mon 11:56]|2:36
[2020-01-04 Sat 20:25]-[2020-01-04 Sat 21:09]|0:44
[2020-01-04 Sat 09:37]-[2020-01-04 Sat 13:22]|3:45
[2020-01-03 Fri 21:13]-[2020-01-03 Fri 23:59]|2:46
[2020-01-03 Fri 18:13]-[2020-01-03 Fri 19:13]|1:00
[2020-01-03 Fri 12:08]-[2020-01-03 Fri 14:12]|2:04
[2020-01-02 Thu 09:35]-[2020-01-02 Thu 11:58]|2:23
[2019-12-29 Sun 02:12]-[2019-12-29 Sun 05:42]|3:30
[2019-12-26 Thu 16:59]-[2019-12-26 Thu 19:51]|2:52
[2019-12-23 Mon 05:03]-[2019-12-23 Mon 05:31]|0:28
[2019-12-23 Mon 03:02]-[2019-12-23 Mon 04:03]|1:01
[2019-12-22 Sun 16:51]-[2019-12-22 Sun 18:40]|1:49
[2019-12-21 Sat 19:23]-[2019-12-22 Sun 00:19]|4:56
[2019-12-20 Fri 14:10]-[2019-12-20 Fri 17:11]|3:01
[2019-12-19 Thu 23:20]-[2019-12-19 Thu 23:38]|0:18
[2019-12-18 Wed 10:47]-[2019-12-18 Wed 12:47]|2:00
[2019-12-09 Mon 10:47]-[2019-12-09 Mon 13:21]|2:34
[2019-12-08 Sun 17:47]-[2019-12-09 Sun 00:28]|6:41
[2019-12-07 Sat 16:07]-[2019-12-07 Sat 23:15]|7:08
[2019-12-06 Fri 19:04]-[2019-12-06 Fri 20:54]|1:50
[2019-12-04 Wed 18:06]-[2019-12-05 Thu 00:42]|6:36
[2019-12-04 Wed 12:36]-[2019-12-04 Wed 13:05]|0:29
[2019-12-03 Tue 22:18]-[2019-12-03 Tue 23:27]|1:09
[2019-12-03 Tue 21:21]-[2019-12-03 Tue 22:18]|0:57
[2019-12-03 Tue 12:40]-[2019-12-03 Tue 15:25]|2:45
[2019-12-02 Mon 20:06]-[2019-12-02 Mon 23:30]|3:24
[2019-12-01 Sun 22:07]-[2019-12-02 Mon 01:06]|2:59
[2019-12-01 Sun 18:59]-[2019-12-01 Sun 19:59]|1:00
[2019-11-30 Sat 14:19]-[2019-11-30 Sat 15:15]|0:56
[2019-11-29 Fri 20:07]-[2019-11-29 Fri 21:24]|1:17
[2019-11-29 Fri 11:51]-[2019-11-29 Fri 12:10]|0:19
[2019-11-28 Thu 09:30]-[2019-11-28 Thu 15:00]|5:30
[2019-11-26 Tue 09:15]-[2019-11-26 Tue 12:57]|3:42
[2019-11-25 Mon 10:35]-[2019-11-25 Mon 13:02]|2:27
[2019-11-20 Wed 12:08]-[2019-11-20 Wed 14:29]|2:21
[2019-11-20 Wed 09:25]-[2019-11-20 Wed 11:32]|2:07
[2019-11-19 Tue 11:45]-[2019-11-19 Tue 14:42]|2:57
[2019-11-13 Wed 20:52]-[2019-11-13 Wed 22:25]|1:33
[2019-11-12 Tue 19:47]-[2019-11-12 Tue 21:14]|1:27
[2019-11-12 Tue 09:30]-[2019-11-12 Tue 11:49]|2:19
[2019-11-11 Mon 21:03]-[2019-11-11 Mon 23:03]|2:00
[2019-11-10 Sun 21:45]-[2019-11-10 Sun 23:25]|1:40
[2019-10-31 Thu 09:20]-[2019-10-31 Thu 11:07]|1:47
[2019-10-30 Wed 10:35]-[2019-10-30 Wed 13:55]|3:20
[2019-10-29 Tue 22:35]-[2019-10-30 Wed 00:13]|1:38
[2019-10-29 Tue 09:33]-[2019-10-29 Tue 11:33]|2:00
[2019-10-28 Mon 21:52]-[2019-10-29 Tue 00:14]|2:22
[2019-10-28 Mon 18:23]-[2019-10-28 Mon 19:23]|1:00
[2019-10-28 Mon 09:07]-[2019-10-28 Mon 15:10]|6:03
[2019-10-27 Sun 20:44]-[2019-10-28 Mon 00:48]|4:04
[2019-10-27 Sun 14:17]-[2019-10-27 Sun 15:42]|1:25
[2019-10-27 Sun 12:15]-[2019-10-27 Sun 13:33]|1:18
[2019-10-26 Sat 13:53]-[2019-10-26 Sat 14:10]|0:17
[2019-10-26 Sat 10:15]-[2019-10-26 Sat 10:58]|0:43
[2019-10-25 Fri 15:12]-[2019-10-25 Fri 17:55]|2:43
[2019-10-25 Fri 09:10]-[2019-10-25 Fri 09:59]|0:49
[2019-10-24 Thu 22:23]-[2019-10-25 Fri 00:05]|1:42
[2019-10-24 Thu 18:45]-[2019-10-24 Thu 21:21]|2:36
[2019-10-24 Thu 09:03]-[2019-10-24 Thu 10:47]|1:44
[2019-10-23 Wed 21:24]-[2019-10-24 Wed 23:49]|2:25
[2019-10-23 Wed 09:09]-[2019-10-23 Wed 10:55]|1:46
[2019-10-22 Tue 22:35]-[2019-10-23 Wed 00:13]|1:33
[2019-10-22 Tue 19:10]-[2019-10-22 Tue 21:38]|2:28
[2019-10-22 Tue 09:18]-[2019-10-22 Tue 12:02]|2:44
[2019-10-21 Mon 23:39]-[2019-10-21 Mon 23:49]|0:10
[2019-10-21 Mon 17:23]-[2019-10-21 Mon 18:28]|1:05
[2019-10-21 Mon 09:05]-[2019-10-21 Mon 13:58]|4:53
[2019-10-20 Sun 23:27]-[2019-10-21 Mon 00:00]|0:33
[2019-10-20 Sun 19:32]-[2019-10-20 Sun 20:23]|0:51
[2019-10-20 Sun 12:55]-[2019-10-20 Sun 14:45]|1:50
[2019-10-19 Sat 19:25]-[2019-10-19 Sat 20:45]|1:20
[2019-10-19 Sat 16:12]-[2019-10-19 Sat 18:47]|2:35
[2019-10-17 Thu 19:18]-[2019-10-17 Thu 22:55]|3:37
[2019-10-17 Thu 09:30]-[2019-10-17 Thu 11:42]|2:12
[2019-10-16 Wed 14:52]-[2019-10-16 Wed 14:59]|0:07
[2019-10-16 Wed 09:08]-[2019-10-16 Wed 10:08]|1:00
[2019-10-15 Tue 22:35]-[2019-10-15 Tue 23:30]|0:55
[2019-10-15 Tue 19:30]-[2019-10-15 Tue 21:40]|2:10
[2019-10-15 Tue 09:10]-[2019-10-15 Tue 12:56]|3:46
[2019-10-14 Mon 19:51]-[2019-10-14 Mon 23:10]|3:19
[2019-10-14 Mon 15:57]-[2019-10-14 Mon 17:23]|1:26
[2019-10-12 Sat 20:05]-[2019-10-12 Sat 21:33]|1:28
[2019-10-12 Sat 15:56]-[2019-10-12 Sat 16:07]|0:11
[2019-10-12 Sat 10:31]-[2019-10-12 Sat 12:31]|2:00
[2019-10-11 Fri 19:55]-[2019-10-11 Fri 22:34]|2:39
[2019-10-11 Fri 17:55]-[2019-10-11 Fri 19:28]|1:33
[2019-10-11 Fri 14:35]-[2019-10-11 Fri 14:47]|0:12
[2019-10-11 Fri 09:10]-[2019-10-11 Fri 11:10]|2:00
[2019-10-10 Thu 20:26]-[2019-10-10 Thu 21:48]|1:22
[2019-10-10 Thu 17:26]-[2019-10-10 Thu 19:40]|2:14
[2019-10-10 Thu 12:15]-[2019-10-10 Thu 14:37]|2:22
[2019-10-10 Thu 08:50]-[2019-10-10 Thu 11:29]|2:39
[2019-10-09 Wed 20:16]-[2019-10-09 Wed 20:55]|0:39
[2019-10-09 Wed 16:46]-[2019-10-09 Wed 17:55]|1:09
[2019-10-09 Wed 11:27]-[2019-10-09 Wed 13:38]|2:11
[2019-09-29 Sun 17:01]-[2019-09-29 Sun 17:23]|0:22
[2019-09-27 Fri 08:56]-[2019-09-27 Fri 10:20]|1:24
[2019-09-26 Thu 21:25]-[2019-09-26 Thu 23:38]|2:13
[2019-09-25 Wed 21:55]-[2019-09-25 Wed 22:18]|0:23
[2019-09-25 Wed 12:20]-[2019-09-25 Wed 15:22]|3:02
[2019-09-25 Wed 09:20]-[2019-09-25 Wed 11:25]|2:05
[2019-09-24 Tue 22:10]-[2019-09-24 Tue 23:16]|1:06
[2019-09-24 Tue 12:05]-[2019-09-24 Tue 13:49]|1:44
[2019-09-24 Tue 01:17]-[2019-09-24 Tue 02:15]|0:58
[2019-09-23 Mon 21:26]-[2019-09-23 Mon 22:57]|1:31
[2019-09-22 Sun 14:52]-[2019-09-22 Sun 18:51]|3:59
[2019-09-21 Sat 16:50]-[2019-09-21 Sat 17:55]|1:05
[2019-09-21 Sat 12:31]-[2019-09-21 Sat 15:44]|3:13
[2019-09-20 Fri 22:05]-[2019-09-21 Sat 00:05]|2:00
[2019-09-20 Fri 14:38]-[2019-09-20 Fri 17:20]|2:42
[2019-09-20 Fri 11:42]-[2019-09-20 Fri 12:48]|1:06
[2019-09-19 Thu 21:14]-[2019-09-20 Fri 00:33]|3:19
[2019-09-19 Thu 09:15]-[2019-09-19 Thu 11:14]|1:59
[2019-09-18 Wed 20:55]-[2019-09-18 Wed 23:25]|2:30
[2019-09-17 Tue 22:05]-[2019-09-17 Tue 22:56]|0:51
[2019-09-14 Sat 14:20]-[2019-09-14 Sat 16:57]|2:37
[2019-09-12 Thu 09:31]-[2019-09-12 Thu 10:36]|1:05
[2019-09-11 Wed 22:40]-[2019-09-12 Thu 01:41]|3:01
[2019-09-11 Wed 12:11]-[2019-09-11 Wed 15:16]|3:05
[2019-09-11 Wed 09:19]-[2019-09-11 Wed 11:49]|2:30
[2019-09-10 Tue 20:60]-[2019-09-10 Tue 23:35]|2:35
[2019-09-10 Tue 16:30]-[2019-09-10 Tue 19:35]|3:05
[2019-09-10 Tue 14:30]-[2019-09-10 Tue 14:41]|0:11
[2019-09-10 Tue 10:27]-[2019-09-10 Tue 11:27]|1:00
[2019-09-09 Mon 09:29]-[2019-09-09 Mon 12:45]|3:16
[2019-09-08 Sun 23:07]-[2019-09-09 Mon 00:46]|1:39
[2019-09-08 Sun 15:10]-[2019-09-08 Sun 21:07]|5:57
[2019-09-06 Fri 12:05]-[2019-09-06 Fri 13:40]|1:35
[2019-09-04 Wed 20:01]-[2019-09-04 Wed 23:19]|3:18
[2019-09-04 Wed 17:01]-[2019-09-04 Wed 20:00]|2:59
[2019-09-04 Wed 09:12]-[2019-09-04 Wed 12:12]|3:00
[2019-09-03 Tue 19:40]-[2019-09-04 Wed 01:20]|5:40
[2019-09-03 Tue 11:12]-[2019-09-03 Tue 14:46]|3:34
[2019-09-03 Tue 10:00]-[2019-09-03 Tue 10:39]|0:39
[2019-09-02 Mon 19:55]-[2019-09-03 Tue 00:00]|4:05
[2019-09-02 Mon 09:53]-[2019-09-02 Mon 13:37]|3:44
[2019-09-01 Sun 19:10]-[2019-09-02 Mon 00:46]|5:36
[2019-08-31 Sat 11:21]-[2019-08-31 Sat 11:44]|0:23
[2019-08-30 Fri 19:21]-[2019-08-30 Fri 23:49]|4:28
[2019-08-30 Fri 15:21]-[2019-08-30 Fri 16:11]|0:50
[2019-08-29 Thu 14:10]-[2019-08-29 Thu 15:16]|1:06
[2019-08-25 Sun 14:15]-[2019-08-25 Sun 21:55]|7:40
[2019-08-22 Thu 15:01]-[2019-08-22 Thu 19:39]|4:38
[2019-08-22 Thu 09:12]-[2019-08-22 Thu 13:30]|4:18
[2019-08-21 Wed 21:15]-[2019-08-22 Thu 00:17]|3:02
[2019-08-21 Wed 12:21]-[2019-08-21 Wed 14:39]|2:18
[2019-08-20 Tue 10:57]-[2019-08-20 Tue 15:04]|4:07
[2019-08-19 Mon 09:19]-[2019-08-19 Mon 13:32]|4:13
#+END_SRC


* Приложение: данные по временным меткам завершений решения задач



This section lists the data on the minute each exercise was considered _complete_.
(Local time.) For statistical purposes the beginning of each exercise is 
considered to be the 
completion time of the previous one. For the first exercise, the beginning 
time is [2019-08-19 Mon 09:19]. 

#+name: completion-times-data
#+BEGIN_SRC elisp
Figure 1.1 Tree with the values of subcombinations
[2019-08-20 Tue 14:35]
Exercise 1.1 Interpreter result
[2019-08-20 Tue 14:23]
Exercise 1.2 Prefix form
[2019-08-20 Tue 14:25]
Exercise 1.3 Sum of squares
[2020-02-28 Fri 12:01]
Exercise 1.4 Compound expressions
[2019-08-20 Tue 14:39]
Exercise 1.5 Ben's test
[2019-08-20 Tue 14:50]
Exercise 1.6 If is a special form
[2019-08-21 Wed 14:05]
Exercise 1.7 Good enough?
[2019-08-22 Thu 12:52]
Exercise 1.8 Newton's method
[2019-08-22 Thu 17:36]
Exercise 1.9 Iterative or recursive?
[2019-08-29 Thu 15:14]
Exercise 1.10 Ackermann's function
[2019-08-25 Sun 18:31]
Exercise 1.11 Recursive vs iterative
[2019-08-25 Sun 19:25]
Exercise 1.12 Recursive Pascal's triangle
[2019-08-25 Sun 19:42]
Exercise 1.13 Fibonacci
[2019-08-25 Sun 23:04]
Exercise 1.14 ~count-change~
[2019-08-30 Fri 16:09]
Exercise 1.15 ~sine~
[2019-08-30 Fri 22:34]
Exercise 1.16 Iterative exponentiation
[2019-08-30 Fri 23:20]
Exercise 1.17 Fast multiplication
[2019-08-30 Fri 23:48]
Exercise 1.18 Iterative multiplication
[2019-08-31 Sat 11:43]
Exercise 1.19 Logarithmic Fibonacci
[2019-09-01 Sun 20:42]
Exercise 1.20 GCD applicative vs normal
[2019-09-01 Sun 23:04]
Exercise 1.21 ~smallest-divisor~
[2019-09-01 Sun 23:43]
Exercise 1.22 ~timed-prime-test~
[2019-09-02 Mon 00:44]
Exercise 1.23 ~test-divisor~
[2019-09-02 Mon 09:56]
Exercise 1.24 Fermat method
[2019-09-02 Mon 11:32]
Exercise 1.25 ~expmod~
[2019-09-02 Mon 12:46]
Exercise 1.26 ~square~ vs ~mul~
[2019-09-02 Mon 12:50]
Exercise 1.27 Carmichael numbers
[2019-09-02 Mon 20:50]
Exercise 1.28 Miller-Rabin
[2019-09-02 Mon 23:28]
Exercise 1.29 Simpson's integral
[2019-09-03 Tue 10:36]
Exercise 1.30 Iterative sum
[2019-09-03 Tue 11:19]
Exercise 1.31 Product
[2019-09-03 Tue 11:59]
Exercise 1.32 Accumulator
[2019-09-03 Tue 12:23]
Exercise 1.33 ~filtered-accumulate~
[2019-09-03 Tue 14:36]
Exercise 1.34 lambda
[2019-09-03 Tue 14:44]
Exercise 1.35 Fixed-point
[2019-09-03 Tue 21:05]
Exercise 1.36 Fixed-point-with-dampening
[2019-09-03 Tue 21:55]
Exercise 1.37 Cont-frac
[2019-09-04 Wed 11:35]
Exercise 1.38 Euler constant
[2019-09-04 Wed 11:35]
Exercise 1.39 Tan-cf
[2019-09-04 Wed 12:11]
Exercise 1.40 Newtons-method
[2019-09-04 Wed 17:06]
Exercise 1.41 Double-double
[2019-09-04 Wed 17:21]
Exercise 1.42 Compose
[2019-09-04 Wed 17:27]
Exercise 1.43 Repeated
[2019-09-04 Wed 17:54]
Exercise 1.44 Smoothing
[2019-09-04 Wed 20:17]
Exercise 1.45 Nth root
[2019-09-04 Wed 21:37]
Exercise 1.46 ~iterative-improve~
[2019-09-04 Wed 22:25]
Exercise 2.1 ~make-rat~
[2019-09-06 Fri 13:00]
Exercise 2.2 ~make-segment~
[2019-09-06 Fri 13:34]
Exercise 2.3 ~make-rectangle~
[2019-09-08 Sun 17:58]
Exercise 2.4 ~cons~ lambda
[2019-09-08 Sun 18:08]
Exercise 2.5 ~cons~ pow
[2019-09-08 Sun 19:07]
Exercise 2.6 Church Numerals
[2019-09-08 Sun 19:41]
Exercise 2.7 ~make-interval~
[2019-09-08 Sun 20:09]
Exercise 2.8 ~sub-interval~
[2019-09-08 Sun 23:07]
Exercise 2.9 ~interval-width~
[2019-09-08 Sun 23:15]
Exercise 2.10 Div interval better
[2019-09-08 Sun 23:30]
Exercise 2.11 Mul interval nine cases
[2019-09-09 Mon 00:45]
Exercise 2.12 ~make-center-percent~
[2019-09-09 Mon 10:11]
Exercise 2.13 Formula for tolerance
[2019-09-09 Mon 10:16]
Exercise 2.14 Parallel resistors
[2019-09-09 Mon 11:24]
Exercise 2.15 Better intervals
[2019-09-09 Mon 11:34]
Exercise 2.16 Interval arithmetic
[2019-09-09 Mon 11:37]
Exercise 2.17 ~last-pair~
[2019-09-10 Tue 10:48]
Exercise 2.18 ~reverse~
[2019-09-10 Tue 10:57]
Exercise 2.19 Coin values
[2019-09-10 Tue 11:27]
Exercise 2.20 Dotted-tail notation
[2019-09-10 Tue 18:55]
Exercise 2.21 Map square list
[2019-09-10 Tue 19:14]
Exercise 2.22 Wrong list order
[2019-09-10 Tue 19:24]
Exercise 2.23 ~for-each~
[2019-09-10 Tue 19:33]
Exercise 2.24 List plot result
[2019-09-10 Tue 22:13]
Exercise 2.25 ~caddr~
[2019-09-10 Tue 23:07]
Exercise 2.26 ~append~ ~cons~ ~list~
[2019-09-10 Tue 23:23]
Exercise 2.27 Deep reverse
[2019-09-11 Wed 09:47]
Exercise 2.28 Fringe
[2019-09-11 Wed 10:24]
Exercise 2.29 Mobile
[2019-09-11 Wed 11:47]
Exercise 2.30 ~square-tree~
[2019-09-11 Wed 14:11]
Exercise 2.31 Tree-map square tree
[2019-09-11 Wed 14:38]
Exercise 2.32 Subsets
[2019-09-11 Wed 14:53]
Exercise 2.33 Map append length
[2019-09-11 Wed 23:53]
Exercise 2.34 Horners rule
[2019-09-12 Thu 00:01]
Exercise 2.35 ~count-leaves-accumulate~
[2019-09-12 Thu 00:17]
Exercise 2.36 ~accumulate-n~
[2019-09-12 Thu 00:26]
Exercise 2.37 ~matrix-*-vector~
[2019-09-12 Thu 00:50]
Exercise 2.38 ~fold-left~
[2019-09-12 Thu 09:45]
Exercise 2.39 Reverse ~fold-right~ ~fold-left~
[2019-09-12 Thu 09:52]
Exercise 2.40 ~unique-pairs~
[2019-09-12 Thu 10:34]
Exercise 2.41 ~triple-sum~
[2019-09-14 Sat 15:15]
Figure 2.8 A solution to the eight-queens puzzle
[2019-09-14 Sat 15:17]
Exercise 2.42 k-queens
[2019-09-17 Tue 22:27]
Exercise 2.43 Slow k-queens
[2019-09-17 Tue 22:55]
Exercise 2.44 ~up-split~
[2019-09-23 Mon 22:54]
Exercise 2.45 ~split~
[2019-09-24 Tue 01:37]
Exercise 2.46 ~make-vect~
[2019-09-20 Fri 12:48]
Exercise 2.47 ~make-frame~
[2019-09-20 Fri 14:48]
Exercise 2.48 ~make-segment~
[2019-09-20 Fri 16:06]
Exercise 2.49 ~segments->painter~ applications
[2019-09-20 Fri 23:10]
Exercise 2.50 ~flip-horiz~ ~rotate270~ ~rotate180~
[2019-09-20 Fri 23:37]
Exercise 2.51 ~below~
[2019-09-22 Sun 18:50]
Exercise 2.52 Modify square-limit
[2019-09-24 Tue 12:25]
Exercise 2.53 Quote introduction
[2019-09-24 Tue 12:36]
Exercise 2.54 ~equal?~ implementation
[2019-09-24 Tue 13:48]
Exercise 2.55 Quote quote
[2019-09-24 Tue 13:48]
Exercise 2.56 Differentiation exponentiation
[2019-09-24 Tue 23:14]
Exercise 2.57 Differentiate three sum
[2019-09-25 Wed 12:40]
Exercise 2.58 ~infix-notation~
[2019-09-25 Wed 15:21]
Exercise 2.59 ~union-set~
[2019-09-25 Wed 22:00]
Exercise 2.60 ~duplicate-set~
[2019-09-25 Wed 22:17]
Exercise 2.61 Sets as ordered lists
[2019-09-26 Thu 21:44]
Exercise 2.62 ~ordered-union-set~ (ordered list)
[2019-09-26 Thu 21:38]
Exercise 2.63 ~tree->list~ (binary search tree)
[2019-09-26 Thu 23:37]
Exercise 2.64 Balanced tree
[2019-09-29 Sun 17:22]
Exercise 2.65 ~tree-union-set~
[2019-10-09 Wed 12:13]
Exercise 2.66 Tree-lookup
[2019-10-09 Wed 13:03]
Exercise 2.67 Huffman decode a simple message
[2019-10-09 Wed 20:20]
Exercise 2.68 Huffman encode a simple message
[2019-10-09 Wed 20:53]
Exercise 2.69 Generate Huffman tree
[2019-10-10 Thu 11:28]
Exercise 2.70 Generate a tree and encode a song
[2019-10-10 Thu 13:11]
Exercise 2.71 Huffman tree for 5 and 10
[2019-10-10 Thu 19:22]
Exercise 2.72 Huffman order of growth
[2019-10-10 Thu 20:34]
Exercise 2.73 Data-driven ~deriv~
[2019-10-11 Fri 11:05]
Exercise 2.74 Insatiable Enterprises
[2019-10-11 Fri 20:56]
Exercise 2.75 ~make-from-mag-ang~ message passing
[2019-10-11 Fri 21:24]
Exercise 2.76 Types or functions?
[2019-10-11 Fri 21:29]
Exercise 2.77 Generic algebra magnitude
[2019-10-12 Sat 16:01]
Exercise 2.78 Ordinary numbers for Scheme
[2019-10-12 Sat 21:06]
Exercise 2.79 Generic equality
[2019-10-14 Mon 15:58]
Exercise 2.80 Generic arithmetic zero?
[2019-10-14 Mon 17:18]
Exercise 2.81 Coercion to itself
[2019-10-15 Tue 11:16]
Exercise 2.82 Three argument coercion
[2019-10-15 Tue 21:40]
Exercise 2.83 Numeric Tower and (raise)
[2019-10-16 Wed 14:53]
Exercise 2.84 ~raise-type~ in ~apply-generic~
[2019-10-17 Thu 11:39]
Exercise 2.85 Dropping a type
[2019-10-20 Sun 13:47]
Exercise 2.86 Compound complex numbers
[2019-10-20 Sun 20:22]
Exercise 2.87 Generalized zero?
[2019-10-21 Mon 18:25]
Exercise 2.88 Subtraction of polynomials
[2019-10-22 Tue 09:55]
Exercise 2.89 Dense term-lists
[2019-10-22 Tue 11:55]
Exercise 2.90 Dense polynomials as a package
[2019-10-22 Tue 21:31]
Exercise 2.91 Division of polynomials
[2019-10-23 Wed 00:11]
Exercise 2.92 Add, mul for different variables
[2019-10-27 Sun 13:32]
Exercise 2.93 Rational polynomials
[2019-10-27 Sun 22:36]
Exercise 2.94 GCD for polynomials
[2019-10-28 Mon 00:47]
Exercise 2.95 Non-integer problem
[2019-10-28 Mon 11:35]
Exercise 2.96 Integerizing factor
[2019-10-28 Mon 19:23]
Exercise 2.97 Reduction of polynomials
[2019-10-29 Tue 00:12]
Exercise 3.1 Accumulators
[2019-10-29 Tue 10:24]
Exercise 3.2 Make-monitored
[2019-10-29 Tue 11:03]
Exercise 3.3 Password protection
[2019-10-29 Tue 11:17]
Exercise 3.4 Call-the-cops
[2019-10-29 Tue 11:32]
Exercise 3.5 Monte-Carlo
[2019-10-30 Wed 00:12]
Exercise 3.6 reset a prng
[2019-10-30 Wed 11:42]
Exercise 3.7 Joint accounts
[2019-10-30 Wed 13:07]
Exercise 3.8 Right-to-left vs Left-to-right
[2019-10-30 Wed 13:45]
Exercise 3.9 Environment structures
[2019-11-20 Wed 14:28]
Exercise 3.10 ~let~ to create state variables
[2019-11-25 Mon 12:52]
Exercise 3.11 Internal definitions
[2019-11-26 Tue 12:44]
Exercise 3.12 Drawing ~append!~
[2019-11-29 Fri 11:55]
Exercise 3.13 ~make-cycle~
[2019-11-29 Fri 12:09]
Exercise 3.14 ~mystery~
[2019-11-29 Fri 21:23]
Exercise 3.15 ~set-to-wow!~
[2019-12-01 Sun 19:59]
Exercise 3.16 ~count-pairs~
[2019-12-02 Mon 00:05]
Exercise 3.17 Real ~count-pairs~
[2019-12-02 Mon 00:47]
Exercise 3.18 Finding cycles
[2019-12-02 Mon 01:04]
Exercise 3.19 Efficient finding cycles
[2019-12-02 Mon 23:29]
Exercise 3.20 Procedural ~set-car!~
[2019-12-03 Tue 14:40]
Exercise 3.21 Queues
[2019-12-03 Tue 15:10]
Exercise 3.22 Procedural queue
[2019-12-03 Tue 22:13]
Exercise 3.23 Dequeue
[2019-12-03 Tue 23:24]
Exercise 3.24 Tolerant tables
[2019-12-04 Wed 18:07]
Exercise 3.25 Multilevel tables
[2019-12-06 Fri 20:35]
Exercise 3.26 Binary tree table
[2019-12-06 Fri 20:53]
Exercise 3.27 Memoization
[2019-12-07 Sat 16:08]
Exercise 3.28 Primitive or-gate
[2019-12-08 Sun 23:43]
Exercise 3.29 Compound or-gate
[2019-12-08 Sun 23:45]
Exercise 3.30 Ripple-carry adder
[2019-12-08 Sun 23:58]
Exercise 3.31 Initial propagation
[2019-12-09 Mon 00:16]
Exercise 3.32 Order matters
[2019-12-09 Mon 00:26]
Exercise 3.33 Averager constraint
[2019-12-18 Wed 11:29]
Exercise 3.34 Wrong squarer
[2019-12-18 Wed 12:30]
Exercise 3.35 Correct squarer
[2019-12-18 Wed 12:47]
Exercise 3.36 Connector environment diagram
[2019-12-21 Sat 20:27]
Exercise 3.37 Expression-based constraints
[2019-12-21 Sat 21:20]
Exercise 3.38 Timing
[2019-12-21 Sat 22:48]
Exercise 3.39 Serializer
[2019-12-23 Mon 05:11]
Exercise 3.40 Three parallel multiplications
[2019-12-29 Sun 04:32]
Exercise 3.41 Better protected account
[2020-01-02 Thu 10:02]
Exercise 3.42 Saving on serializers
[2020-01-02 Thu 10:35]
Exercise 3.43 Multiple serializations
[2020-01-02 Thu 11:33]
Exercise 3.44 Transfer money
[2020-01-02 Thu 11:40]
Exercise 3.45 New plus old serializers
[2020-01-02 Thu 11:46]
Exercise 3.46 Broken test-and-set!
[2020-01-02 Thu 11:56]
Exercise 3.47 Semaphores
[2020-01-03 Fri 12:59]
Exercise 3.48 Serialized-exchange deadlock
[2020-01-03 Fri 13:30]
Exercise 3.49 When numbering does not work
[2020-01-03 Fri 13:41]
Exercise 3.50 ~stream-map~ multiple arguments
[2020-01-03 Fri 21:18]
Exercise 3.51 ~stream-show~
[2020-01-03 Fri 21:28]
Exercise 3.52 Streams with mind-boggling
[2020-01-03 Fri 22:17]
Exercise 3.53 Stream power of two
[2020-01-03 Fri 22:40]
Exercise 3.54 ~mul-streams~
[2020-01-03 Fri 22:47]
Exercise 3.55 Streams partial-sums
[2020-01-03 Fri 23:05]
Exercise 3.56 Hamming's streams-merge
[2020-01-03 Fri 23:26]
Exercise 3.57 Exponential additions fibs
[2020-01-03 Fri 23:36]
Exercise 3.58 Cryptic stream
[2020-01-03 Fri 23:50]
Exercise 3.59 Power series
[2020-01-04 Sat 09:58]
Exercise 3.60 ~mul-series~
[2020-01-04 Sat 11:07]
Exercise 3.61 ~power-series-inversion~
[2020-01-04 Sat 13:13]
Exercise 3.62 ~div-series~
[2020-01-04 Sat 13:21]
Exercise 3.63 ~sqrt-stream~
[2020-01-04 Sat 20:32]
Exercise 3.64 ~stream-limit~
[2020-01-06 Mon 09:38]
Exercise 3.65 Approximating logarithm
[2020-01-06 Mon 10:34]
Exercise 3.66 Lazy pairs
[2020-01-06 Mon 22:55]
Exercise 3.67 All possible pairs
[2020-01-06 Mon 23:09]
Exercise 3.68 ~pairs-louis~
[2020-01-06 Mon 23:26]
Exercise 3.69 ~triples~
[2020-02-17 Mon 20:10]
Exercise 3.70 ~merge-weighted~
[2020-01-07 Tue 11:58]
Exercise 3.71 Ramanujan numbers
[2020-01-07 Tue 12:49]
Exercise 3.72 Ramanujan 3-numbers
[2020-01-08 Wed 10:27]
Figure 3.32 Integral-signals
[2020-01-08 Wed 10:59]
Exercise 3.73 RC-circuit
[2020-01-08 Wed 13:09]
Exercise 3.74 Zero-crossings
[2020-01-08 Wed 16:50]
Exercise 3.75 Filtering signals
[2020-01-08 Wed 18:11]
Exercise 3.76 ~stream-smooth~
[2020-01-08 Wed 19:56]
Exercise 3.77 Streams integral
[2020-01-08 Wed 20:51]
Exercise 3.78 Second order differential equation
[2020-01-08 Wed 21:47]
Exercise 3.79 General second-order ode
[2020-01-08 Wed 21:57]
Figure 3.36
[2020-01-08 Wed 23:21]
Exercise 3.80 RLC circuit
[2020-01-08 Wed 23:40]
Exercise 3.81 Generator-in-streams
[2020-01-09 Thu 00:37]
Exercise 3.82 Streams Monte-Carlo
[2020-01-09 Thu 09:42]
Exercise 4.1 ~list-of-values~ ordered
[2020-01-09 Thu 20:11]
Exercise 4.2 Application before assignments
[2020-01-09 Thu 20:41]
Exercise 4.3 Data-directed eval
[2020-01-09 Thu 21:24]
Exercise 4.4 ~eval-and~ and ~eval-or~
[2020-01-09 Thu 22:14]
Exercise 4.5 ~cond~ with arrow
[2020-01-22 Wed 16:36]
Exercise 4.6 Implementing let
[2020-01-22 Wed 17:03]
Exercise 4.7 Implementing let*
[2020-01-22 Wed 18:09]
Exercise 4.8 Implementing named let
[2020-01-22 Wed 19:50]
Exercise 4.9 Implementing until
[2020-01-23 Thu 18:06]
Exercise 4.10 Modifying syntax
[2020-02-06 Thu 22:08]
Exercise 4.11 Environment as a list of bindings
[2020-02-11 Tue 06:58]
Exercise 4.12 Better abstractions setting value
[2020-02-11 Tue 19:40]
Exercise 4.13 Implementing ~make-unbound!~
[2020-02-12 Wed 08:52]
Exercise 4.14 Meta map versus built-in map
[2020-02-12 Wed 08:58]
Exercise 4.15 The ~halts?~ predicate
[2020-02-12 Wed 09:24]
Exercise 4.16 Simultaneous internal definitions
[2020-02-12 Wed 13:17]
Exercise 4.17 Environment for internal definitions
[2020-02-12 Wed 14:09]
Exercise 4.18 Alternative scanning
[2020-02-12 Wed 14:35]
Exercise 4.19 Mutual simultaneous definitions
[2020-02-12 Wed 19:52]
Exercise 4.20 ~letrec~
[2020-02-13 Thu 00:49]
Exercise 4.21 Y-combinator
[2020-02-13 Thu 01:07]
Exercise 4.22 Extending evaluator to support ~let~
[2020-02-14 Fri 19:33]
Exercise 4.23 Analysing sequences
[2020-02-14 Fri 19:40]
Exercise 4.24 Analysis time test
[2020-02-14 Fri 20:12]
Exercise 4.25 Lazy factorial
[2020-02-14 Fri 21:01]
Exercise 4.26 ~unless~ as a special form
[2020-02-15 Sat 04:32]
Exercise 4.27 Mutation in lazy interpreters
[2020-02-15 Sat 16:54]
Exercise 4.28 Eval before applying
[2020-02-15 Sat 17:01]
Exercise 4.29 Lazy eval slow without memoization
[2020-02-15 Sat 17:51]
Exercise 4.30 Lazy sequences
[2020-02-15 Sat 21:32]
Exercise 4.31 Lazy arguments with syntax extension
[2020-02-15 Sat 23:44]
Exercise 4.32 Streams versus lazy lists
[2020-02-16 Sun 11:49]
Exercise 4.33 Quoted lazy lists
[2020-02-16 Sun 14:09]
Exercise 4.34 Printing lazy lists
[2020-02-16 Sun 19:25]
Exercise 4.35 Pythagorean triples 
[2020-02-17 Mon 17:25]
Exercise 4.36 Infinite Pythagorean triples
[2020-02-17 Mon 20:26]
Exercise 4.37 Another method for triples
[2020-02-17 Mon 21:17]
Exercise 4.38 Logical puzzle - Not same floor
[2020-02-17 Mon 21:56]
Exercise 4.39 Order of restrictions
[2020-02-17 Mon 22:01]
Exercise 4.40 People to floor assignment
[2020-02-17 Mon 22:29]
Exercise 4.41 Ordinary Scheme floor problem
[2020-02-18 Tue 00:12]
Exercise 4.42 The liars puzzle
[2020-02-18 Tue 12:16]
Exercise 4.43 Problematical Recreations
[2020-02-18 Tue 13:31]
Exercise 4.44 Nondeterministic eight queens
[2020-02-18 Tue 15:17]
Exercise 4.45 Five parses
[2020-02-18 Tue 19:45]
Exercise 4.46 Order of parsing
[2020-02-18 Tue 19:55]
Exercise 4.47 Parse verb phrase by Louis
[2020-02-18 Tue 20:13]
Exercise 4.48 Extending the grammar
[2020-02-18 Tue 21:06]
Exercise 4.49 Alyssa's generator
[2020-02-18 Tue 21:51]
Exercise 4.50 The ~ramb~ operator
[2020-02-17 Mon 14:56]
Exercise 4.51 Implementing ~permanent-set!~
[2020-02-18 Tue 22:34]
Exercise 4.52 ~if-fail~
[2020-02-19 Wed 00:05]
Exercise 4.53 Test evaluation
[2020-02-19 Wed 00:12]
Exercise 4.54 ~analyze-require~
[2020-02-19 Wed 11:26]
Exercise 4.55 Simple queries
[2020-02-19 Wed 17:38]
Exercise 4.56 Compound queries
[2020-02-19 Wed 18:04]
Exercise 4.57 Custom rules
[2020-02-19 Wed 21:36]
Exercise 4.58 Big shot
[2020-02-19 Wed 22:12]
Exercise 4.59 Meetings
[2020-02-19 Wed 22:57]
Exercise 4.60 Pairs live near
[2020-02-19 Wed 23:20]
Exercise 4.61 Next-to relation
[2020-02-19 Wed 23:31]
Exercise 4.62 Last-pair
[2020-02-20 Thu 00:19]
Exercise 4.63 Genesis
[2020-02-20 Thu 10:28]
Figure 4.6 How the system works
[2020-02-20 Thu 10:59]
Exercise 4.64 Broken outranked-by
[2020-02-20 Thu 12:33]
Exercise 4.65 Second-degree subordinates
[2020-02-20 Thu 12:50]
Exercise 4.66 Ben's accumulation
[2020-02-20 Thu 13:08]
Exercise 4.67 Loop detector
[2020-02-20 Thu 23:20]
Exercise 4.68 Reverse rule
[2020-02-21 Fri 15:48]
Exercise 4.69 Great grandchildren
[2020-02-21 Fri 17:43]
Exercise 4.70 Cons-stream delays second argument
[2020-02-20 Thu 17:08]
Exercise 4.71 Louis' simple queries
[2020-02-21 Fri 20:56]
Exercise 4.72 ~interleave-stream~
[2020-02-20 Thu 17:11]
Exercise 4.73 ~flatten-stream~ delays
[2020-02-20 Thu 17:19]
Exercise 4.74 Alyssa's streams
[2020-02-21 Fri 22:00]
Exercise 4.75 ~unique~ special form
[2020-02-21 Fri 23:19]
Exercise 4.76 Improving ~and~
[2020-02-22 Sat 18:27]
Exercise 4.77 Lazy queries
[2020-03-14 Sat 15:42]
Exercise 4.78 Non-deterministic queries
[2020-03-15 Sun 12:40]
Exercise 4.79 Prolog environments
[2020-05-10 Sun 17:59]
Figure 5.1 Data paths for a Register Machine
[2020-02-23 Sun 13:18]
Figure 5.2 Controller for a GCD Machine
[2020-02-22 Sat 22:27]
Exercise 5.1 Register machine plot
[2020-02-22 Sat 22:56]
Exercise 5.2 Register machine Exercise 5.1
[2020-02-23 Sun 13:26]
Exercise 5.3 Machine for ~sqrt~, Newton Method
[2020-02-23 Sun 20:47]
Exercise 5.4 Recursive register machines
[2020-02-24 Mon 20:49]
Exercise 5.5 Manual factorial and Fibonacci
[2020-02-24 Mon 23:27]
Exercise 5.6 Fibonacci machine extra instructions
[2020-02-24 Mon 23:43]
Exercise 5.7 Test the 5.4 machine on a simulator
[2020-02-25 Tue 10:42]
Exercise 5.8 Ambiguous labels
[2020-02-25 Tue 21:58]
Exercise 5.9 Prohibit (op)s on labels
[2020-02-25 Tue 22:23]
Exercise 5.10 Changing syntax
[2020-02-25 Tue 22:39]
Exercise 5.11 Save and restore
[2020-02-26 Wed 13:30]
Exercise 5.12 Data paths from controller
[2020-02-26 Wed 23:40]
Exercise 5.13 Registers from controller
[2020-02-27 Thu 10:57]
Exercise 5.14 Profiling
[2020-02-28 Fri 20:21]
Exercise 5.15 Instruction counting
[2020-02-28 Fri 21:36]
Exercise 5.16 Tracing execution
[2020-02-28 Fri 22:59]
Exercise 5.17 Printing labels
[2020-02-29 Sat 17:43]
Exercise 5.18 Register tracing
[2020-02-29 Sat 14:07]
Exercise 5.19 Breakpoints
[2020-02-29 Sat 17:42]
Exercise 5.20 Drawing a list ~(#1=(1 . 2) #1)~
[2020-02-29 Sat 22:15]
Exercise 5.21 Register machines list operations
[2020-03-01 Sun 13:03]
Exercise 5.22 ~append~ and ~append!~ as machines
[2020-03-01 Sun 14:11]
Exercise 5.23 EC-evaluator with ~let~ and ~cond~
[2020-03-02 Mon 10:52]
Exercise 5.24 Making ~cond~ a primitive
[2020-03-02 Mon 14:42]
Exercise 5.25 Normal-order (lazy) evaluation
[2020-03-03 Tue 14:57]
Exercise 5.26 Tail recursion with ~factorial~
[2020-03-03 Tue 19:38]
Exercise 5.27 Stack depth for recursive factorial
[2020-03-03 Tue 19:49]
Exercise 5.28 Interpreters without tail recursion
[2020-03-03 Tue 20:29]
Exercise 5.29 Stack in tree-recursive Fibonacci
[2020-03-03 Tue 20:50]
Exercise 5.30 Errors
[2020-03-04 Wed 11:35]
Exercise 5.31 a ~preserving~ mechanism
[2020-03-04 Wed 21:36]
Exercise 5.32 Symbol-lookup optimization
[2020-03-04 Wed 22:51]
Exercise 5.33 Compiling ~factorial-alt~
[2020-03-05 Thu 16:55]
Exercise 5.34 Compiling iterative factorial
[2020-03-05 Thu 20:58]
Exercise 5.35 Decompilation
[2020-03-05 Thu 21:30]
Exercise 5.36 Order of evaluation
[2020-03-06 Fri 17:47]
Exercise 5.37 ~preserving~
[2020-03-06 Fri 21:01]
Exercise 5.38 Open code primitives
[2020-03-07 Sat 18:57]
Exercise 5.39 ~lexical-address-lookup~
[2020-03-07 Sat 20:41]
Exercise 5.40 Compile-time environment
[2020-03-08 Sun 15:02]
Exercise 5.41 ~find-variable~
[2020-03-07 Sat 19:37]
Exercise 5.42 Compile variable and assignment
[2020-03-08 Sun 12:59]
Exercise 5.43 Scanning out defines
[2020-03-08 Sun 21:00]
Exercise 5.44 Open code compile-time environment
[2020-03-08 Sun 21:29]
Exercise 5.45 Stack usage for ~factorial~
[2020-03-09 Mon 10:09]
Exercise 5.46 Stack usage for ~fibonacci~
[2020-03-09 Mon 10:34]
Exercise 5.47 Calling interpreted procedures
[2020-03-09 Mon 11:45]
Exercise 5.48 ~compile-and-run~
[2020-03-10 Tue 12:14]
Exercise 5.49 ~read-compile-execute-print~ loop
[2020-03-10 Tue 12:36]
Exercise 5.50 Compiling the metacircular evaluator
[2020-03-14 Sat 15:52]
Exercise 5.51 EC-evaluator in low-level language
[2020-04-13 Mon 11:45]
Exercise 5.52 Making a compiler for Scheme
[2020-05-06 Wed 11:09]
#+END_SRC



* Приложение: Код на Emacs Lisp для анализа данных

This section included the Emacs Lisp code used to analyse the data above.
The code is directly executable in the org-mode version of the report.
Interested readers reading the PDF version are advised to consult the 
org-mode version.

#+latex: \lstset{upquote=true}
#+BEGIN_SRC elisp
  (require 'org-element)
  (cl-labels (

  ; lexical-defun
  (decorate-orgtable (tbl)
    (seq-concatenate
     'string
     "("
  "| Exercise | Days | Sessions | Minutes |"
  (char-to-string ?\n)
  "|- + - + - + - |"
  (format-orgtable tbl)
  ")")
  )

  ; lexical-defun
  (format-orgtable (list-of-lists)
  (apply
   #'seq-concatenate
   (cons
    'string
    (seq-map 
       (lambda (x) (format-table-line x))
      list-of-lists)))
  )

  ; lexical-defun
  (format-table-line (line)
  (seq-concatenate 'string
   (char-to-string ?\n)
   "|"
   (substring 
     (car line)
     0
     (min 60 (seq-length (car line))))
   "|"
   (format "%3.3f"(caddr line))
   "|"
   (format "%3d" (nth 4 line))
   "|"
   (format "%3.3f" (nth 6 line))
   "|")
  )

  ;; lexical-defun
  (get-study-sessions-data ()
    (save-excursion
      (org-babel-goto-named-src-block
        "study-sessions-data")
      (seq-map (lambda (x) 
                 (list
                      (org-time-string-to-seconds
                        (substring-no-properties
                          x
                          3
                          23))
                      (org-time-string-to-seconds
                        (substring-no-properties
                          x
                          26
                          46))
                      ))
      (seq-subseq
       (split-string
        (org-element-property 
          :value 
          (org-element-at-point))
        "\n")
       0
       -1))) 
   )

  ;; lexical-defun
  (get-task-sequence-data ()
  (save-excursion
      (org-babel-goto-named-src-block 
        "completion-times-data")
    (let ((exercise-index 0))
     (seq-mapn
      (lambda (nam dat)
        (setq exercise-index
          (+ 1 exercise-index))
        (list nam dat exercise-index))
    (apply #'seq-concatenate 
    (cons 'list
    (seq-map-indexed
       (lambda (x idx) 
         (if (= 0 (mod idx 2))
           (list x)
           nil))
       (seq-subseq
       (split-string
        (org-element-property 
          :value (org-element-at-point))
        "\n")
       0
       -1))))
      (apply #'seq-concatenate 
    (cons 'list
    (seq-map-indexed
       (lambda (x idx) 
         (if (= 1 (mod idx 2))
           ;(print x)
           (list x)
           nil))
       (seq-subseq
       (split-string
        (org-element-property
          :value (org-element-at-point))
        "\n")
       0
       -1)))))))
  )

  ;; lexical-defun
  (sort-task-seq (task-seq)
   (seq-sort
    (lambda (x y)
      (if (org-time< (cadr x)
                     (cadr y))
          t
        nil))
    task-seq)
   )

  ;; lexical-defun
  (find-out-of-order-tasks (task-seq)
  (seq-reduce 
     (lambda (acc next-elem)
        (if (org-time< 
              (cadr next-elem) (cadr acc))
          (list (+ 1 (car acc))
                (cadr next-elem)
                (cons (cadddr acc) (caddr acc))
                next-elem)
          (list (car acc)
                (cadr next-elem)
                (caddr acc) next-elem)))
   task-seq
   (list 0 "2019-08-19 Mon 09:19" (list) (list)))
  )

  ;; lexical-defun
  (find-spanning-sessions-and-duration
   (prev-time-stamp 
    next-time-stamp
    study-sessions)
   (seq-reduce
    (lambda (acc next-session)
      (let ((session-start (car next-session))
            (session-end (cadr next-session)))
        (cond ((<= session-end prev-time-stamp) 
               acc)
              ((<= next-time-stamp session-start)
               acc)
              (t (list (+ (car acc) 1)
                       (+ (cadr acc)
 (cond ((and (<= prev-time-stamp session-start)
             (<= session-end next-time-stamp))
        (- session-end session-start))
       ((and (<= session-start prev-time-stamp)
             (<= prev-time-stamp session-end)
             (<= session-end next-time-stamp))
        (- session-end prev-time-stamp))
       ((and (<= prev-time-stamp session-start)
             (<= session-start next-time-stamp)
             (<= next-time-stamp session-end))
        (- next-time-stamp session-start))
       ((and (<= session-start prev-time-stamp)
             (<= next-time-stamp session-end))
        (- next-time-stamp prev-time-stamp))
       (t 0))))))))
    study-sessions
    (list 0 0)))

  ;; lexical-defun
  (summarize-list (sorted-task-seq study-sessions)
  (cadr (seq-reduce
(lambda (acc next-elem)
  (let ((prev-time-stamp (car acc))
        (retval (cadr acc))
        (next-time-stamp
         (org-time-string-to-seconds
          (cadr next-elem)))
        (exercise-name (car next-elem))
        (exercise-index (caddr next-elem)))
    (let ((spans-sessions
           (find-spanning-sessions-and-duration
            prev-time-stamp 
            next-time-stamp 
            study-sessions)))
      (list next-time-stamp
            (cons 
(list exercise-name
 :spent-time-calendar-days 
   (/ (-
       next-time-stamp
       prev-time-stamp)
      (* 60 60 24))
 :spans-sessions 
   (if (not (eq 0 (car spans-sessions)))
     (car spans-sessions)
   (error 
     "Fix time: %s, spans-sessions=%s"
     next-elem
     spans-sessions))
 :spent-time-net-minutes 
   (/ (cadr spans-sessions) 60)
 :original-index 
   exercise-index)
   retval)))))
         sorted-task-seq
         (list 
 (org-time-string-to-seconds
   "2019-08-19 Mon 09:19")
   ())))
)

  (r-h (l)
    (seq-reverse (seq-subseq l 0)))

  ;; lexical-defun
  (make-logarithmic-histogram (astrotime-list)
  (let* ((numbins
          (ceiling
           (log (+ 1.0
                   (seq-reduce
                    #'max
                    (seq-map 
                      (lambda (x) (nth 6 x))
                     (r-h astrotime-list))
                    0))
                2))))

    (seq-reduce
     (lambda (acc elem)
       (let* ((hardness (nth 6 elem))
              (nbin (floor (log (+ 1.0 hardness)
                                2))))
         (aset acc
               nbin
               (+ 1 (aref acc nbin)))
         acc))
     (r-h astrotime-list)
     (make-vector numbins 0)))
  )

  ;; lexical-defun
  (make-linear-histogram (astrotime-list)
  (let* ((numbins 32)
         (binsize
          (ceiling
           (/ (seq-reduce
               #'max
               (seq-map
                (lambda (x) (nth 6 x))
                (r-h astrotime-list))
               0)
              numbins ))))

    (seq-reduce
     (lambda (acc elem)
       (let* ((hardness (nth 6 elem))
              (nbin (floor (/ hardness binsize))))
         (aset acc
               nbin
               (+ 1 (aref acc nbin)))
         acc))
     (r-h astrotime-list)
     (make-vector numbins 0)))
  )

  ;; lexical-defun
  (sort-by-hardness (astrotime-list)
  ;; 6 is the hardness index
  (seq-sort (lambda (x y)
              (let* ((hardness-x (nth 6 x))
                     (hardness-y (nth 6 y)))
                (if (< hardness-x hardness-y)
                    t
                  nil)))
            astrotime-list)
  )

  ;; lexical-defun
  (sort-by-nsessions (astrotime-list)
  ;; 4 is the nsessions index
  (seq-sort (lambda (x y)
              (let* ((nses-x (nth 4 x))
                     (nses-y (nth 4 y)))
                (if (< nses-x nses-y)
                    t
                  nil)))
            astrotime-list)
  )

  ;; lexical-defun
  (sort-by-original-index (astrotime-list)
  ;; 8 is the original index
  (seq-sort (lambda (x y)
              (let* ((oidx-x (nth 8 x))
                     (oidx-y (nth 8 y)))
                (if (< oidx-x oidx-y)
                    t
                  nil)))
            astrotime-list)
  )

  ) ;; end cl-labels defuns

  (let* (

  ;; lexical-define
  (study-sessions (get-study-sessions-data))

  ;; lexical-define
  (task-seq (get-task-sequence-data))

  ;; lexical-define
  (sorted-task-seq (sort-task-seq task-seq))

  ;; lexical-define
  (out-of-order-tasks 
    (find-out-of-order-tasks task-seq))

  ;; lexical-define
  (astrotime-list
   (summarize-list 
     sorted-task-seq
     study-sessions))

  ;; lexical-define
  (problems-sorted-by-completion-time
   (seq-reverse astrotime-list))

  ;; lexical-define
  (logarithmic-histogram
   (make-logarithmic-histogram astrotime-list))

  ;; lexical-define
  (linear-histogram
   (make-linear-histogram astrotime-list))

  ;; lexical-define

  (problems-sorted-by-hardness
   (sort-by-hardness astrotime-list))

  ;; lexical-define
  (problems-sorted-by-nsessions
   (sort-by-nsessions astrotime-list))

  ;; lexical-define
  (problems-sorted-by-original-index
   (sort-by-original-index astrotime-list))

  )

 (princ (char-to-string ?\())
 (pp "Amount of the out-of-order-problems: ")
 (princ (char-to-string ?\())
 (pp (number-to-string 
       (car out-of-order-tasks)))
 (princ (char-to-string ?\n))

 (pp "Out-of-order problems :")
 (princ (char-to-string ?\n))
 (pp (caddr out-of-order-tasks))
 (princ (char-to-string ?\n))

 (pp "Task summary (completion time):")
 (princ (char-to-string ?\n))
 (princ 
  (decorate-orgtable 
   (seq-subseq 
    problems-sorted-by-completion-time
    0 3)))
 (princ (char-to-string ?\n))


 (princ (char-to-string ?\n))
 (pp "Task summary (original-index):")
 (princ (char-to-string ?\n))
 ;; (pp (seq-subseq
 ;; problems-sorted-by-original-index 0 2))
 (princ 
  (decorate-orgtable 
   (seq-subseq 
    problems-sorted-by-original-index
    0 3)))
 (princ (char-to-string ?\n))

 ;; Hardest 10 problems
 (princ (char-to-string ?\n))
 (pp "Hardest 10 problems (raw):")
 (princ (char-to-string ?\n))
 ;; (pp (seq-subseq
 ;; problems-sorted-by-original-index 0 2))
 (princ 
  (decorate-orgtable 
   (seq-subseq 
    problems-sorted-by-hardness
    -10)))
 (princ (char-to-string ?\n))

 ;; Hardest 10 problems
 (princ (char-to-string ?\n))
 (pp "Hardest 10 problems (sessions):")
 (princ (char-to-string ?\n))
 ;; (pp (seq-subseq
 ;; problems-sorted-by-original-index 0 2))
 (princ 
  (decorate-orgtable 
   (seq-subseq 
    problems-sorted-by-nsessions
    -10)))
 (princ (char-to-string ?\n))


 (princ (char-to-string ?\n))
 (pp "Logarithmic histogram:")
 ;; Make a logarithmic histogram
 (princ (char-to-string ?\n))

 (pp logarithmic-histogram)
 (princ (char-to-string ?\n))

 (pp "Linear histogram:")
 (princ (char-to-string ?\n))
 ;; Make a linear histogram
 (pp linear-histogram)
 (princ (char-to-string ?\n))

 (pp "Median difficulty:")
 (princ (char-to-string ?\n))

 (pp
  (nth
   (floor (/ (seq-length
              problems-sorted-by-hardness)
             2))
          problems-sorted-by-hardness))

 (pp "Median n-sessions:")
 (princ (char-to-string ?\n))

 (pp
  (nth
   (floor (/ (seq-length
              problems-sorted-by-nsessions)
             2))
          problems-sorted-by-nsessions))
 (princ (char-to-string ?\))))
 ))
#+END_SRC




# * COMMENT Table of Contents
#+TOC: headlines 3
#+latex: \tableofcontents

# ./experience-report-minutes-per-problem.png http://lockywolf.files.wordpress.com/2021/02/experience-report-minutes-per-problem.png

# experience-report-days.png http://lockywolf.files.wordpress.com/2021/02/experience-report-days-1.png
# experience-report-study-sessions.png http://lockywolf.files.wordpress.com/2021/02/experience-report-study-sessions.png

# experience-report-hardness-histogram-linear.png http://lockywolf.files.wordpress.com/2021/02/experience-report-hardness-histogram-linear.png
# experience-report-hardness-histogram-logarithmic.png http://lockywolf.files.wordpress.com/2021/02/experience-report-hardness-histogram-logarithmic.png
