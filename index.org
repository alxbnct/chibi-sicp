# -*- mode: org; geiser-scheme-implementation: chibi;  -*-
# Time-stamp: <2019-09-20 16:34:51 lockywolf>
# Created   : [2019-08-18 Sun 20:11]
# Author    : lockywolf gmail.com

#+STARTUP: inlineimages
#+STARTUP: latexpreview
#+HTML_MATHJAX: align: left indent: 5em tagside: left font: Neo-Euler
#+HTML_MATHJAX: cancel.js noErrors.js
#+OPTIONS: tex:imagemagick


* noweb + common
** Setting chibi arguments. DANGEROUS                       :dangerous:elisp:

#+begin_src elisp :export both :results value
(setq geiser-chibi-extra-command-line-parameters
   '("-m" "chibi" "-m" "chibi show" "-m" "chibi show pretty"
     "-m" "chibi ast" "-m" "chibi time" "-m" "srfi 27" "-m" "chibi process"))
#+end_src

#+RESULTS:
| -m | chibi | -m | chibi show | -m | chibi show pretty | -m | chibi ast | -m | chibi time | -m | srfi 27 |

** Some common code blocks

#+name: common
#+begin_src scheme :results output :exportss none
  (import (chibi ast))
  (import (chibi show))
   (define (disp sexp)
     (display sexp)
     (newline))
#+end_src

#+RESULTS: common

* SICP [27%]
:PROPERTIES:
:header-args: :noweb yes
:END:

** TODO Chapter 1: Building abstractions with procedures [57/61]
*** Snippet
 #+BEGIN_SRC scheme :exports both :results value :session
   (* (+ 2 (* 4 6))
      (+ 3 5 7))
 #+END_SRC

 #+RESULTS:
 : 390

*** Thought
 Tree accumulation is the process of computing a thing by traversing a tree.

*** DONE Figure 1.1 Tree representation, showing the value of each subcombination :graphviz:
    CLOSED: [2019-08-20 Tue 14:35]
 For the sake of pedagogical clarity, I have formatted it as a picture.
 #+BEGIN_SRC plantuml :exports both :file figure-1-1-mm.png
 @startmindmap
 skinparam monochrome true
 +_ 390
 ++_ *
 ++_ 26
 +++_ +
 +++_ 2
 +++_ 24
 ++++_ *
 ++++_ 4
 ++++_ 6
 ++_ 15
 +++_ +
 +++_ 3
 +++_ 5
 +++_ 7
 @endmindmap
 #+END_SRC

 #+RESULTS:
 [[file:figure-1-1-mm.png]]
 ;
 # Then next line is the same diagram verbose, using DOT.
 #+begin_src plantuml :exports both :file figure-1-1-dot.png
 @startdot
 graph g {
	 node [shape=plaintext];
	 A1 [label="390"];

	 B1 [label="*"];
	 B2 [label="26"];
	 B3 [label="15"];

	 C1 [label="+"];
	 C2 [label="2"];
	 C3 [label="24"];

	 D1 [label="*"];
	 D2 [label="4"];
	 D3 [label="6"];

	 E1 [label="+"];
	 E2 [label="3"];
	 E3 [label="5"];
	 E4 [label="7"];

 // edges
	 A1 -- B1;
	 A1 -- B2;
	 A1 -- B3;
	
	 B2 -- C1;
	 B2 -- C2;
	 B2 -- C3;

	 C3 -- D1;
	 C3 -- D2;
	 C3 -- D3;

	 B3 -- E1;
	 B3 -- E2;
	 B3 -- E3;
	 B3 -- E4;

 //	B1 -> B3 [label="(g o f)'" tailport=s headport=s];

	 { rank=same; A1 }
	 { rank=same; B1 B2 B3 } 
	 { rank=same; C1 C2 C3 }
	 { rank=same; D1 D2 D3 }
	 { rank=same; E1 E2 E3 E4 }
 } 
 @enddot
 #+end_src 

 #+RESULTS:
 [[file:figure-1-1-dot.png]]

*** Snippet
#+name square
#+begin_src scheme :exports both :results value :session
  (define (square x) (* x x))
  (define (sum-of-squares x y)
    (+ (square x) (square y)))
  (sum-of-squares 3 4)
#+end_src

#+RESULTS:
: 25

*** DONE Exercise 1.1 Interpreter result
    CLOSED: [2019-08-20 Tue 14:23]
 #+begin_src scheme :exports both :results output :session
   (define (disp sexp)
     (display sexp)
     (newline))
   (disp 10)
   (disp (+ 2 3 4))
   (disp (- 9 1))
   (disp (/ 6 2))
   (disp (+ (* 2 4) (- 4 6)))
   (define a 3)
   (define b (+ a 1))
   (disp (+ a b (* a b)))
   (disp (= a b))
   (disp
    (if (and (> b a) (< b (* a b )))
	b
	a))
   (disp (cond ((= a 4) 6)
	((= b 4) (+ 6 7 a))
	(else 25)))
   (disp (+ 2 (if (< b a) b a)))
   (disp (* (cond ((> a b) a)
               ((< a b) b)
               (else -1)) 
            (+ a 1)))
 #+end_src

 #+RESULTS:
 #+begin_example
 10
 9
 8
 3
 6
 19
 #f
 4
 16
 5
 16
 #+end_example

*** DONE Exercise 1.2 Prefix form
    CLOSED: [2019-08-20 Tue 14:25]
 #+begin_src scheme :exports both :results value :session
 (/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))
 #+end_src

 #+RESULTS:
 : -37/150

*** DONE Exercise 1.3 Sum of squares
    CLOSED: [2019-08-20 Tue 14:35]
 #+begin_src scheme :exports both :results value :session
 (define (sum-of-squares x y)
   (+ (square x) (square y)))
 (import (srfi 95))
 (define (sum-of-two-max a b c)
   (let ((num_list (sort (list a b c) (lambda (a b) (if (> a b) a b)))))
    (sum-of-squares (car num_list) (cadr num_list))))
 (sum-of-two-max 1 2 3)
 #+end_src

 #+RESULTS:
 : 13

*** DONE Exercise 1.4 Compound expressions
    CLOSED: [2019-08-20 Tue 14:39]
 #+begin_src scheme :exports both :results output :session
 (define (a-plus-abs-b a b)
   ((if (> b 0) + -) a b))
 (disp (a-plus-abs-b  3 4))
 (disp (a-plus-abs-b  3 -4))
 #+end_src

 #+RESULTS:
 : 7
 : 7

*** DONE Exercise 1.5 Ben's test
    CLOSED: [2019-08-20 Tue 14:50]
 #+begin_src scheme :exports both :results value
 (define (p) (p))
 (define (test x y)
   (if (= x 0) 0 y))
 (test 0 (p))
 #+end_src

 On my interpreter this code goes into an infinite recursion, which
 makes sense, I guess, since the second argument to (test) is evaluated
 before executing (test). However, if we only substitute /p/ into the
 application of test and try to traverse the tree depth-first, this
 code should be able to terminate successfully?

*** DONE Exercise 1.6 If is a special form
    CLOSED: [2019-08-21 Wed 14:05]
The problem with this Alyssa's (new-if) is that both arguments would
be computed, so this (new-if) would be either very inefficient or even
not working at all in the case when one of the arguments is
infeasible.
Consider:

#+begin_src scheme :exports both :results output :session
<<common>>
(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
(define a 1)
(define b 0)
(disp (if (not (= b 0)) (/ a b) a))
(new-if (not (= b 0)) (/ a b) a)
#+end_src

#+RESULTS:
: 1
: {Exception #19 user "divide by zero" () #<procedure #f> (#f . 127)}

However, this issue can be solved using scheme macros.

#+begin_src scheme :exports both :results output :session
  <<common>>
  (define-syntax new-if
    (syntax-rules ()
      ( (new-if predicate then-clause else-clause)
	(cond (predicate then-clause)
	      (else else-clause))
      )
    )
  )
  (define a 1)
  (define b 0)
  (disp (if (not (= b 0)) (/ a b) a))
  (disp (new-if (not (= b 0)) (/ a b) a))

#+end_src

#+RESULTS:
: 1
: 1

The code above works as expected, because the macro does not evaluate
its arguments, and (cond) is a special form.

*** DONE Exercise 1.7 Good enough?
    CLOSED: [2019-08-22 Thu 12:52]
This exercise is a very misleading one. On the first glance is seems
that this is just about formulating a good criterion. Make no mistake,
practically solving this task means really writing all this code
carefully.

The function we are interested in is:
\begin{equation}
\label{eq:5}
f(x) = \sqrt{x}
\end{equation}

The code given in the chapter before is equivalent to the following
Newton's method formula, where $f_i$ denotes the next guess:
\begin{equation}
\label{eq:1} 
f_{i+1}_{} = \frac{f_i + \frac{x}{f_i}}{2}
\end{equation}

How on Earth does this formula even appear? Let's remember some
mathematics, namely, the Taylor series (variables unbound):
\begin{equation}
\label{eq:2}
 f(x) = f(x_{0}_{}) + f'(x_{0})(x-x_{0}) + o(x)
\end{equation}

Let us call `true' value of $\sqrt{x}=f$. Let us call our first guess
$f_{0}$. What is the value of the difference (error) between them?
Clearly, $f-f_0$. Well, the problem is — we don't know $f$. But we do
know $f^2$. Therefore $f^2-f^2_0$ is a number we know. What will be the
error on the next step of the algorithm? Let's find $f_1$ as
$f_1=f_0+\delta$. If $\delta$ is not too big, we can use the Taylor
expansion from ref:eq:1 $\delta$.
\begin{equation}
\label{eq:8}
E = f^2 - f_0^2 = f^2 - (f_0 + \delta)^2 \approx f^2 - f_0^2 - 2f_0\delta
\end{equation}


Be careful. What I expanded here is not the function value. It is the
_error_ value. Now, clearly we want our error to be as small as
possible, desirably as little as machine precision would allow. So
assuming $E=0$, we get an equation to solve:
\begin{align}
\label{eq:9}
E=0 \leftrightarrow& f^2-f_0^2-2f_0\delta=0 \\
\delta =& \frac{f_0^2 -f^2 }{2f_0}
\end{align}

Remember though that we don't need just $\delta$ here. We actually need
$f_1$. But $f_1$ is just $f_0+\delta$.
\begin{align}
\label{eq:10}
f_1 = \frac{f^2 - f_0^2}{2f_0} + f_0
\end{align}
Now if you rearrange this formula, you will get exactly the formula
ref:eq:1.

The code below is copied from SICP verbatim and implements the
algorithm above.

#+begin_src scheme :exports both :results value :session :noweb-ref simple-sqrt-iter
  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
	guess
	(sqrt-iter (improve guess x) x)))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results value :noweb-ref square-improve
  (define (improve guess x)
    (average guess (/ x guess)))
#+end_src

#+begin_src scheme :exports both :results value :session :noweb-ref simple-newton-recursion
  (define (good-enough? guess x)
    (< (abs (- (square guess) x)) 0.001))
  <<square-improve>>
  (define (average x y)
    (/ (+ x y) 2))
  (define (sqrt x)
    (sqrt-iter 1.0 x))

#+end_src

#+name simple-newton
#+begin_src scheme :exports both :results value :session
  <<common>>
  <<square>>
  <<simple-sqrt-iter>>
  <<simple-newton-recursion>>
  (sqrt 9)
#+end_src

#+RESULTS:
: 3.00009155413138

An example of how this fails on small numbers:

#+begin_src scheme :exports both :results value
<<simple-newton>>
(square (sqrt 0.0004))
#+end_src

#+RESULTS:
: 0.0012532224857331766

An example of why this fails on big numbers I didn't manage to
craft. Perhaps chibi-scheme has some clever way to deal with rounding?
Anyway — here is the code:
#+begin_src scheme :exports both :results value
  <<simple-newton>>
  (square (sqrt 9999999999.0))
#+end_src

#+RESULTS:
: 9999999999.0

Why exactly this is not very good algorithms is a good question. The
derivative of the square is well-defined near the 0, although the
derivative of the square root is not. Therefore, the equation ref:eq:8
become very imprecise. As we see, big number seem to be working fine
in my scheme implementation.

Let us write a better sqrt-iter?.

#+begin_src scheme :exports both :results value :noweb-ref better-sqrt-iter
  (define (sqrt-iter guess x)
   (let ((better-guess (improve guess x)))
    (if (good-enough? guess (square better-guess))
	better-guess
	(sqrt-iter better-guess x))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref better-newton
<<common>>
<<square>>
<<better-sqrt-iter>>
<<simple-newton-recursion>>
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results value
<<better-newton>>
(square (sqrt 0.0004))
#+end_src

#+RESULTS:
: 0.0005452233379244715

Works faster and gives a better result. Seemingly. QED[fn:1].

*** DONE Exercise 1.8 Newton's method
    CLOSED: [2019-08-22 Thu 17:36]

This exercise is not very hard. The only difference is that the
`improve' function is not derived from a derivative of a square but
rather from a derivative of a cube.


#+name: cube-improve
#+begin_src scheme :exports both :results value
(define (cube-improve guess x)
    (/ (+ (/ x (* guess guess)) (* 2 guess)) 3))
#+end_src

#+RESULTS: cube-improve
: #<undef>

#+name: cube-good-enough
#+begin_src scheme :exports both :results value
(define (cube-good-enough? guess x)
  (< (abs (- (cube guess) x)) 0.001))
#+end_src

#+RESULTS: cube-good-enough
: #<undef>

#+name: cube-root-iter
#+begin_src scheme :exports both :results value
  (define (cube-root-iter guess x)
    (let ((better-guess (cube-improve guess x)))
      (disp better-guess)
      (if (cube-good-enough? better-guess (cube guess))
	  better-guess
	  (cube-root-iter better-guess x))))
#+end_src

#+RESULTS: cube-root-iter
: #<undef>

#+name: cube-simple
#+begin_src scheme :exports both :results output
<<common>>
<<cube>>
<<cube-improve>>
<<cube-good-enough>>
<<cube-root-iter>>
(cube-root-iter 1.0 27.0)
#+end_src

#+RESULTS: cube-simple
: 9.666666666666666
: 6.540758356453956
: 4.570876778578707
: 3.4780192333867963
: 3.0626891086275365
: 3.001274406506175
: 3.0000005410641766
: 3.0000000000000977

*** TODO Figure 1.2 Procedural decomposition of the sqrt program
TODO
*** TODO Figure 1.3 A linear recursive process for computing \(6!\).
TODO
*** TODO Figure 1.4 A linear iterative process for computing \(6!\).
TODO
*** DONE Exercise 1.9 Iterative or recursive? :macro:er_macro_transformer:chicken:
    CLOSED: [2019-08-29 Thu 15:14]

I didn't find (inc) and (dec) in my scheme, so I define them myself.

I still don't want to overload the "+" and "-" symbols, so I will call
them `plus' and `minus'.

#+name: example-substitution-first
#+begin_src scheme :exports both :results value
  (define (inc x)
    (+ 1 x))
  (define (dec x)
    (- x 1))
  (define-syntax plusF
    (er-macro-transformer
     (lambda (form rename compare?)
       (let ((a (cadr form))
	     (b (caddr form)))
n	 (if (= a 0) b `(inc (plusF ,(dec a) ,b)))))))
  (macroexpand '(plusF 4 5))
#+end_src

#+RESULTS: example-substitution-first
| inc | (inc (inc (inc 5))) |

We can see that the macro expander has expanded the computation in to
a tree of length 4. This happens because the algorithm is genuinely
recursive, the return value is not produced by a call to itself, and
therefore recursion cannot be tail-optimized. 

#+name: example-substitution-second
#+begin_src scheme :exports both :results value
  (define (inc x)
    (+ 1 x))
  (define (dec x)
    (- x 1))
  (define-syntax plusS
    (er-macro-transformer
     (lambda (form rename compare?)
       (let ((a (cadr form))
	     (b (caddr form)))
	 (if (= a 0) b `(plusS ,(dec a) ,(inc b)))))))
  (macroexpand '(plusS 4 5))
#+end_src

#+RESULTS: example-substitution-second
: 9


We can clearly see the difference. The first macro is genuinely
recursive, it expands to a series of calls, and needs to keep the
information about this calls on the stack. The second one is actually
iterative. The macro call only happens as the last step, and no
information is kept, as the return value will be just the last result,
so this macro is expanded until it's just a number.

*** DONE Exercise 1.10 Ackermann's function
    CLOSED: [2019-08-25 Sun 18:31]
Let's run the demos first:
#+name: ackerman
#+begin_src scheme :exports both :results output :session
  <<common>>
  (define (A x y)
    (cond ((= y 0.0) 0.0)
	  ((= x 0.0) (* 2.0 y))
	  ((= y 1.0) 2.0)
	  (else (A (- x 1.0) (A x (- y 1.0))))))
  (disp (A 1 10))
  (disp (A 2 4))
  (disp (A 3 3))
#+end_src

#+RESULTS: ackermann
: 1024.0
: 65536.0
: 65536.0

The values of these expressions are listed above.

#+begin_src scheme :exports both :results value :session
  (define (f n) (A 0 n))
  (define (g n) (A 1 n))
  (define (h n) (A 2 n))
  (define (k n) (* 5 n n))
#+end_src

#+RESULTS:
: #<undef>

The mathematical expressions for these formulae are:
\begin{eqnarray}
\label{eq:3}
f(n) & = & 2y\\
g(n) & = & 2^y \\
h(n) & = & 2^{2^n}\\
k(n) & = & 5n^2\\
\end{eqnarray}

Actually this is not the Ackermann's function as it is most often
defined, for example, see
[[http://mathworld.wolfram.com/AckermannFunction.html]]. But the
recurrent relation is the same. This version of the Ackermann's
function seems to be equivalent to the powers tower.

I may have lied with the coefficients, but essentially, the
Ackermann's function with parameters $n$ and $m$ works by applying the
n-the hyperoperator m times to 2. A hyperoperator is a generalization
of the standard matematical operator sequence `+', `*', `^', see
[[https://googology.wikia.org/wiki/Hyper_operator]]

*** TODO Figure 1.5 The tree-recursive process generated in computing (fib 5)
*** DONE Exercise 1.11 Recursive vs iterative
    CLOSED: [2019-08-25 Sun 19:25]

\begin{equation}
\label{eq:4}
f(n)=\left\{
\begin{array}{l@{\quad:\quad}l}
n & n<3\\
f(n-1) + 2f(n-2) + 3f(n-3) & \ge 3
\end{array}\right.
\end{equation}

#+begin_src scheme :exports both :results value :session
    (define (f-recursive n)
      (cond ((< n 3) n)
	    (else
	     (+
	      (f-recursive (- n 1))
	      (* 2 (f-recursive (- n 2)))
	      (* 3 (f-recursive (- n 3)))))))
    (f-recursive 7)
#+end_src

#+RESULTS:
: 142

#+begin_src scheme :exports both :results value :session
  (define (f-iter m n fn-1 fn-2 fn-3)
    (let ((fn (+ fn-1 (* 2 fn-2) (* 3 fn-3))))
      (cond ((= m n) fn)
	     (else (f-iter m (+ n 1) fn fn-1 fn-2)))))

  (define (f-iterative n)
    (cond ((< n 3) n)
	  (else (f-iter n 3 2 1 0))))

  (f-iterative 7)
#+end_src

#+RESULTS:
: 142

*** DONE Exercise 1.12 Recursive Pascal's triangle
    CLOSED: [2019-08-25 Sun 19:42]

\begin{tabular}{rcccccccccc}
 &    &    &    &    &  1\\\noalign{\smallskip\smallskip}
 &    &    &    &  1 &    &  1\\\noalign{\smallskip\smallskip}
 &    &    &  1 &    &  2 &    &  1\\\noalign{\smallskip\smallskip}
 &    &  1 &    &  3 &    &  3 &    &  1\\\noalign{\smallskip\smallskip}
 &  1 &    &  4 &    &  6 &    &  4 &    &  1\\\noalign{\smallskip\smallskip}
 &    &    &    &  . &  . &  . &    &    &   &   \\\noalign{\smallskip\smallskip}
\end{tabular}

#+BEGIN_SRC scheme
    (define (pascal-number line-number column-number)
      (cond ((= line-number 1) 1)
	    ((= line-number 2) 1)
	    ((= column-number 1) 1)
	    ((= column-number line-number) 1)
	    (else (+
		   (pascal-number (- line-number 1) (- column-number 1))
		   (pascal-number (- line-number 1) column-number)))))
    (pascal-number 5 3)
#+END_SRC

#+RESULTS:
: 6

*** DONE Exercise 1.13 Fibonacci
    CLOSED: [2019-08-25 Sun 23:04]

\begin{equation}
\label{eq:6}
\mbox{Fib}(n)=\left\{ 
\begin{array}{l@{\quad:\quad}l}
0 & n=0\\
1 & n=1\\
\mbox{Fib}(n-1) + \mbox{Fib}(n-2) & \mbox{otherwise}}
\end{array}\right.
\end{equation}

Abelson and Sussman define \(\varphi=(1+\sqrt{5})/2\) and \(\psi=(1-\sqrt{5})/2\).

Knowing that \( \mbox{Fib}(n) = (\varphi^{n} - \psi^n)/\sqrt{5}\) is almost all the
problem done, because \(\psi\) is clearly less than \(1\), so for large
\(n\) it will be exponentially close to \(0\), and this is where the
``closest integer'' comes from.

Let us prove the rest by induction.
\begin{eqnarray}
\label{eq:13}
\frac{\varphi^{n-1} - \psi^{n-1} + \varphi^{n-2} - \psi^{n-2}}{\sqrt{5}} &=& \frac{\varphi^{n} - \psi^{n}}{\sqrt{5}}\\
\varphi^{n-1} - \psi^{n-1} + \varphi^{n-2} - \psi^{n-2} &=& \varphi^{n} - \psi^{n} \\
(\varphi + 1)\varphi^{n-2} - (\psi + 1)\psi^{n-2} &=&  \varphi^{n} - \psi^{n}\\
(\varphi + 1 - \varphi^2)\varphi^{n-2} &=&  (\psi + 1 - \psi^2)\psi^{n-2}\\
(\frac{1+\sqrt{5}}{2} + 1 - (\frac{1+\sqrt{5}}{2})^2)\varphi^{n-2} &=&
(\frac{1-\sqrt{5}}{2} + 1 - (\frac{1-\sqrt{5}}{2}))\psi^{n-2} \\
(\frac{2+2\sqrt{5}}{4} + \frac{4}{4} - \frac{1+2\sqrt{5}+5}{4})\varphi^{n-2} &=&
(\frac{2-2\sqrt{5}}{4} + \frac{4}{4} - \frac{1-2\sqrt{5}+5}{4})\psi^{n-2}\\
0&=&0
\end{eqnarray}

This proves that the recurrent relation for \(\frac{\varphi^n-\psi^n}{\sqrt{5}}\) is the
same as for the Fibonacci sequence. Then if we prove that there exist
such \(n\) and \(n-1\) so that \(\mbox{Fib}(n) =
\frac{\varphi^n-\psi^n}{\sqrt{5}}\), then we're done.

Indeed, let's have a look at \(n=1\): \(\frac{1+\sqrt{5}}{2
\sqrt{5}} - \frac{1-\sqrt{5}}{2 \sqrt{5}} = 1\); and \(n=0\): \(
\frac{1-1}{\sqrt{5}} = 0\).

*** DONE Exercise 1.14 count-change              :macro:er_macro_transformer:
    CLOSED: [2019-08-30 Fri 16:09]

Let us use the non-standard but common er-macro-transformer to plot
the execution tree.

#+begin_src scheme :exports both :results output
  (define-syntax cc
    (er-macro-transformer
     (lambda (form rename compare?)
       (let ((amount (cadr form))
	     (kinds-of-coins (caddr form)))
	 (cond ((= amount 0) 1)
	       ((or (< amount 0) (= kinds-of-coins 0)) 0)
	       (`(+ (cc ,amount
			,(- kinds-of-coins 1))
		    (cc ,(- amount
			    (first-denomination
			     kinds-of-coins))
			,kinds-of-coins))))))))
  (define (first-denomination kinds-of-coins)
    (cond ((= kinds-of-coins 1) 1)
	  ((= kinds-of-coins 2) 5)
	  ((= kinds-of-coins 3) 10)
	  ((= kinds-of-coins 4) 25)
	  ((= kinds-of-coins 5) 50)))
(show #t " "(pretty (macroexpand '(cc 11 5))))
#+end_src

#+RESULTS:
:  (+
:   (+
:    (+
:     (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 1)))))))))))
:        (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 1)))))) (+ (+ 0 1) 0)))
:     (+ (+ (+ 0 1) 0) 0))
:    0)
:   0)

Initially I wrote the same code in Emacs Lisp, I am leaving it here
for future reference.

#+begin_src elisp :exports both :results output
    (defmacro cc (amount kinds-of-coins)
      (cond ((= amount 0) 1)
	    ((or (< amount 0) (= kinds-of-coins 0)) 0)
	    (`(+ (cc ,amount
		    ,(- kinds-of-coins 1))
		(cc ,(- amount
		       (first-denomination
			kinds-of-coins))
		    ,kinds-of-coins)))))
  (defun first-denomination (kinds-of-coins)
    (cond ((= kinds-of-coins 1) 1)
	  ((= kinds-of-coins 2) 5)
	  ((= kinds-of-coins 3) 10)
	  ((= kinds-of-coins 4) 25)
	  ((= kinds-of-coins 5) 50)))
  (pp (macroexpand-all '(cc 11 5)))

#+end_src

#+RESULTS: ?
#+begin_example
(+
 (+
  (+
   (+
    (+ 0
       (+ 0
	  (+ 0
	     (+ 0
		(+ 0
		   (+ 0
		      (+ 0
			 (+ 0
			    (+ 0
			       (+ 0
				  (+ 0 1)))))))))))
    (+
     (+ 0
	(+ 0
	   (+ 0
	      (+ 0
		 (+ 0
		    (+ 0 1))))))
     (+
      (+ 0 1)
      0)))
   (+
    (+
     (+ 0 1)
     0)
    0))
  0)
 0)
#+end_example

The space complexity of the algorithm will be dominated by the depth
of the tree — that is the value to be changed, as there is no need to
keep any additional information.

The time complexity can be estimated as follows: for every additional
value the algorithm will have to go through all passes of the
algorithm without an additional denomination, times the amount divided
by the value of an additional denomination. We can consider the
additional denomination value as a constant, and the amount of steps
for the simplest case of only one denomination is the
amount. Therefore, the algorithm is linear in amount and exponential
in the number of denominations.

\begin{equation}
\label{eq:14}
C = \Theta(n^a)
\end{equation}

*** I found a bug in ob-scheme while doing this Exercise.
 _In process I have found a bug in org-babel!_
#+begin_src scheme :exports both :results output
(display "(+ 0) ")
#+end_src

#+RESULTS:
: 0

#+begin_src scheme :exports both :results output
(display "(+ 0)")
#+end_src

#+RESULTS:
| + | 0 |

(org-babel-script-escape "(+ 0)") (org-babel-script-escape "(+ 0) ")

*** DONE Exercise 1.15 sine                      :macro:er_macro_transformer:
    CLOSED: [2019-08-30 Fri 22:34]

First let us code this thing:

Loop version:

#+begin_src scheme :exports both :results output
  (define niter 0)
  (define (cube x) (* x x x))
  (define (p x)
    (set! niter (+ niter 1))
    (- (* 3 x) (* 4 (cube x))))
  (define (sine angle)
    (if (not (> (abs angle) 0.1))
	angle
	(p (sine (/ angle 3.0)))))
  (display "sine=" )
  (display (sine 12.15))
  (display " niter=")
  (display niter)
#+end_src

#+RESULTS:
: sine=-0.39980345741334 niter=5

Let's have the macro system expand this for us.

#+begin_src scheme :exports both :results output
  (define (cube x)
    (* x x x))
  (define (p x)
    (- (* 3  x)
       (* 4 (cube x))))
  (define-syntax sine
    (er-macro-transformer
     (lambda (form rename compare?)
       (let ((a (cadr form)))
	 (if (< (abs a) 0.1)
	     a
	     `(p (sine ,(/ a 3))))))))
  (show #t " " (pretty (macroexpand '(sine 12.15))))

#+end_src

#+RESULTS:
:  (p (p (p (p (p 0.05)))))

Theoretically, we can expand everything at once. 

#+begin_src scheme :exports both :results output
  (define-syntax cube
    (er-macro-transformer
     (lambda (form rename compare?)
       (let ((x (cadr form)))
	 `(* ,x ,x ,x)))))
  (define-syntax p
    (er-macro-transformer
     (lambda (form rename compare?)
       (let ((x (cadr form)))
	 `(- (* 3 ,x)
	     (* 4 (cube ,x)))))))
  (define-syntax sine
    (er-macro-transformer
     (lambda (form rename compare?)
       (let ((a (cadr form)))
	 (if (< (abs a) 0.1)
	     a
	     `(p (sine ,(/ a 3))))))))
  (show #t " " (pretty (macroexpand '(sine 12.15))))
#+end_src

#+RESULTS:
#+begin_example
 (-
  (* 3
     (-
      (* 3
         (-
          (* 3
             (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                (* 4
                   (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                      (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                      (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
          (* 4
             (*
              (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                 (* 4
                    (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
              (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                 (* 4
                    (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
              (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                 (* 4
                    (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))))))
      (* 4
         (*
          (-
           (* 3
              (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                 (* 4
                    (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
           (* 4
              (*
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))))
          (-
           (* 3
              (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                 (* 4
                    (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
           (* 4
              (*
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))))
          (-
           (* 3
              (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                 (* 4
                    (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
           (* 4
              (*
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))))))))
  (* 4
     (*
      (-
       (* 3
          (-
           (* 3
              (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                 (* 4
                    (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
           (* 4
              (*
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))))))
       (* 4
          (*
           (-
            (* 3
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
            (* 4
               (*
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))))
           (-
            (* 3
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
            (* 4
               (*
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))))
           (-
            (* 3
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
            (* 4
               (*
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))))))))
      (-
       (* 3
          (-
           (* 3
              (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                 (* 4
                    (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
           (* 4
              (*
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))))))
       (* 4
          (*
           (-
            (* 3
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
            (* 4
               (*
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))))
           (-
            (* 3
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
            (* 4
               (*
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))))
           (-
            (* 3
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
            (* 4
               (*
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))))))))
      (-
       (* 3
          (-
           (* 3
              (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                 (* 4
                    (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
           (* 4
              (*
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))))))
       (* 4
          (*
           (-
            (* 3
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
            (* 4
               (*
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))))
           (-
            (* 3
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
            (* 4
               (*
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))))
           (-
            (* 3
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
            (* 4
               (*
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))))))))))
#+end_example

As seen from the code above, the amount of steps is 5. It is easily
seen from the fact that the application of ~p~ starts when *x* is
sufficiently small, and that requires \(0.1 > 12.15\cdot(\frac{1}{3})^n \Rightarrow n
= O(\log_3 121.5)\) steps.

~(sine x)~ is expandable in constant space and time, ~(cube x)~ is
expandable in constant space and time if multiplication is an
elementary operation. Therefore the only operation left is
~p~. Therefore, time and space are of equal order of magnitude.

 - \(\left\lceil \log_3 121.5 \right\rceil = 5\)
 - \(O(\ln(a\cdot b))\) where \(a\) is the angle and \(b\) is precision

*** DONE Exercise 1.16 Iterative exponentiation
    CLOSED: [2019-08-30 Fri 23:20]

For the start, let's input the code.

#+begin_src scheme :exports both :results value
  (define (expt b n)
    (if (= n 0)
	1
	(* b (expt b (- n 1)))))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results value
  (define (expt b n)
    (expt-iter b n 1))
  (define (expt-iter b counter product)
    (if (= counter 0)
	product
	(expt-iter b
		   (- counter 1)
		   (* b counter product))))
#+end_src

#+begin_src scheme :exports both :results value
  (define (fast-expt b n)
    (cond ((= n 0) 1)
	  ((even? n) (square (fast-expt b (/ n 2))))
	  (else (* b (fast-expt b (- n 1))))))
  (define (even? n)
    (= (remainder n 2) 0))
  (fast-expt 2 10)
#+end_src

#+RESULTS:
: 1024

#+begin_src scheme :exports both :results value
    (define (fast-expt b n a)
      (cond ((= n 0) a)
	    ((even? n)  (fast-expt (square b) (/ n 2) a))
	    (else (fast-expt b (- n 1) (* a b)))))
    (define (even? n)
      (= (remainder n 2) 0))
    (define (faster-expt b n)
      (fast-expt b n 1))
    (faster-expt 2 10)
#+end_src

#+RESULTS:
: 1024

The answer is the code block above. We just collect some data and put
it into the state variable *a*.

*** DONE Exercise 1.17 Fast multiplication
    CLOSED: [2019-08-30 Fri 23:48]
#+begin_src scheme :exports both :results value
  (define (double a)
    (* 2 a))
  (define (halve a)
    (if (even? a)
	(/ a 2)
	(raise "Error: a not even.")))
  (define (even? n)
	(= (remainder n 2) 0))
  (define (* a b)
    (cond 
     ((= b 0) 0)
     ((even? b) (double (* a (halve b))))
     (else (+ a (* a (- b 1))))))
  (* 137 17)
#+end_src

#+RESULTS:
: 2329

The procedure above uses logarithmic time and space, because for every
subtraction there is also at least one division, so the total
convergence speed is exponential. This could be reformulated as an
iterative procedure, with an accumulator variable, but I am too lazy.

*** DONE Exercise 1.18 Iterative multiplication
    CLOSED: [2019-08-31 Sat 11:43]

In Exercise 1.17 I said that I was too lazy to design an iterative
procedure. Well, now I do it in this exercise.

#+begin_src scheme :exports both :results value
  (define (double a)
    (* 2 a))
  (define (halve a)
    (if (even? a)
	(/ a 2)
	(raise "Error: a not even.")))
  (define (even? n)
	(= (remainder n 2) 0))
  (define (mul a b accumulator)
    (cond 
     ((= b 0) accumulator)
     ((even? b) (mul (double a) (halve b)))
     (else (mul a (- b 1) (+ a accumulator)))))
  (* 137 17)
#+end_src

#+RESULTS:
: 2329

The idea here is exactly the same as in the previous Exercise 1.18.

*** DONE Exercise 1.19 Logarithmic Fibonacci
    CLOSED: [2019-09-01 Sun 20:42]

As usualy, let's first copy the code of ~fib-iter~.

#+begin_src scheme :exports both :results value
  (define (fib n)
    (fib-iter 1 0 n))
  (define (fib-iter a b count)
    (if (= count 0)
	b
	(fib-iter (+ a b) a (- count 1))))
  (fib 10)
#+end_src

#+RESULTS:
: 55

The formula for \(T\) is the following:

\begin{eqnarray}
T_{pq} \begin{pmatrix} a\\ b \end{pmatrix} & = & \begin{pmatrix} aq+bq+ap \\ bp + aq \end{pmatrix} &\\ 
T_{pq} \left( T_{pq} \begin{pmatrix} a\\ b \end{pmatrix} \right) & = & \begin{pmatrix} (aq+bq+ap)q+(bp + aq)q+(aq+bq+ap)p \\ (bp + aq)p + (aq+bq+ap)q \end{pmatrix} &\\
T_{p'q'}\begin{pmatrix} a\\ b \end{pmatrix} & = & \begin{pmatrix}a(2pq + qq) + a(pp+qq) + b(2pq + qq)\\ a(2pq + qq) + b(pp + qq) \end{pmatrix}& \\
\end{eqnarray}
From here we can easily see the values for \(p\prime\) and \(q'\):
# \(a(2pq + qq) + a(pp+qq) + b(2pq + qq)\)
# \(a(2pq + qq) + b(pp + qq)\)

\(p'=pp+qq\), \(q' = 2pq+qq\)

Let us substitute them into the code given by Abelson and Sussman.

#+begin_src scheme :exports both :results value
  (define (fib n)
    (fib-iter 1 0 0 1 n))
  (define (fib-iter a b p q count)
    (cond ((= count 0) b)
	  ((even? count)
	   (fib-iter a
		     b
		     (+ (* p p) (* q q))
		     (+ (* 2 p q) (* q q))
		     (/ count 2)))
	  (else (fib-iter (+ (* b q) (* a q) (* a p))
			  (+ (* b p) (* a q))
			  p
			  q
			  (- count 1)))))
  (fib 10)
#+end_src

#+RESULTS:
: 55

Works.

*** *Interjection* ir-macro-transformer.

#+begin_src scheme :exports both :results value
  (define-syntax swap!
    (ir-macro-transformer
     (lambda (form inject compare?)
       (let ((a (cadr form))
	     (b (caddr form))
	     (tmp (cadr form)))
	     (set! a b)
	     (set! b tmp)))))
  (define x 4)
  (define y 5)
  (swap! x y)
  (list x y)
#+end_src

#+RESULTS:
: "{Exception #19 user \"undefined variable\" (ir-macro-transformer) #<procedure #f> (#f . 3)}"

*** DONE Exercise 1.20 GCD applicative vs normal :er_macro_transformer:macro:
    CLOSED: [2019-09-01 Sun 23:04]
The exercise urges us to recall the difference between the normal
order and the applicative order of evaluation.

 *Normal*: fully expand the computation tree until obtained an
expression involving only primitive operators.

 *Applicative*: evaluate the arguments and then apply.

First let us print the execution tree of the normal order.
#+begin_src scheme :exports both :results output
    (define-syntax gcd-normal
      (er-macro-transformer
       (lambda (form rename compare?)
	 (let ((a (cadr form))
	       (b (caddr form)))
	   (if (= b 0)
		`(if (= ,b 0)
                     ,a
                     (remainder ,a ,b))
		`(if (= ,b 0)
		     (,a (remainder ,a ,b))
		     (gcd-normal ,b ,(remainder a b))))))))
      (display (show #f " " (pretty (macroexpand '(gcd-normal 206 40)))))
#+end_src

#+RESULTS:
:  (if (= 40 0)
:      (206 (remainder 206 40))
:      (if (= 6 0)
:          (40 (remainder 40 6))
:          (if (= 4 0)
:              (6 (remainder 6 4))
:              (if (= 2 0) (4 (remainder 4 2)) (if (= 0 0) 2 (remainder 2 0))))))

Now let us show the applicative order.
#+begin_src scheme :exports both :results output
    (define-syntax gcd-normal
      (er-macro-transformer
       (lambda (form rename compare?)
	 (let ((a (cadr form))
	       (b (caddr form)))
	   (if (= b 0)
		`(if (= ,b 0)
                     ,a
                     'division-by-zero)
		`(if (= ,b 0)
		     (,a (remainder ,a ,b))
		     (gcd-normal ,b ,(remainder a b))))))))
      (display (show #f " " (pretty (macroexpand '(gcd-normal 206 40)))))
#+end_src

#+RESULTS:
:  (if (= 40 0)
:      (206 (remainder 206 40))
:      (if
:       (= 6 0)
:       (40 (remainder 40 6))
:       (if (= 4 0)
:           (6 (remainder 6 4))
:           (if (= 2 0) (4 (remainder 4 2)) (if (= 0 0) 2 'division-by-zero)))))

The problem here would arise, if the ~(if)~ form had a normal
evaluation order, because the last division, ~(remainder 2 0)~ may be
a forbidden operation, involving a division by zero. On the other
hand, the evaluation of ~(remainder x 0)~ could be defined as *x*, and
then the algorithm would evaluate one more (useless) remainder.

*** DONE Exercise 1.21 smallest-divisor
    CLOSED: [2019-09-01 Sun 23:43]

As usual, let us first copy the code for the ~smallest-divisor~.

#+begin_src scheme :exports both :results output :noweb-ref primetest
  (define (smallest-divisor n)
    (find-divisor n 2))
  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
	  ((divides? test-divisor n) test-divisor)
	  (else (find-divisor n (+ test-divisor 1)))))
  (define (divides? a b) (= (remainder b a) 0))

  (define (prime? n)
    (= n (smallest-divisor n)))
#+end_src

#+begin_src scheme :exports both :results output
  <<primetest>>
  (display (smallest-divisor 199))
  (newline)
  (display (smallest-divisor 1999))
  (newline)
  (display (smallest-divisor 19999))
  (newline)
  (display (/ 19999 7))
  (newline)
#+end_src

#+RESULTS:
: 199
: 1999
: 7
: 2857

Well, this problem doesn't look too complicated on the first glance.

*** DONE Exercise 1.22 timed-prime-test
    CLOSED: [2019-09-02 Mon 00:44]

#+begin_src scheme :exports both :results output :noweb-ref timed-primetest
  (define (runtime) (* 1000 (current-second)))

  (define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (runtime)))

  (define (start-prime-test n start-time)
    (if (prime? n)
	(report-prime (- (runtime) start-time))))

  (define (report-prime elapsed-time)
    (display " *** ")
    (display elapsed-time))
  (define (search-for-primes start finish)
    (timed-prime-test start)
    (if (< (+ 1 start) finish)
	(if (even? start)
	    (search-for-primes (+ start 1) finish)
	    (search-for-primes (+ start 2) finish))))
#+end_src

#+begin_src scheme :exports both :results output
  <<primetest>>
  <<timed-primetest>>
  (search-for-primes 1000 1020)
  (newline)
  (search-for-primes 10000 10038)
  (newline)
  (search-for-primes 100000 100044)
  (newline)
  (search-for-primes 1000000 1000038)
#+end_src

#+RESULTS:
#+begin_example

1000
1001
1003
1005
1007
1009 *** 0.006103515625
1011
1013 *** 0.005859375
1015
1017
1019 *** 0.005859375

10000
10001
10003
10005
10007 *** 0.016845703125
10009 *** 0.016845703125
10011
10013
10015
10017
10019
10021
10023
10025
10027
10029
10031
10033
10035
10037 *** 0.016845703125

100000
100001
100003 *** 0.052978515625
100005
100007
100009
100011
100013
100015
100017
100019 *** 0.052978515625
100021
100023
100025
100027
100029
100031
100033
100035
100037
100039
100041
100043 *** 0.052001953125

1000000
1000001
1000003 *** 0.163818359375
1000005
1000007
1000009
1000011
1000013
1000015
1000017
1000019
1000021
1000023
1000025
1000027
1000029
1000031
1000033 *** 0.1650390625
1000035
1000037 *** 0.1640625
#+end_example

 - Write the procedure: done.
 - Find the smallest three primes greater than 1000   : found.
 - Find the smallest three primes greater than 10000  : found.
 - Find the smallest three primes greater than 100000 : found.
 - Find the smallest three primes greater than 1000000: found.
 - The timing data confirms the prediction. \(\sqrt{10}\approx3\), \(0.16 \approx 3\cdot1.05\).
 - The execution time per step for testing 1.000.000 is 1.63e-07. The
   execution time per step for testing 100.000 5.3199e-07. At least on
   my machine the claim doesn't seem to hold very well.

*** DONE Exercise 1.23 (next test-divisor)
    CLOSED: [2019-09-02 Mon 09:56]

#+begin_src scheme :exports both :results value :noweb-ref improved-primetest
  (define (next x)
    (if (= 2 x)
	3
	(+ x 2)))
  (define (smallest-divisor n)
    (find-divisor n 2))
  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
	  ((divides? test-divisor n) test-divisor)
	  (else (find-divisor n (next test-divisor)))))
  (define (divides? a b) (= (remainder b a) 0))

  (define (prime? n)
    (= n (smallest-divisor n)))

#+end_src

#+begin_src scheme :exports both :results output
<<improved-primetest>>
<<timed-primetest>>
(timed-prime-test 1009)
(timed-prime-test 1013)
(timed-prime-test 1019)
(timed-prime-test 10007)
(timed-prime-test 10009)
(timed-prime-test 10037)
(timed-prime-test 100003)
(timed-prime-test 100019)
(timed-prime-test 100043)
(timed-prime-test 1000003)
(timed-prime-test 1000033)
(timed-prime-test 1000037)

#+end_src

#+RESULTS:
#+begin_example

1009 *** 0.010009765625
1013 *** 0.00390625
1019 *** 0.00390625
10007 *** 0.010009765625
10009 *** 0.010009765625
10037 *** 0.010009765625
100003 *** 0.031005859375
100019 *** 0.03076171875
100043 *** 0.030029296875
1000003 *** 0.10205078125
1000033 *** 0.104736328125
1000037 *** 0.10205078125
#+end_example

We can see that the test does show a speed improvement, although not
as impressive as 2 times. We can observe that the number of steps is
not really halved, since ~(+ a b)~ requires one operation, and ~(if (=
2 x) 3 else (+ 3 2))~ requires three operations, so the speed should
improve by 3/2, which we can observe.

*** DONE Exercise 1.24 Fermat method
    CLOSED: [2019-09-02 Mon 11:32]

Firstly we need the ~(fast-prime?)~ procedure.

#+begin_src scheme :exports both :results value :noweb-ref random
(define (random x)
  (random-integer x))
#+end_src

#+RESULTS:
: 30

#+begin_src scheme :exports both :results value :noweb-ref expmod
  (define (expmod base exp m)
    (cond ((= exp 0) 1)
	  ((even? exp)
	   (remainder
	    (square (expmod base (/ exp 2) m))
	    m))
	  (else
	   (remainder
	    (* base (expmod base (- exp 1) m))
	    m))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref fermat-primetest
<<random>>
  (define (fermat-test n)
    (define (try-it a)
      (= (expmod a n n) a))
    (try-it (+ 1 (random (- n 1)))))
  (define prime-test fermat-test)
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref fast-prime
  (define (fast-prime? n times)
    (cond ((= times 0) true)
	  ((prime-test n) (fast-prime? n (- times 1)))
	  (else false)))
  (define true #t)
  (define false #f)
  (define (prime? x)
    (fast-prime? x 10))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results output
<<expmod>>
<<fermat-primetest>>
<<fast-prime>>
<<timed-primetest>>
(timed-prime-test 1009)
(timed-prime-test 1013)
(timed-prime-test 1019)
(timed-prime-test 10007)
(timed-prime-test 10009)
(timed-prime-test 10037)
(timed-prime-test 100003)
(timed-prime-test 100019)
(timed-prime-test 100043)
(timed-prime-test 1000003)
(timed-prime-test 1000033)
(timed-prime-test 1000037)
(timed-prime-test 1000)
(timed-prime-test 6601)
#+end_src

#+RESULTS:
#+begin_example

1009 *** 0.0830078125
1013 *** 0.057861328125
1019 *** 0.060791015625
10007 *** 0.072998046875
10009 *** 0.071044921875
10037 *** 0.07275390625
100003 *** 0.083251953125
100019 *** 0.0849609375
100043 *** 0.085693359375
1000003 *** 0.09521484375
1000033 *** 0.09619140625
1000037 *** 0.09814453125
1000
6601 *** 0.0478515625
#+end_example

Firstly, observe that the interpreter seems to be doing some black magic, so
that the test for 1009 takes more time than the test for 1013.

Secondly, observe that indeed, the speed seems to have reduced its dependence
on the length of a number, and if we want to test even bigger numbers, the
dependency should become even smaller, as \(\log(n)\) grows very slowly. In
particular, comparing the range around 1000 and 1000.000, the ratio of
\(\frac{\log_{10}(1000000)}{\log_{10}(1000)} = \frac{6}{3} = 2\). This doesn't seem
to be completely the case, but hey, there may be some constants involved, as
well as some interpreter dark magic.

*** DONE Exercise 1.25 expmod
    CLOSED: [2019-09-02 Mon 12:46]

Well, in principle, Alyssa's algorithm should work. The problem here really
is that we would have to store the number \(a^n\), which is a very big number,
especially because we are interested in testing primality of very large
numbers (e.g., 512-bit long cryptography keys), and \((2^{256-1})^{2^{256}}\)
is a very large number.

*** DONE Exercise 1.26 square vs mul
    CLOSED: [2019-09-02 Mon 12:50]

The hint here lies in the name of the person helping Louis. Eva Lu Ator
sounds similar to "evaluator", and the reason for Louis's problem really lies
in the optimization capabilities of the interpreter. That is, if the
evaluating algorithm uses applicative order, then the ~expmod~ is evaluated
twice per step, which makes ~(/ exp 2)~ useless. If, however, the interpreter
can memoize the results, his algorithm would be just as good.

*** DONE Exercise 1.27 Carmichael numbers
    CLOSED: [2019-09-02 Mon 20:50]

First let us recall some Carmichael numbers.

| # |      |
|---+------|
| 1 |  561 |
| 2 | 1105 |
| 3 | 1729 |
| 4 | 2465 |
| 5 | 2821 |
| 6 | 6601 |

We already have a procedure that computes \(a^n\mod n\), and a procedure that
computes \(a\mod n\) is even a scheme primitive. Moreover, we even have all
the code that does the comparison, with the single difference - our existing
code takes an initial guess uniformly at random, whereas we need to check all
\( a < n\).

#+begin_src scheme :exports both :results output
<<expmod>>
  (define (congruent? a n)
    (= (expmod a n n) a))
  (define (carmichael-iter a n)
    (cond ((= a n) #t)
	  ((not (congruent? a n)) #f)
	  (else (carmichael-iter (+ 1 a) n))))
  (define (carmichael-or-prime? n)
    (carmichael-iter 1 n))
  (define (test-carmichael n)
    (display "Testing ")
    (display n)
    (display ": ")
    (if (carmichael-or-prime? n)
      (display "true")
      (display "false"))
    (newline))
  (test-carmichael 561)
  (test-carmichael 1105)
  (test-carmichael 1729)
  (test-carmichael 2465)
  (test-carmichael 2821)
  (test-carmichael 6601)
  (test-carmichael 20)
  (test-carmichael 7)
#+end_src

#+RESULTS:
: Testing 561: true
: Testing 1105: true
: Testing 1729: true
: Testing 2465: true
: Testing 2821: true
: Testing 6601: true
: Testing 20: false
: Testing 7: true

*** DONE Exercise 1.28 Miller-Rabin
    CLOSED: [2019-09-02 Mon 23:28]
#+begin_src scheme :exports both :results value :noweb-ref expmod-miller-rabin
  (define (expmod base exp m)
    (cond ((= exp 0) 1)
	  ((even? exp)
	   (let* ((root (expmod base (/ exp 2) m))
		  (sq (square root)))
	     (if (and (= (remainder sq m) 1) (not (or (= root 1) (= root (- m 1)))))
	      0
	      (remainder sq m))))
	  (else
	   (remainder
	    (* base (expmod base (- exp 1) m))
	    m))))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results value :noweb-ref miller-rabin-primetest
    <<random>>
      (define (rabin-test n)
	(define (try-it a)
	  (let ((result (expmod a (- n 1) n) ))
	    (if (or (= 1 result)  (= n 1) (= n 0))
	    #t
	    #f)))
	(if (not (= n 1)) (try-it (+ 1 (random (- n 1)))) #t))
      (define prime-test rabin-test)

#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results output :noweb-ref rabin-prime
<<expmod-miller-rabin>>
<<miller-rabin-primetest>>
<<fast-prime>>
<<timed-primetest>>
#+end_src

#+RESULTS:

#+begin_src scheme :exports both :results output
<<rabin-prime>>
(timed-prime-test 1009)
(timed-prime-test 1013)
(timed-prime-test 1019)
(timed-prime-test 10007)
(timed-prime-test 10009)
(timed-prime-test 10037)
(timed-prime-test 100003)
(timed-prime-test 100019)
(timed-prime-test 100043)
(timed-prime-test 1000003)
(timed-prime-test 1000033)
(timed-prime-test 1000037)
(timed-prime-test 1000)
(timed-prime-test 6601)

#+end_src

#+RESULTS:
#+begin_example

1009 *** 0.09716796875
1013 *** 0.086669921875
1019 *** 0.087158203125
10007 *** 0.1220703125
10009 *** 0.113037109375
10037 *** 0.113037109375
100003 *** 0.130859375
100019 *** 0.133056640625
100043 *** 0.132080078125
1000003 *** 0.151123046875
1000033 *** 0.172119140625
1000037 *** 0.156982421875
1000
6601
#+end_example

I used the ~(let)~ construction introduced in the later chapters, because I
find bindings with nested procedures confusing.

*** DONE Exercise 1.29 Simpson's integral
    CLOSED: [2019-09-03 Tue 10:36]

Since at the end of the task we are told to compare the result of our
algorithm with the results of the ~integral~ procedure, let us first copy the
integral code.

#+begin_src scheme :exports both :results value :noweb-ref integral-common
  (define (sum term a next b)
    (if (> a b)
	0
	(+ (term a)
	   (sum term (next a) next b))))
  (define (cube x)
    (* x x x))
  (define (next point)
    (+ point 1))
#+end_src

#+begin_src scheme :exports both :results value 
<<integral-common>>
  (define (integral f a b dx)
    (define (add-dx x)
      (+ x dx))
    (* (sum f (+ a (/ dx 2.0)) add-dx b)
       dx))
  (list (integral cube 0 1 0.01) (integral cube 0 1 0.001))

#+end_src

#+RESULTS:
| 0.24998750000000053 | 0.24999987500000106 |

#+begin_src scheme :exports both :results output
  <<integral-common>>
  (define (integral-simpson f a b npoints)
    (define h (/ (- b a) npoints))
    (define h/3 (/ h 3))
    (define (f_k k)
      (* (f (+ a (* k h))) (cond ((= k 0) 1)
				 ((= k npoints) 1)
				 ((odd? k) 4)
				 ((even? k) 2))))
    (* h/3 (sum f_k 0 next npoints)))
  (display (integral-simpson cube 0 1 100))
  (newline)
  (display (integral-simpson cube 0 1 1000))
#+end_src

#+RESULTS:
: 1/4
: 1/4

An impressive result. I don't know at which point of the computation the
interpreter switches to an exact representation, but meh, this result is good.

*** DONE Exercise 1.30 Iterative sum
    CLOSED: [2019-09-03 Tue 11:19]

#+begin_src scheme :exports both :results output
  (define (inc x) (+ x 1))
  (define (identity x) x)
  (define (sum term a next b)
    (define (iter a result)
      (if (= a b)
	  (+ a result)
	  (iter (next a) (+ a result))))
    (iter a 0))

  (sum identity 1 inc 10)

#+end_src

#+RESULTS:
: 55

*** DONE Exercise 1.31 Product
    CLOSED: [2019-09-03 Tue 11:59]
**** DONE a. Defining product
     CLOSED: [2019-09-03 Tue 11:56]
 #+begin_src scheme :exports both :results value
   (define (inc x) (+ x 1))
   (define (identity x) x)
   (define (product term a next b)
     (define (iter a result)
       (if (= a b)
	   (* (term a) result)
	   (iter (next a) (* (term a) result))))
     (iter a 1.0))
   (define (factorial x) (product identity 1 inc 6))
   (factorial 6)
   (define (pi precision)
     (define (enumerator index)
       (cond ((odd?  index) (+ index 1.0))
	     ((even? index) (+ index 2.0))
	     (else (error "Error"))))
     (define (denominator index)
       (cond ((odd?  index) (+ index 2.0))
	     ((even? index) (+ index 1.0))
	     (else (error "Error"))))
     (define (fraction index)
       (/ (enumerator index) (denominator index)))
     (* 4.0 (product fraction 1 inc precision)))
     (pi 1280)
 #+end_src

 #+RESULTS:
 : 3.142818162579486

I can say that it converges very-very slowly.
**** DONE b. A recursive version
     CLOSED: [2019-09-03 Tue 11:59]

#+begin_src scheme :exports both :results value
   (define (inc x) (+ x 1))
   (define (identity x) x)
   (define (product term a next b)
     (define (iter a result)
       (if (= a b)
	   (* (term a) result)
	   (* (iter (next a) (term a)) result)))
     (iter a 1.0))
   (define (factorial x) (product identity 1 inc 6))
   (factorial 6)
#+end_src

#+RESULTS:
: 720.0

Doesn't make too much sense to me, but here you are.

*** DONE Exercise 1.32 Accumulator
    CLOSED: [2019-09-03 Tue 12:23]
I will cheat a little bit in this exercise, I will run ~sum~ as an iterative
procedure and ~product~ as a recursive procedure, so at the end I will have
two implementations, not 4, but that should not be too much of a digression.
#+begin_src scheme :exports both :results value :noweb-ref accumulator-common
   (define (inc x) (+ x 1))
   (define (identity x) x)
#+end_src

**** DONE Implement ~sum~ in terms of an iterative accumulator
     CLOSED: [2019-09-03 Tue 12:23]
#+begin_src scheme :exports both :results value
<<accumulator-common>>
  (define (accumulate combiner null-value term a next b)
       (define (iter a result)
	 (if (>= a b)
	     (combiner (term a) result)
	     (combiner (iter (next a) (term a)) result)))
       (iter a null-value))
  (define (sum term a next b)
    (accumulate + 0 term a next b))
  (sum identity 1 inc 10)
#+end_src

#+RESULTS:
: 55

**** DONE Implement ~product~ in terms of a recursive process
     CLOSED: [2019-09-03 Tue 12:22]

#+begin_src scheme :exports both :results value
<<accumulator-common>>
  (define (accumulate combiner null-value term a next b)
       (define (iter a result)
	 (if (= a b)
	     (combiner (term a) result)
	      (iter (next a) (combiner (term a) result) )))
       (iter a null-value))
  (define (product term a next b)
    (accumulate * 1 term a next b))
  (product identity 1 inc 10)

#+end_src

#+RESULTS:
: 3628800

*** DONE Exercise 1.33 filtered-accumulate
    CLOSED: [2019-09-03 Tue 14:36]
**** DONE a. Sum-of-squares-of-primes
    CLOSED: [2019-09-03 Tue 14:24]
#+begin_src scheme :exports both :results value :noweb-ref filtered-accumulate
  <<accumulator-common>>
  <<rabin-prime>>
    (define (filtered-accumulate combiner filter null-value term a next b)
     (define (iter a result)
       (if (= a b)
	   (combiner (if (filter a) (term a) null-value) result)
	   (iter (next a) (combiner (if (filter a) (term a) null-value) result))))
     (iter a null-value))
     #+end_src
     
#+begin_src scheme :exports both :results value 
    <<filtered-accumulate>>
    (define (sum-square-prime a next b)
      (filtered-accumulate + prime? 0 square a next b))
    (sum-square-prime 1 inc 10)
#+end_src

#+RESULTS:
: 88
**** DONE b. Product of positive integers mutually prime with n
     CLOSED: [2019-09-03 Tue 14:36]

#+begin_src scheme :exports both :results output
  <<filtered-accumulate>>
  (define (product-mutually-prime n)
    (define (filter-gcd x)
      (if (= (gcd n x) 1)
	  #t
	  #f))
    (filtered-accumulate * filter-gcd 1 identity 1 inc n))
  (display (product-mutually-prime 10))
#+end_src

#+RESULTS:
: 189

Here I used the ~gcd~ function from the standard library.

*** DONE Exercise 1.34 lambda
    CLOSED: [2019-09-03 Tue 14:44]

#+begin_src scheme :exports both :results value :noweb-ref example-lambda
(define (f g) (g 2))
#+end_src

#+begin_src scheme :exports both :results value
<<example-lambda>>
(define (square x) (* x x))
(f square)
#+end_src

#+RESULTS:
: 4

#+begin_src scheme :exports both :results value
<<example-lambda>>
(f (lambda (z) (* z (+ z 1))))
#+end_src

#+RESULTS:
: 6

#+begin_src scheme :exports both :results value
<<example-lambda>>
(f f)
#+end_src

#+RESULTS:
: "{Exception #19 user \"non procedure application\" (2) #<procedure #f> (\"/usr/lib64/chibi/init-7.scm\" . 230)}"

Well, no wonder. The final combination reduces to ~(2 2)~, which *IS* a
non-procedure application.

*** DONE Exercise 1.35 fixed-point
    CLOSED: [2019-09-03 Tue 21:05]



\(\varphi = \frac{1+\sqrt{5}}{2}\)
\(x\mapsto 1+\frac{1}{x}\)
Let's substitute:
\( \frac{1+\sqrt{5}}{2} &=& 1+ \frac{2}{1+\sqrt{5}} \)
\( (1+\sqrt{5})^2 = 2(1+\sqrt{5})+ 4\)
\( 1 + 2 \sqrt{5} + 5 = 2 + 2 \sqrt{5} + 4 \)
\(6 = 6\)


#+begin_src scheme :exports both :results value :noweb-ref fixed-point-silent
  (define tolerance 0.00001)
  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2))
	 tolerance))
    (define (try guess)
      (let ((next (f guess)))
	(if (close-enough? guess next)
	    next
	    (try next))))
  (try first-guess))
#+end_src

#+begin_src scheme :exports both :results value
<<fixed-point-silent>>
(fixed-point cos 1.0)
#+end_src

#+RESULTS:
: 0.7390822985224024

#+begin_src scheme :exports both :results value
  <<fixed-point-silent>>
  (define (golden-transform x)
    (+ 1 (/ 1 x)))
  (fixed-point golden-transform 1.0)

#+end_src

#+RESULTS:
: 1.6180327868852458

#+begin_src scheme :exports both :results value
(/ (+ 1 (sqrt 5)) 2)
#+end_src

#+RESULTS:
: 1.618033988749895

The difference is not too big.

*** DONE Exercise 1.36 fixed-point-with-dampening
    CLOSED: [2019-09-03 Tue 21:55]

#+begin_src scheme :exports both :results value :noweb-ref fixed-point-verbose
  (define tolerance 0.00001)
  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (display "Guesses: ")
      (display v1)
      (display " ")
      (display v2)
      (newline)
      (< (abs (- v1 v2))
	 tolerance))
    (define (try guess)
      (let ((next (f guess)))
	(if (close-enough? guess next)
	    next
	    (try next))))
  (try first-guess))
#+end_src

To find a solution to \(x^x=1000\), let us rearrange: \( x = \log_x1000 =
\frac{\log 1000}{\log x}\).

#+begin_src scheme :exports both :results value :noweb-ref log1000
(define (log1000/logx x)
  (/ (log 1000) (log x)))
#+end_src

#+begin_src scheme :exports both :results output
<<fixed-point-verbose>>
<<log1000>>
(display (fixed-point log1000/logx 5))
#+end_src

#+RESULTS:
#+begin_example
Guesses: 5 4.29202967422018
Guesses: 4.29202967422018 4.741863119908242
Guesses: 4.741863119908242 4.438204569837609
Guesses: 4.438204569837609 4.635299887107611
Guesses: 4.635299887107611 4.50397811613643
Guesses: 4.50397811613643 4.589989462723705
Guesses: 4.589989462723705 4.53301150767844
Guesses: 4.53301150767844 4.570475672855484
Guesses: 4.570475672855484 4.545720389670642
Guesses: 4.545720389670642 4.562024936588171
Guesses: 4.562024936588171 4.551263234080531
Guesses: 4.551263234080531 4.55835638768598
Guesses: 4.55835638768598 4.553676852183342
Guesses: 4.553676852183342 4.55676216434628
Guesses: 4.55676216434628 4.554727130670954
Guesses: 4.554727130670954 4.556069054770006
Guesses: 4.556069054770006 4.555184018843625
Guesses: 4.555184018843625 4.5557676565438205
Guesses: 4.5557676565438205 4.555382746639082
Guesses: 4.555382746639082 4.55563658243586
Guesses: 4.55563658243586 4.555469180245326
Guesses: 4.555469180245326 4.555579577901
Guesses: 4.555579577901 4.5555067722873686
Guesses: 4.5555067722873686 4.5555547860484085
Guesses: 4.5555547860484085 4.555523121789556
Guesses: 4.555523121789556 4.555544003742869
Guesses: 4.555544003742869 4.555530232469306
Guesses: 4.555530232469306 4.555539314360711
4.555539314360711
#+end_example

#+begin_src scheme :exports both :results value :noweb-ref fixed-point-verbose-with-dampening
  (define tolerance 0.00001)
  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (display "Guesses: ")
      (display v1)
      (display " ")
      (display v2)
      (newline)
      (< (abs (- v1 v2))
	 tolerance))
    (define (try guess)
      (let ((next (f guess)))
	(if (close-enough? guess next)
	    next
	    (try (/ (+ guess next) 2)))))
  (try first-guess))
#+end_src

#+begin_src scheme :exports both :results output
<<fixed-point-verbose-with-dampening>>
<<log1000>>
(display (fixed-point log1000/logx 5))
#+end_src

#+RESULTS:
: Guesses: 5 4.29202967422018
: Guesses: 4.64601483711009 4.49720773504196
: Guesses: 4.571611286076025 4.544977348996107
: Guesses: 4.558294317536066 4.553717728226165
: Guesses: 4.556006022881116 4.555225576581478
: Guesses: 4.555615799731297 4.555482885419889
: Guesses: 4.555549342575593 4.555526711628406
: Guesses: 4.555538027102 4.555534173941779
: 4.555534173941779

Well, the amount of steps is visibly smaller. Works.

*** DONE Exercise 1.37 cont-frac
    CLOSED: [2019-09-04 Wed 10:34]
**** DONE a. recursive
     CLOSED: [2019-09-04 Wed 11:35]
     #+begin_src scheme :exports both :results value :noweb-ref cont-frac-recursive
  (define (cont-frac n d k)
    (define (next step)
      (if (< step k)
	  (/ (n step) (+ (d step) (next (+ step 1))) )
	  0))
    (next 1))
     #+end_src
    
     #+begin_src scheme :exports both :results value
     <<cont-frac-recursive>>
         (/ 1 (cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 14))
     #+end_src

     #+RESULTS:
     : 1.6180257510729614

Abelson and Sussman tell us to estimate \(k\) needed to approximate the \(\varphi\) to a required
degree (0.0001). I didn't manage to derive the formula myself, however, I can
give a link to the book where this proof is given:

Khinchin, Continued Fractions (1935), chapter 2, section 7, gives an upper
bound on the speed of convergence as \(\frac{1}{k^2}\). Therefore we should
expect \(k \approx \sqrt{1000} \approx 33\). This holds for an arbitrary convergent
continued fraction. In our case, however, when \(N_k=D_k=1\), the constant in
the rate is also known as \(\sqrt{5}\), so the equation we need to solve is
in fact \(k^2 \sqrt{5} = 1000\), and in practice that is
\(\sqrt{\frac{1000}{2.23}} = 21\). How exactly we managed to do it in 14
steps, I don't know.

**** DONE b. iterative
     CLOSED: [2019-09-04 Wed 11:35]

We just start computing from the end.

#+begin_src scheme :exports both :results value :noweb-ref cont-frac
  (define (cont-frac n d k)
    (define (next step accumulator)
      (if (> step 0)
	  (next (- step 1) (/ (n step) (+ (d step) accumulator)))
	  accumulator))
    (next k 0))
#+end_src

#+RESULTS:
: #<undef>
  
#+begin_src scheme :exports both :results value
<<cont-frac>>
  (/ 1 (cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 14))
#+end_src

#+RESULTS:
: 1.6180371352785146


Remark: this exercise took me 7 hours.

*** DONE Exercise 1.38 euler constant
    CLOSED: [2019-09-04 Wed 11:35]

The only difficulty with this exercise is to derive the formula for the
second lambda.

#+begin_src scheme :exports both :results value
  <<cont-frac>>
  (+ 2 
     (cont-frac 
      (lambda (i) 1.0)
      (lambda (i) (if (= (remainder i 3) 2) (+ (* (/ i 3) 2) 2) 1))
      14 ))
#+end_src

#+RESULTS:
: 2.794771662537

*** DONE Exercise 1.39 tan-cf
    CLOSED: [2019-09-04 Wed 12:11]
    :LOGBOOK:

    :END:
#+begin_src scheme :exports both :results output
  <<cont-frac>>
  (define (tan-cf x k)
    (cont-frac
     (lambda (i)
       (if (= i 1) x (- (* x x))))
     (lambda (i)
       (- (* 2 i) 1))
     k))
  (display (tan 0.1))
  (newline)
  (display(tan-cf 0.1 300))
#+end_src

#+RESULTS:
: 0.10033467208545055
: 0.10033467208545055

*** DONE Exercise 1.40 newtons-method
    CLOSED: [2019-09-04 Wed 17:06]
    :LOGBOOK:
    CLOCK: [2019-09-04 Wed 17:21]--[2019-09-04 Wed 17:21] =>  0:00
    :END:

#+begin_src scheme :exports both :results value :noweb-ref deriv
  (define (deriv g)
    (lambda (x) (/ (- (g (+ x dx)) (g x)) dx)))
  (define dx 0.00001)
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref newtons-method
  (define (newton-transform g)
    (lambda (x) (- x (/ (g x) ((deriv g) x)))))
  (define (newtons-method g guess)
    (fixed-point (newton-transform g) guess))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref square
(define (square x)
 (* x x))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref cube
(define (cube x)
  (* x x x))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref cubic
  (define (cubic a b c) 
    (lambda (x) (+ (cube x) (* a (square x)) (* b x) c)))x
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref inc
(define (inc x) (+ x 1))
#+end_src

#+begin_src scheme :exports both :results output
<<fixed-point-silent>>
<<cubic>>
<<cube>>
<<square>>
<<deriv>>
<<newtons-method>>

(display (newtons-method (cubic 5 3 1) 1))
#+end_src

#+RESULTS:
: -4.365230013403046

Theoretically, a cubic may have up to 3 roots, but to find all of them we
would need to try over all possible ones.

*** DONE Exercise 1.41 double-double
    CLOSED: [2019-09-04 Wed 17:21]

#+begin_src scheme :exports both :results value :noweb-ref double-function
(define (double fun)
  (lambda (x) (fun (fun x))))
(define (inc x)
  (+ x 1))
#+end_src

#+begin_src scheme :exports both :results value
<<double-function>>
(((double double) inc) 5)
#+end_src

#+RESULTS:
: 9

#+begin_src scheme :exports both :results value
<<double-function>>
(((double (double double)) inc) 5)
#+end_src

#+RESULTS:
: 21

\(21 = 5 + 16\)
Double really works as a power of a function. \( 2 \Rightarrow 2^2 \Rightarrow2^{2^2} =
\mbox{inc}^{16} 5 \)
*** DONE Exercise 1.42 compose
    CLOSED: [2019-09-04 Wed 17:27]
#+begin_src scheme :exports both :results value :noweb-ref compose
(define (compose f g)
  (lambda (x) (f (g x))))
#+end_src

#+begin_src scheme :exports both :results value
<<compose>>
<<square>>
<<inc>>
((compose square inc) 6)
#+end_src

#+RESULTS:
: 49

*** DONE Exercise 1.43 repeated
    CLOSED: [2019-09-04 Wed 17:54]
#+begin_src scheme :exports both :results value :noweb-ref repeated

  (define (repeated fun n)
    (define (repeat-it n fun combinator)
      (if (= n 1)
	  combinator
	  (repeat-it  (- n 1) fun (lambda (x) (fun (combinator x))))))
      (repeat-it n fun fun))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results value
<<repeated>>

<<square>>

((repeated square 2) 5)
#+end_src

#+RESULTS:
: 625

Hm. Managed to do it without the ~compose~ form.

*** DONE Exercise 1.44 smoothing
    CLOSED: [2019-09-04 Wed 20:17]

#+begin_src scheme :exports both :results value :noweb-ref smooth
  (define dx 0.1)
  (define (smooth f)
    (lambda (x) (/ (+ (f (- x dx))
		 (f x)
		 (f (+ x dx)))
	      3)))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref n-smoothed
  (define (n-smoothed fun n)
    ((repeated smooth n) fun))
#+end_src

#+begin_src scheme :exports both :results output
<<smooth>>
<<n-smoothed>>
<<repeated>>
<<cube>>
(define (ex144-answer x)
  ((n-smoothed cube 3) x))
(display (ex144-answer 10))
#+end_src

#+RESULTS:
: 1000.6

Looks like what we wanted.

*** DONE Exercise 1.45 nth-root
    CLOSED: [2019-09-04 Wed 21:37]

#+begin_src scheme :exports both :results value :noweb-ref average
(define (average x y)
   (/ (+ x y) 2))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref average-damp
(define (average-damp f)
  (lambda (x) (average x (f x))))
#+end_src


#+begin_src scheme :exports both :results value :noweb-ref n-average-damp
(define (n-average-damped f n)
   ((repeated average-damp n) f))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref better-fixed-point
  (define tolerance 0.0001)
  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2))
	 tolerance))
    (define (try guess)
       (let ((next (f guess)))
	(if (close-enough? guess next)
	    next
	    (try next))))
  (try first-guess))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results value :noweb-ref root-n-x
  (define (root n x initial-guess)
    (fixed-point
     (n-average-damped
      (lambda (y) (/ x (pow y (- n 1))))
      n) 
      initial-guess))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref pow-recursive
(define (pow x n)
 (if (= n 1)
   x
   (* x (pow x (- n 1)))))
#+end_src

#+begin_src scheme :exports both :results output
<<average>>
<<average-damp>>
<<repeated>>
<<better-fixed-point>>
<<n-average-damp>>
<<pow-recursive>>
<<root-n-x>>
(display (root 4 4 3.0))

#+end_src

#+RESULTS:
: 1.4144444873765194

The true answer would require to actually estimate the dampening factor, but
we know that *n* is enough, and I am lazy.

*** DONE Exercise 1.46 iterative-improve
    CLOSED: [2019-09-04 Wed 22:25]

#+begin_src scheme :exports both :results value :noweb-ref iterative-improve
  (define (iterative-improve good-enough? improve)
    (define (improver guess)
      (if (good-enough? guess)
	  guess
	  (improver (improve guess))))
  improver)
#+end_src

**** DONE a. sqrt
     CLOSED: [2019-09-04 Wed 22:24]

#+begin_src scheme :exports both :results value
    <<square>>
    <<iterative-improve>>
    (define (ex1.46sqrt x)
      (let (
	    (square-improver
	     (iterative-improve
	      (lambda (y) (< (abs (- (square y) x )) 0.01))
	      (lambda (y) (/ (+ y (/ x y)) 2)))
	     )
	    )
	(square-improver 1)))
    (ex1.46sqrt 2.0)
#+end_src

#+RESULTS:
: 1.4166666666666665

**** DONE b. fixed-point
     CLOSED: [2019-09-04 Wed 22:25]

#+begin_src scheme :exports both :results value
    <<square>>
    <<iterative-improve>>
    (define (fixpoint f)
      (let (
	    (fixpoint-improver
	     (iterative-improve
	      (lambda (y) (< (abs (- (f y) y )) 0.01))
	      (lambda (y) (/ (+ y (f y)) 2)))
	     )
	    )
	(fixpoint-improver 1.0)))
    (fixpoint (lambda (x) (+ 1 (/ 1 x))))
#+end_src

#+RESULTS:
: 1.6147785476652068



I have made it. At [2019-09-04 Wed 22:25] I still haven't implemented all the
pictures, but I already can say that I have solved _all_ problems of the
first chapter of SICP. Some macros are wrong, I need to revise them, but that
will be done on the second pass. (Yes, there will be a second [or, rather, third] pass!)

** TODO Chapter 2: Building abstractions with Data [47/102]
*** DONE Exercise 2.1 make-rat
    CLOSED: [2019-09-06 Fri 13:00]


In this exercise I will also define the functions presented by Abelson
and Sussman for general reference.

#+begin_src scheme :exports both :results value :noweb-ref make-rat
  (define (make-rat numerator denominator)
    (let* ((my-gcd (gcd numerator denominator))
	   (numerator (/ numerator my-gcd))
	   (denominator (/ denominator my-gcd))
	   (sign (/ (abs denominator) denominator)))
      (cons (* numerator sign) (* denominator sign))))
  (define (numer x)
    (car x))

  (define (denom x)
    (cdr x))

#+end_src

#+RESULTS:
: unfinished

#+begin_src scheme :exports both :results value 2.2.1-basic-rat
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
		 (* (numer y) (denom x)))
	      (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
		 (* (numer y) (denom x)))
	      (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
	      (* (denom x) (denom y))))

  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
	      (* (denom x) (numer y))))
  (define (equal-rat? x y)
    (= (* (numer x) (denom y))
       (* (numer y) (denom x))))

#+end_src

#+begin_src scheme :exports both :results value :noweb-ref print-rat
  (define (print-rat x)
    (newline)
    (display (numer x))
    (display "/")
    (display (denom x)))
#+end_src

#+begin_src scheme :exports both :results output
<<print-rat>>
<<2.2.1-basic-rat>>
<<make-rat>>
(define one-half (make-rat -65 -5))
(print-rat one-half)
#+end_src

#+RESULTS:
: 
: 13/1

*** TODO Figure 2.1

This figure contains a data-abstraction diagram. I don't know how to
make them yet.

*** DONE Exercise 2.2 make-segment
    CLOSED: [2019-09-06 Fri 13:34]

#+begin_src scheme :exports both :results value :noweb-ref make-segment
  (define (make-segment x1 y1 x2 y2)
    (cons (make-point x1 y1)  (make-point x2 y2)))

  (define (start-segment segment)
    (car segment))

  (define (end-segment segment)
    (cdr segment))

  (define (make-point x y)
    (cons x y))

  (define (x-point point)
    (car point))

  (define (y-point point)
    (cdr point))

  (define (midpoint-segment segment)
    (make-point (/ (+ (x-point (start-segment segment))
		   (x-point (end-segment   segment))) 2)
		(/ (+ (y-point (start-segment segment))
		   (y-point (end-segment   segment))) 2)))

#+end_src

#+begin_src scheme :exports both :results value :noweb-ref print-point
  (define (print-point p)
    (newline)
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")"))
#+end_src

#+begin_src scheme :exports both :results output
<<print-point>>
<<make-segment>>
(print-point (midpoint-segment (make-segment 1 0 0 1)))
#+end_src

#+RESULTS:
: 
: (1/2,1/2)

The task looks pretty straightforward. Just make a cons of points.

*** DONE Exercise 2.3 make-rectangle
    CLOSED: [2019-09-08 Sun 17:58]

I will choose the following two representations:
 - List of points from top left to the right.
 - Two lists of coordinates, x and y.

I will not be using segments from Exercise 2.2, because then I would
have to care about the consistency of the first and the last point in
the four segments.

#+begin_src scheme :exports both :results output :noweb-ref rectangle
  (define (area rectangle)
    (* (get-height rectangle) (get-width rectangle)))
  (define (perimeter rectangle)
    (* 2 (+ (get-height rectangle) (get-width rectangle))))
  (define (get-height rectangle)
    (dist (nth-point 1 rectangle) (nth-point 2 rectangle)))
  (define (get-width rectangle)
    (dist (nth-point 2 rectangle) (nth-point 3 rectangle)))
  (define (dist point1 point2)
    (+ (square (- (x-point point1) (x-point point2))) (square (- (y-point point1) (y-point point2)))))

#+end_src

#+begin_src scheme :exports both :results output :noweb-ref rectangle-point-list
  (define (make-rectangle x1 y1 x2 y2 x3 y3 x4 y4)   
    (list (make-point x1 y1)
	  (make-point x2 y2)
	  (make-point x3 y3)
	  (make-point x4 y4)))
  (define (nth-point n rectangle)
    (if (= n 1)
	(car rectangle)
	(nth-point (- n 1) (cdr rectangle))))
#+end_src


#+begin_src scheme :exports both :results output :noweb-ref rectangle-two-lists
  (define (make-rectangle x1 y1 x2 y2 x3 y3 x4 y4)   
    (cons (list x1 x2 x3 x4) (list y1 y2 y3 y4)))

  (define (nth-point n rectangle)
    (if (= n 1)
	(make-point (caar rectangle) (cadr rectangle))
	(nth-point (- n 1) (cons (cdar rectangle) (cddr rectangle)))))
#+end_src

#+begin_src scheme :exports both :results output
  <<rectangle>>
  <<rectangle-point-list>>
  <<make-segment>>
  (let ((test1 (make-rectangle 0 0 0 1 1 1 1 0)))
    (display "Area=")
    (display (area test1))
    (newline)
    (display "Perimeter=")
    (display (perimeter test1))
    (newline))

#+end_src

#+RESULTS:
: Area=1
: Perimeter=4


#+begin_src scheme :exports both :results output
  <<rectangle>>
  <<rectangle-two-lists>>
  <<make-segment>>
  (let ((test1 (make-rectangle 0 0 0 1 1 1 1 0)))
    (display "Area=")
    (display (area test1))
    (newline)
    (display "Perimeter=")
    (display (perimeter test1))
    (newline))

#+end_src

#+RESULTS:
: Area=1
: Perimeter=4

This is not very efficient, but two implementations were requested --
and they were delivered.

*** DONE Exercise 2.4 cons-lambda
    CLOSED: [2019-09-08 Sun 18:08]

#+begin_src scheme :exports both :results output
  (define (cons x y)
    (lambda (m) (m x y)))
  (define (car z)
    (z (lambda (p q) p)))
  (define (cdr z)
    (z (lambda (p q) q)))

  (display (car (cons 'a 'b)))
  (newline)
  (display (cdr (cons 'a 'b)))
  (newline)
#+end_src

#+RESULTS:
: a
: b

*** DONE Exercise 2.5 cons-pow
    CLOSED: [2019-09-08 Sun 19:07]
    0:00:00 -- 0:56:02 

#+begin_src scheme :exports both :results value :noweb-ref ex2.5cons
(define (cons a b)
  (* (expt 2 a) (expt 3 b)))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results value :noweb-ref ex2.5car
(define (car number)
  (log (gcd (expt 2.0 (floor (log number 2))) number) 2))
(define (cdr number)
  (log (gcd (expt 3.0 (floor (log number 2))) number) 3))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results value
<<ex2.5car>>
<<ex2.5cons>>

(list (car (cons 14 4)) (cdr (cons 14 4)))

#+end_src

#+RESULTS:
| 14.0 | 4.0 |

*** DONE Exercise 2.6 Church Numerals
    CLOSED: [2019-09-08 Sun 19:41]
0:00:00 -- 0:23:58 

In the worst case this exercise can be copied literally right from the
Wikipedia article: https://en.wikipedia.org/wiki/Church_encoding
#+begin_src scheme :exports both :results value :noweb-ref church-zero
  (define identity (lambda (x) x))
  (define zero (lambda (f) identity))
  (define (add-1 n)
    (lambda (f) (lambda (x) (f ((n f) x)))))
#+end_src

#+begin_src scheme :exports both :results output
  <<church-zero>>
  (define one (lambda (f) (lambda (x) (f x))))
  (define two (lambda (f) (lambda (x) (f (f x)))))
  (define (plus a b)
    (lambda (f) (lambda (x) ((a f) ((b f) x)))))

#+end_src

#+RESULTS:

*** DONE Exercise 2.7 make-interval
    CLOSED: [2019-09-08 Sun 20:09]
0:00:00 -- 0:20:09 

#+begin_src scheme :exports both :results value :noweb-ref make-interval
  (define (make-interval a b)
    (cons a b))
  (define (upper-bound interval)
    (max (car interval) (cdr interval)))
  (define (lower-bound interval)
    (min (car interval) (cdr interval)))
#+end_src


#+begin_src scheme :exports both :results value :noweb-ref interval-common
  (define (add-interval x y)
    (make-interval (+ (lower-bound x) (lower-bound y))
		   (+ (upper-bound x) (upper-bound y))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref mul-interval-simple
  (define (mul-interval x y)
    (let ((p1 (* (lower-bound x) (lower-bound y)))
	  (p2 (* (lower-bound x) (upper-bound y)))
	  (p3 (* (upper-bound x) (lower-bound y)))
	  (p4 (* (upper-bound x) (upper-bound y))))
      (make-interval (min p1 p2 p3 p4)
		     (max p1 p2 p3 p4))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref div-interval-lame
  (define (div-interval x y)
    (mul-interval
     x
     (make-interval (/ 1.0 (upper-bound y))
		    (/ 1.0 (lower-bound y)))))
#+end_src

#+begin_src scheme :exports both :results output
<<make-interval>>
<<interval-common>>
<<div-interval-lame>>
<<mul-interval-simple>>
(show #t " " (add-interval (make-interval 5 5.6) (make-interval 6 6.1)) "\n")
(show #t " " (mul-interval (make-interval -0.1 0.1) (make-interval 100 110)) "\n")
(show #t " " (div-interval (make-interval -0.1 0.1) (make-interval 100 110)))
#+end_src

#+RESULTS:
:  (11.0 . 11.7)
:  (-11.0 . 11.0)
:  (-0.001 . 0.001)

*** DONE Exercise 2.8 sub-interval
    CLOSED: [2019-09-08 Sun 23:07]

#+begin_src scheme :exports both :results value :noweb-ref sub-interval
  (define (sub-interval a b)
    (make-interval (- (upper-bound a) (lower-bound b))
		   (- (lower-bound a) (upper-bound b))))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results output
<<make-interval>>
<<sub-interval>>
(show #t " " (sub-interval (make-interval 100 -100) (make-interval -1 101)))
#+end_src

#+RESULTS:
:  (101 . -201)

*** DONE Exercise 2.9 interval-width
    CLOSED: [2019-09-08 Sun 23:15]
 0:06:00
#+begin_src scheme :exports both :results value
  (define (width interval)
    (abs (- (upper-bound interval) (lower-bound interval))))
#+end_src

\( a + \Delta a + b + \Delta b = (a+b) + (\Delta a + \Delta b)\)
\((a+\Delta a)\cdot (b+\Delta b) = (a\cdot b) + (a\Delta b + b\Delta a + \Delta a \Delta b)\)

The formulae above should relatively convincingly explain why the
width is not the function of the initial widths only in the case of
multiplication. 

*** DONE Exercise 2.10 div-interval-better
    CLOSED: [2019-09-08 Sun 23:30]
0:14:50  
The initial Alyssa's construction is:
#+begin_src scheme :exports both :results value :noweb-ref div-interval-better
  (define (div-interval x y)
    (when (and (< (lower-bound y) 0) (> (upper-bound y) 0))
      (error "Division by zero." (list x y)))
      (mul-interval
       x
       (make-interval (/ 1.0 (upper-bound y))
		      (/ 1.0 (lower-bound y)))))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results output
<<div-interval-better>>
<<make-interval>>
(display (div-interval (make-interval 1 2) (make-interval -1 1)))
#+end_src

#+RESULTS:
: '(Exception #19 user "Division by zero." (((1 . 2) (-1 . 1))) #f #f)

*** DONE Exercise 2.11 mul-interval-nine-cases
    CLOSED: [2019-09-09 Mon 00:45]
1:06:58 

| number | lower x | upper x | lower y | upper y |
|--------+---------+---------+---------+---------|
|      2 | +       | +       | +       | +       |
|      2 | +       | +       | -       | +       |
|      2 | +       | +       | -       | -       |
|      2 | -       | +       | +       | +       |
|      3 | -       | +       | -       | +       |
|      2 | -       | +       | -       | -       |
|      2 | -       | -       | +       | +       |
|      2 | -       | -       | -       | +       |
|      2 | -       | -       | -       | -       |


#+begin_src scheme :exports both :results value :noweb-ref mul-interval
  (define (mul-interval x y)
    (let ((x1 (lower-bound x))
	  (x2 (upper-bound x))
	  (y1 (lower-bound y))
	  (y2 (upper-bound y)))
      (cond ((and (> x1 0) (> x2 0) (> y1 0) (> y2 0)) (make-interval (* x1 y1) (* x2 y2)))
	    ((and (> x1 0) (> x2 0) (< y1 0) (> y2 0)) (make-interval (* x2 y1) (* x2 y2)))
	    ((and (> x1 0) (> x2 0) (< y1 0) (< y2 0)) (make-interval (* x2 y1) (* x2 y1)))
	    ((and (< x1 0) (> x2 0) (> y1 0) (> y2 0)) (make-interval (* x1 y2) (* x2 y2)))
	    ((and (< x1 0) (> x2 0) (< y1 0) (> y2 0))
	     (let ((p1 (* (lower-bound x) (lower-bound y)))
		   (p2 (* (lower-bound x) (upper-bound y)))
		   (p3 (* (upper-bound x) (lower-bound y)))
		   (p4 (* (upper-bound x) (upper-bound y))))
	       (make-interval (min p1 p2 p3 p4)
			      (max p1 p2 p3 p4))))
	    ((and (< x1 0) (> x2 0) (< y1 0) (< y2 0)) (make-interval (* x2 y2) (* x2 y1)))
	    ((and (< x1 0) (< x2 0) (> y1 0) (> y2 0)) (make-interval (* x1 y2) (* x2 y1)))
	    ((and (< x1 0) (< x2 0) (< y1 0) (> y2 0)) (make-interval (* x2 y2) (* x1 y1)))
	    ((and (< x1 0) (< x2 0) (< y1 0) (< y2 0)) (make-interval (* x2 y2) (* x1 y1))))))
#+end_src

I don't even want to test it. 

#+begin_src scheme :exports both :results output
<<mul-interval>>
<<make-interval>>
(show #t " " (mul-interval (make-interval -2 2) (make-interval -5 6)))

#+end_src

#+RESULTS:
:  (-12 . 12)

Marvelous.

*** DONE Exercise 2.12 make-center-percent
    CLOSED: [2019-09-09 Mon 10:11]

#+begin_src scheme :exports both :results value :noweb-ref make-center-width
  (define (make-center-width c w)
    (make-interval (- c w) (+ c w)))
  (define (center i)
    (/ (+ (lower-bound i) (upper-bound i)) 2))
  (define (width i)
    (/ (- (upper-bound i) (lower-bound i)) 2))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref make-center-precision
  (define (make-center-percent center percent)
    (let ((delta (* center (/ percent 100))))
      (make-interval  (+ center delta) (- center delta))))
  (define (relative-precision interval)
    (let* ((center (/ (+ (lower-bound interval) (upper-bound interval))
		     2))
	   (percent (/ (abs (- (lower-bound interval) (upper-bound interval))) 2)))
      (/ percent center)))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results output
<<make-center-width>>
<<make-center-precision>>
<<make-interval>>
  (let ((test-interval (make-center-percent 100 2)))
    (show #t " " test-interval "\n")
    (show #t " " (center test-interval) "\n")
    (show #t " " (relative-precision test-interval)) "\n")
#+end_src

#+RESULTS:
:  (102 . 98)
:  100
:  1/50

*** DONE Exercise 2.13 formula for tolerance
    CLOSED: [2019-09-09 Mon 10:16]

\((a+\Delta a)\cdot (b+\Delta b) = (a\cdot b) + (a\Delta b + b\Delta a + \Delta a \Delta b)\)
\(\frac{(a+\Delta a)\cdot (b+\Delta b)}{a\cdot b} = \frac{(a\cdot b)}{a\cdot b} + \frac{(a\Delta b +
b\Delta a + \Delta a \Delta b)}{a \cdot b} \approx 1 + \frac{\Delta a}{a} + \frac{\Delta b}{b}\) 

*** DONE Exercise 2.14 parallel-resistors
    CLOSED: [2019-09-09 Mon 11:24]
0:37:00 +  0:31:07 = 1:06:07
#+begin_src scheme :exports both :results output
  <<make-interval>>
  <<div-interval-better>>
  <<mul-interval>>
  <<interval-common>>
  (define (par1 r1 r2)
    (div-interval (mul-interval r1 r2)
		  (add-interval r1 r2)))
  (define (par2 r1 r2)
    (let ((one (make-interval 1 1)))
      (div-interval
       one (add-interval (div-interval one r1)
			 (div-interval one r2)))))

  (show #t " " (par1 (make-interval 4.9 5.1) (make-interval 6.9 7.1)) "\n")
  (show #t " " (par2 (make-interval 4.9 5.1) (make-interval 6.9 7.1)) "\n")
#+end_src

#+RESULTS:
:  (2.7713114754098367 . 3.0686440677966096)
:  (2.8652542372881356 . 2.968032786885246)

It is worth noticing that ~par2~ uses more operations than
~par1~. Even if the title problem in the exercise wasn't present, we
would still get a less precise result.

#+begin_src scheme :exports both :results output
    <<make-interval>>
    <<mul-interval>>
    <<div-interval-better>>
    (let ((one (make-interval 1.0 1.0))
	  (i2 (make-interval 4.9 5.1))
	  (i3 (make-interval 6.9 7.1)))
      (show #t " " (div-interval one one) "\n")
      (show #t " " (div-interval one i2) "\n")
      (show #t " " (div-interval i2 i2) "\n")
      (show #t " " (div-interval i2 i3) "\n")
      (show #t " " (mul-interval  i2 (div-interval one i2)) "\n"))

#+end_src

#+RESULTS:
:  (1.0 . 1.0)
:  (0.19607843137254904 . 0.2040816326530612)
:  (0.9607843137254903 . 1.040816326530612)
:  (0.6901408450704226 . 0.7391304347826086)
:  (0.9607843137254903 . 1.040816326530612)

The idea here is, in some sense, the non-independence of the random
variables *i2* and *i2*. Regardless of the precision of *i2*, we
_know_ that \(\frac{i_2}{i_2} = 1\). 

The center-percent form I implemented is slightly different from the
one Abelson expected, I guess, but still,
\(\frac{1}{1} \approx 1 \pm 2\Delta\). This is too much.

*** DONE Exercise 2.15 better-intervals
    CLOSED: [2019-09-09 Mon 11:34]

I already answered this question in the Exercise 2.14. The problem is
of the potential independence (which may or may not be the case) of
*a* and *b*, but complete dependence of *a* on *a*, which is \(1\)
regardless of whether *a* is even well-defined.

*** DONE Exercise 2.16 interval-arithmetic
    CLOSED: [2019-09-09 Mon 11:37]

To solve this problem in the general case, on would have to build a
probability distribution of the function on the variables, and use
something of a probabilistic reduction on every step. I am not aware
of such systems if they even exist. It would be indispensable for
quantum modelling though.

Hypothetically, if such systems existed, they would do something like
build a distribution on every step of the computation and track every
quantity occurrence in every distribution.


*** TODO Figure 2.2 Box-and-pointer representation of ~(cons 1 2)~. :graphviz:
https://gitlab.com/graphviz/graphviz/issues/1588
https://gitlab.com/graphviz/graphviz/issues/1589
10:00:00
[2019-09-10 Tue 10:24] I managed to make pgf work with org-mode, but
didn't manage to  make a picture yet. So far this problem happened to
generalize to the case of drawing arbitrary vector graphics. Graphviz
turned out to be less fit for this problem.

#+begin_src plantuml :exports both :file figure-2-2.png
  @startdot
  digraph sicp2_2 {
    node [shape=none];
    source [label=""];
    
    node [shape=plaintext, style="rounded"];
    struct0 [label=<<table BORDER="0" CELLBORDER="1" CELLSPACING="0">
             <tr>
                 <td width="29" height="35" sides="ltrb" port="f1"></td>
                 <td width="29" height="35" sides="lrtb" port="f2"></td>
             </tr>
             </table>>, style="rounded,filled", fillcolor="gray"];
    rankdir=LR;
    node [shape=record, style="rounded"];
    struct2 [label="<f2> 2"];
    struct1 [label="<f1> 1"];
    edge [arrowhead=normal,arrowtail=dot];    
    struct0:f2:c -> struct2:f0 [tailclip=false];
    struct0:f1:c -> struct1:f0 [tailclip=false];
    source -> struct0;
  }

  @enddot
#+end_src 

#+RESULTS:
[[file:figure-2-2.png]]


#+name: tikztest
#+header: :imagemagick yes :iminoptions -density 600 :imoutoptions -geometry 200
#+header: :fit yes :headers '("\\usepackage{tikz}")
#+header: :buffer on
#+begin_src latex :results raw file :exports code :file test.png
  \usetikzlibrary{trees}
  \begin{tikzpicture}[color=white]
    \node [circle, draw, fill=red!70] at (0,0) {1}
      child { 
             node [circle, draw, fill=blue!70] {2}
             child { 
                   node [circle, draw, fill=green!70]  {3} }
             child { 
                   node [circle, draw, fill=yellow!70] {4} }
            };
  \end{tikzpicture}
#+end_src

#+RESULTS: tikztest
[[file:test.png]]

#+begin_src plantuml :exports both :file ditaa.png
@startditaa
               +---+---+     +---+---+         +---+---+     +---+
          ---->| * | *-+---->| * | * |    ---->| * | *------>| 4 |
               +-|-+---+     +-|-+-|-+         +-|-+---+     +---+
                 |             |   |             |
                 V             V   V             V
             +---+---+      +---+ +---+      +---+---+     +---+---+
             | * | * |      | 3 | | 4 |      | * | *-+---->| * | * |
             +-|-+-|-+      +---+ +---+      +-|-+---+     +-|-+-|-+
               |   |                           |             |   |
               V   V                           V             V   V
            +---+ +---+                      +---+        +---+ +---+
            | 1 | | 2 |                      | 1 |        | 2 | | 3 |
            +---+ +---+                      +---+        +---+ +---+

@endditaa
#+end_src 

#+RESULTS:
[[file:ditaa.png]]


*** DONE Exercise 2.17 last-pair
    CLOSED: [2019-09-10 Tue 10:48]
0:20:51 

#+begin_src scheme :exports both :results value :noweb-ref last-pair
  (define (last-pair lst)
    (list-tail lst (- (length lst) 1)))
#+end_src

#+begin_src scheme :exports both :results output
<<last-pair>>
(let ((tmp (last-pair '(1 1))))
(show #t " " (car tmp) " " (cdr tmp)))
#+end_src

#+RESULTS:
:  1 ()

*** DONE Exercise 2.18 reverse
    CLOSED: [2019-09-10 Tue 10:57]
0:03:56 
#+begin_src scheme :exports both :results value :noweb-ref reverse-list
  (define (reverse lst)
    (define (lst-iter x y)
       (if (null? y)
	   x
	   (lst-iter (cons (car y) x) (cdr y))))
    (lst-iter '() lst))
#+end_src

#+begin_src scheme :exports both :results output
<<reverse-list>>
(show #t " " (reverse '(1 2 3)))
#+end_src

#+RESULTS:
:  (3 2 1)

*** DONE Exercise 2.19 coin-values                                   :unsure:
    CLOSED: [2019-09-10 Tue 11:27]

#+begin_src scheme :exports both :results value :noweb-ref coin-values
  (define us-coins (list 50 25 10 5 1))
  (define uk-coins (list 100 50 20 10 5 2 1 0.5))
  (define uk-coins-damaged (list 0.50 100 50 20 10 5 2 1))

  (define (cc amount coin-values)
    (cond ((= amount 0) 1)
	  ((or (< amount 0) (no-more? coin-values)) 0)
	  (else
	   (+ (cc amount
		  (except-first-denomination
		   coin-values))
	      (cc (- amount
		     (first-denomination
		      coin-values))
		  coin-values)))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref first-denomination
  (define (first-denomination coin-values)
    (car coin-values))
  (define (except-first-denomination coin-values)
    (cdr coin-values))
  (define (no-more? coin-values)
    (null? coin-values))
#+end_src

*Warning:* the next code is a bit slow (~1 minute).

#+begin_src scheme :exports both :results output
<<first-denomination>>
<<coin-values>>
(show #t " " (cc 137 us-coins) "\n")
(show #t " " (cc 137 uk-coins) "\n")
#+end_src

#+RESULTS:
:  704
:  443166

#+begin_src scheme :exports both :results output
<<first-denomination>>
<<coin-values>>
(show #t " " (cc 137 uk-coins-damaged) "\n")
#+end_src

#+RESULTS:
:  443166

I don't see why the result would depend on the order of the coins. We
don't seem to be using the order anywhere.

*** DONE Exercise 2.20 dotted-tail notation
    CLOSED: [2019-09-10 Tue 18:55]
1:45:10 
#+begin_src scheme :exports both :results value :noweb-ref same-parity
  (define (same-parity . lst)
    (define (iter-parity lst bit accumulator)
      (cond ((null? lst)
	     accumulator)
	    ((= (remainder (car lst) 2) bit)
	     (iter-parity (cdr lst) bit (cons (car lst) accumulator)))
	    (else
	     (iter-parity (cdr lst) bit accumulator))))
   (reverse (iter-parity lst (remainder (car lst) 2) '())))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results output
<<same-parity>>
(show #t " " (same-parity 2 3 4) "\n")
(show #t " " (same-parity 1 2 3 4) "\n")
#+end_src

#+RESULTS:
:  (2 4)
:  (1 3)

*** DONE Exercise 2.21 map-square-list
    CLOSED: [2019-09-10 Tue 19:14]
0:13:23 
#+begin_src scheme :exports both :results output
  (define nil #f)
  (define (square-list items)

  (if (null? items)
	'()
	(cons (* (car items) (car items)) (square-list (cdr items)))))
  (show #t " " (square-list '(1 2 3 4 5)))
#+end_src

#+RESULTS:
:  (1 4 9 16 25)

#+begin_src scheme :exports both :results output
  (define (square-list items)
    (map (lambda (x) (* x x)) items))

  (show #t " " (square-list '(1 2 3 4 5)))
#+end_src

#+RESULTS:
:  (1 4 9 16 25)

One of the peculiar tricks in this equation is that unlike in older
lisps, *#f* is not entirely the same as ~'()~, although they both
evaluate to false.

*** DONE Exercise 2.22 wrong list order
    CLOSED: [2019-09-10 Tue 19:24]
Referring to Exercise 2.20 is highly recommended. 

The problem with the first solution is that, indeed, he's ~cons~'ing
the pair in such a way that it would produce the reversed list.

The problem with the second solution is that it IS creating a list-ish
construction that is contains all the elements in the right order, but
stores them in ~cdr~'s, not in ~car~'s. 

In lisp without mutations (without ~set-cdr!~ and ~set-car!~), it is
only possible to prepend elements to lists, not really append.

*** DONE Exercise 2.23 for-each
    CLOSED: [2019-09-10 Tue 19:33]
0:04:56 
#+begin_src scheme :exports both :results output
  (define (for-each fun items)
   (unless (null? items)
    (fun (car items))
    (for-each fun (cdr items))))

  (for-each (lambda (x)
	      (newline)
	      (display x))
	    (list 57 321 88))
#+end_src

#+RESULTS:
: 
: 57
: 321
: 88

*** DONE Exercise 2.24 list-plot-result                            :graphviz:
    CLOSED: [2019-09-10 Tue 22:13]
0:48:39 
The result of the interpreter:
#+begin_src scheme :exports both :results output
(show #t " " (list 1 (list 2 (list 3 4))))
#+end_src

#+RESULTS:
:  (1 (2 (3 4)))

The box-and-pointer structure:

#+begin_src plantuml :exports both :file exercise-2-24.png
  @startdot
  digraph sicp2_24 {
    node [shape=plaintext, style="rounded"];
    struct1 [label=<<table BORDER="0" CELLBORDER="1" CELLSPACING="0">
             <tr>
                 <td width="29" height="35" sides="ltrb" port="f0">1</td>
                 <td width="29" height="35" sides="lrtb" port="f1"></td>
             </tr>
             </table>>, style="rounded,filled", fillcolor="gray"];
    rankdir=LR;
    edge [arrowhead=normal,arrowtail=dot,tailclip=false, dir=both];    
    struct1:f1:c -> struct2 [tailclip=false];
    
    node [shape=plaintext, style="rounded"];
    struct2 [label=<<table BORDER="0" CELLBORDER="1" CELLSPACING="0">
             <tr>
                 <td width="29" height="35" sides="ltrb" port="f0"></td>
                 <td width="29" height="35" sides="lrtb" port="f1">'()</td>
             </tr>
             </table>>, style="rounded,filled", fillcolor="gray"];
    
    struct2:f0:c -> struct3 [tailclip=false];
    
    node [shape=plaintext, style="rounded"];
    struct3 [label=<<table BORDER="0" CELLBORDER="1" CELLSPACING="0">
             <tr>
                 <td width="29" height="35" sides="ltrb" port="f0"></td>
                 <td width="29" height="35" sides="lrtb" port="f1"></td>
             </tr>
             </table>>, style="rounded,filled", fillcolor="gray"];

    node [shape=plaintext, style="rounded"];
    struct4 [label=<<table BORDER="0" CELLBORDER="1" CELLSPACING="0">
             <tr>
                 <td width="29" height="35" sides="ltrb" port="f0"></td>
                 <td width="29" height="35" sides="lrtb" port="f1">'()</td>
             </tr>
             </table>>, style="rounded,filled", fillcolor="gray"];
    struct3_3 [label="2",shape=record];
    struct3:f0:c -> struct3_3 [tailclip=false];

    struct3:f1:c -> struct4 [tailclip=false];

    struct5 [label=<<table BORDER="0" CELLBORDER="1" CELLSPACING="0">
             <tr>
                 <td width="29" height="35" sides="ltrb" port="f0">3</td>
                 <td width="29" height="35" sides="lrtb" port="f1"></td>
             </tr>
             </table>>, style="rounded,filled", fillcolor="gray"];
    struct4:f0:c -> struct5;    

    struct6 [label=<<table BORDER="0" CELLBORDER="1" CELLSPACING="0">
             <tr>
                 <td width="29" height="35" sides="ltrb" port="f0">4</td>
                 <td width="29" height="35" sides="lrtb" port="f1">'()</td>
             </tr>
             </table>>, style="rounded,filled", fillcolor="gray"];
    struct5:f1:c -> struct6;

  }

  @enddot
#+end_src 

#+RESULTS:
[[file:exercise-2-24.png]]

Tree interpretation:

 #+begin_src plantuml :exports both :file figure-1-1-dot.png
 @startdot
 graph g {
	 node [shape=plaintext];
	 A1 [label="(1 (2 (3 4)))"];

	 B1 [label="1"];
         B2 [label="(2 (3 4))"];

         C1 [label="2"];
         C2 [label="(3 4)"];

         D1 [label="3"];
         D2 [label="4"];


 // edges
	 A1 -- B1;
	 A1 -- B2;
	
	 B2 -- C1;
	 B2 -- C2;

	 C2 -- D1;
	 C2 -- D2;

	 { rank=same; A1 }
	 { rank=same; B1 B2 } 
	 { rank=same; C1 C2 }
	 { rank=same; D1 D2 }
 } 
 @enddot
 #+end_src 

 #+RESULTS:
 [[file:figure-1-1-dot.png]]

*** DONE Exercise 2.25 caddr
    CLOSED: [2019-09-10 Tue 23:07]
#+begin_src scheme :exports both :results value
(car (cdr (car (cdr (cdr '(1 3 (5 7) 9))))))
#+end_src

#+RESULTS:
: 7

#+begin_src scheme :exports both :results value
(caar '((7)))
#+end_src

#+RESULTS:
: 7

#+begin_src scheme :exports both :results output
(show #t " " (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr '(1 (2 (3 (4 (5 (6 7)))))))))))))))))))
#+end_src

#+RESULTS:
:  7

The task was funny.

*** DONE Exercise 2.26 append cons list
    CLOSED: [2019-09-10 Tue 23:23]

#+begin_src scheme :exports both :results output
(define x (list 1 2 3))
(define y (list 4 5 6))
(show #t " " (append x y) "\n")
(show #t " " (cons x y) "\n")
(show #t " " (list x y) "\n")
#+end_src

#+RESULTS:
:  (1 2 3 4 5 6)
:  ((1 2 3) 4 5 6)
:  ((1 2 3) (4 5 6))

*** DONE Exercise 2.27 deep-reverse
    CLOSED: [2019-09-11 Wed 09:47]
0:14:46 
#+begin_src scheme :exports both :results output
  (define (deep-reverse lst)
    (define (iter-reverse lst1 accumulator)
      (if (null? lst1)
	  accumulator
	  (if (pair? (car lst1))
	      (iter-reverse (cdr lst1) (cons (deep-reverse (car lst1)) accumulator))
	      (iter-reverse (cdr lst1) (cons (car lst1) accumulator)))))
    (iter-reverse lst '()))

  (define x (list (list 1 2) (list 3 4)))
  (show #t " " (reverse x) "\n")
  (show #t " " (deep-reverse x))
#+end_src

#+RESULTS:
:  ((3 4) (1 2))
:  ((4 3) (2 1))

*** DONE Exercise 2.28 fringe
    CLOSED: [2019-09-11 Wed 10:24]
0:37:00
#+begin_src scheme :exports both :results output
      (define (fringe tree)
	(define (fringe-iter tree accumulator)
	  (cond  ((null? tree) '())
		 ((not (pair? tree)) (list tree))
		 (else
		   (append accumulator 
			   (fringe-iter (car tree) '())
			   (fringe-iter (cdr tree) '())))))
	(fringe-iter tree '()))
      (define x (list (list 1 2) (list 3 4)))
      (show #t " " (fringe x) "\n")
      (show #t " " (fringe (list x x)) "\n")

#+end_src

#+RESULTS:
:  (1 2 3 4)
:  (1 2 3 4 1 2 3 4)

*** DONE Exercise 2.29 mobile
    CLOSED: [2019-09-11 Wed 11:47]
1:23:0
#+begin_src scheme :exports both :results value :noweb-ref mobile
  (define (make-mobile left right)
    (list left right))

  (define (make-branch length structure)
    (list length structure))

  (define (left-branch mobile)
    (car mobile))

  (define (right-branch mobile)
    (cadr mobile))

  (define (branch-length branch)
    (car branch))

  (define (branch-structure branch)
    (cadr branch))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref mobile-total-weight
  (define (total-weight mobile)
    (if (pair? mobile)
    (+ (if (pair? (branch-structure (left-branch mobile)))
	   (total-weight (branch-structure (left-branch mobile)))
	   (branch-structure (left-branch mobile)))
       (if (pair? (branch-structure (right-branch mobile)))
	   (total-weight (branch-structure (right-branch mobile)))
	   (branch-structure (right-branch mobile))))
    mobile))
#+end_src

#+begin_src scheme :exports both :results value
  <<mobile>>
  <<mobile-total-weight>>
  (total-weight
   (make-mobile
    (make-branch
     5
     (make-mobile
      (make-branch 1 1)
      (make-branch 2 2)))
    (make-branch 7 2)))
#+end_src

#+RESULTS:
: 5

#+begin_src scheme :exports both :results value :noweb-ref mobile-balanced
    (define (balanced? mobile)
      (and
       (=
	(*
	 (branch-length (left-branch mobile))
	 (total-weight (branch-structure (left-branch mobile))))
	(*
	 (branch-length (right-branch mobile))
	 (total-weight (branch-structure (right-branch mobile))))
	)
       (if (pair? (branch-structure (left-branch mobile)))
	   (balanced? (branch-structure (left-branch mobile)))
	   #t)
       (if (pair? (branch-structure (right-branch mobile)))
	   (balanced? (branch-structure (right-branch mobile)))
	   #t)))
     
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results output
<<mobile-balanced>>
<<mobile-total-weight>>
<<mobile>>
  (show #t " " (balanced?
   (make-mobile
    (make-branch
     5
     (make-mobile
      (make-branch 1 1)
      (make-branch 2 2)))
    (make-branch 7 2))) "\n")
  (show #t " " (balanced? (make-mobile (make-branch 5 5) (make-branch 5 5))) "\n")

#+end_src

#+RESULTS:
:  #f
:  #t

If we replace lists with ~cons~, the only thing that needs to be
changed is that ~cadr~ should be replaced with ~car~.

*** DONE Exercise 2.30 square-tree
    CLOSED: [2019-09-11 Wed 14:11]
 1. A no-high-level version
#+begin_src scheme :exports both :results value :noweb-ref  square-tree
  (define (square-tree tree)
    (cond ((null? tree) '())
	  ((not (pair? tree)) (square tree))
	  (else (cons (square-tree (car tree))
		      (square-tree (cdr tree))))))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results output
<<square-tree>>
  (show #t " " (square-tree
   (list 1
	 (list 2 (list 3 4) 5)
	 (list 6 7))))
#+end_src

#+RESULTS:
:  (1 (4 (9 16) 25) (36 49))
 2. High-level version
#+begin_src scheme :exports both :results output :noweb-ref square-subtree-map
    (define (square-tree tree)
      (map (lambda (sub-tree)
	     (if (pair? sub-tree)
		 (square-tree sub-tree)
		 (square sub-tree)))
	   tree))

#+end_src

#+RESULTS:

#+begin_src scheme :exports both :results output
<<square-subtree-map>>
  (show #t " " (square-tree
   (list 1
	 (list 2 (list 3 4) 5)
	 (list 6 7))))
#+end_src

#+RESULTS:
:  (1 (4 (9 16) 25) (36 49))

Not a very hard problem.

*** DONE Exercise 2.31 tree-map square tree
    CLOSED: [2019-09-11 Wed 14:38]
Not a very hard problem.
#+begin_src scheme :exports both :results output
  (define (square-tree tree) (tree-map square tree))

  (define (tree-map square tree)
    (map (lambda (sub-tree)
	   (if (pair? sub-tree)
	       (tree-map square sub-tree)
	       (square sub-tree)))
	 tree))
  (show #t " " 
	(square-tree
	 (list 1
	       (list 2 (list 3 4) 5)
	       (list 6 7))))

#+end_src

#+RESULTS:
:  (1 (4 (9 16) 25) (36 49))

*** DONE Exercise 2.32 subsets
    CLOSED: [2019-09-11 Wed 14:53]

#+begin_src scheme :exports both :results value :noweb-ref subsets
  (define (subsets s)
    (if (null? s)
	(list '())
	(let ((rest (subsets (cdr s))))
	  (append rest (map (lambda (suffix) (append (list (car s)) suffix)) rest)))))
  (subsets '(1 2 3))
#+end_src

#+RESULTS:
|---+---+---|
| 3 |   |   |
| 2 |   |   |
| 2 | 3 |   |
| 1 |   |   |
| 1 | 3 |   |
| 1 | 2 |   |
| 1 | 2 | 3 |

The explanation is easy. The subsets can be constructed by taking any
element, say, the first, and appending it to every subset of the rest
of the set. That is if we already have a set of subsets of some set
*S*, and we are adding some element *a*, then it may or may not be in
every subset of the enlarged set *S+a*. 


*** TODO Figure 2.7 Signal-flow diagram

*** DONE Exercise 2.33 map-append-length
    CLOSED: [2019-09-11 Wed 23:53]

#+begin_src scheme :exports both :results value :noweb-ref filter
  (define (filter predicate sequence)
    (cond ((null? sequence) '())
	  ((predicate (car sequence))
	   (cons (car sequence)
		 (filter predicate (cdr sequence))))
	  (else (filter predicate (cdr sequence)))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref accumulate
  (define (accumulate op initial sequence)
    (if (null? sequence)
	initial
	(op (car sequence)
	    (accumulate op initial (cdr sequence)))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref enumerate-interval
  (define (enumerate-interval low high)
    (if (> low high)
	'()
	(cons low (enumerate-interval (+ low 1) high))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref enumerate-tree
  (define (enumerate-tree tree)
    (cond ((null? tree) '())
	   ((not (pair? tree)) (list tree))
	   (else (append (enumerate-tree (car tree))
			 (enumerate-tree (cdr tree))))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref map-append-length
  (define (map p sequence)
    (accumulate (lambda (x y) (x y)) '() sequence))
  (define (append seq1 seq2)
    (accumulate cons seq2 seq1))
  (define (length sequence)
    (accumulate (lambda (x y) (+ 1 y))))
#+end_src

#+begin_src scheme :exports both :results value
 (length (make-list 100 99))
#+end_src

#+RESULTS:
: 100

*** DONE Exercise 2.34 horners-rule
    CLOSED: [2019-09-12 Thu 00:01]
#+begin_src scheme :exports both :results value
<<accumulate>>
  (define (horner-eval x coefficient-sequence)
    (accumulate (lambda (this-coeff higher-terms) (+ this-coeff (* x higher-terms)))
		0
		coefficient-sequence))
  (horner-eval 2 (list 1 3 0 5 0 1))

#+end_src

#+RESULTS:
: 79

*** DONE Exercise 2.35 count-leaves-accumulate
    CLOSED: [2019-09-12 Thu 00:17]
#+begin_src scheme :exports both :results value
<<accumulate>>
  (define (count-leaves t)
    (accumulate + 0 (map (lambda (x) (if (pair? x)
				    (count-leaves x)
				    1)) t)))
  (count-leaves (list 1 2 3))
#+end_src

#+RESULTS:
: 3

*** DONE Exercise 2.36 accumulate-n
    CLOSED: [2019-09-12 Thu 00:26]
#+begin_src scheme :exports both :results value :noweb-ref accumulate-n
<<accumulate>>
  (define (accumulate-n op init seqs)
    (if (null? (car seqs))
	'()
	(cons (accumulate op init (map car seqs))
              (accumulate-n op init (map cdr seqs)))))
#+end_src
  
#+begin_src scheme :exports both :results value
<<accumulate-n>>
  (accumulate-n + 0 '((1 2 3) (4 5 6) (7 8 9) (10 11 12)))
#+end_src

#+RESULTS:
| 22 | 26 | 30 |

*** DONE Exercise 2.37 matrix-*-vector
    CLOSED: [2019-09-12 Thu 00:50]

#+begin_src scheme :exports both :results value :noweb-ref dot-product
  (define (dot-product v w)
    (accumulate + 0 (map * v w)))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref matrix-operations
  (define (matrix-*-vector m v)
    (map (lambda (x) (dot-product v x)) m))
  (define (transpose mat)
    (accumulate-n cons '() mat))
  (define (matrix-*-matrix m n)
    (let ((cols (transpose n)))
      (map (lambda (x) (matrix-*-vector m x)) n)))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results output
<<accumulate>>
<<accumulate-n>>
<<dot-product>>
<<matrix-operations>>
(show #t " " (matrix-*-vector '((1 2 3 4) (4 5 6 6) (6 7 8 9)) '(1 2 3 4)) "\n")
(show #t " " (transpose '((1 2 3 4) (4 5 6 6) (6 7 8 9))) "\n")
(show #t " " (matrix-*-matrix
               '((1 2 3 4) (4 5 6 6) (6 7 8 9)) 
               '((1 2 3 4) (4 5 6 6) (6 7 8 9)) ) "\n")
#+end_src

#+RESULTS:
:  (30 56 80)
:  ((1 4 6) (2 5 7) (3 6 8) (4 6 9))
:  ((30 56 80) (56 113 161) (80 161 230))

*** DONE Exercise 2.38 fold-left
    CLOSED: [2019-09-12 Thu 09:45]
#+begin_src scheme :exports both :results value :noweb-ref fold-left
  (define (fold-left op initial sequence)
    (define (iter result rest)
      (if (null? rest)
	  result
	  (iter (op result (car rest))
		(cdr rest))))
    (iter initial sequence))
#+end_src

#+begin_src scheme :exports both :results output
<<accumulate>>
<<fold-left>>
(show #t " " (accumulate / 1 (list 1 2 3)) "\n")
(show #t " " (fold-left / 1 (list 1 2 3)) "\n")
(show #t " " (accumulate list '() (list 1 2 3)) "\n")
(show #t " " (fold-left list '() (list 1 2 3)) "\n")
(show #t " " (fold-left + 0 (list 1 2 3)) "\n")
(show #t " " (accumulate + 0 (list 1 2 3)) "\n")
#+end_src

#+RESULTS:
:  3/2
:  1/6
:  (1 (2 (3 ())))
:  (((() 1) 2) 3)
:  6
:  6

Well, it seems that commutative operations, that is the ones for which
\(a+b = b+a\).

*** DONE Exercise 2.39 reverse fold-right fold-left
    CLOSED: [2019-09-12 Thu 09:52]

#+begin_src scheme :exports both :results output
<<accumulate>>
<<fold-left>>
  (define (reverse sequence)
    (accumulate (lambda (x y) (cons x y)) '() sequence))
  (show #t " " (reverse (list 1 2 3)) "\n")
  (define (reverse sequence)
    (fold-left  (lambda (x y) (cons y x)) '() sequence))
  (show #t " " (reverse (list 1 2 3)))

#+end_src

#+RESULTS:
:  (1 2 3)
:  (3 2 1)

*** DONE Exercise 2.40 unique-pairs
    CLOSED: [2019-09-12 Thu 10:34]
0:42:00

#+begin_src scheme :exports both :results value :noweb-ref flatmap
  (define (flatmap proc seq)
    (accumulate append '() (map proc seq)))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref prime-sum
  (define (prime-sum? pair)
    (prime? (+ (car pair) (cadr pair))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref make-pair-sum
(define (make-pair-sum pair)
    (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref prime-sum-pairs
  (define (prime-sum-pairs n)
    (map make-pair-sum
	  (filter prime-sum? (flatmap
			      (lambda (i)
				(map (lambda (j) (list i j))
				     (enumerate-interval 1 (- i 1))))
			      (enumerate-interval 1 n)))))
#+end_src

#+begin_src scheme :exports both :results output
<<prime-sum-pairs>>
<<enumerate-interval>>
<<flatmap>>
<<accumulate>>
<<prime-sum>>
<<filter>>
<<fast-prime>>
<<fermat-primetest>>
<<expmod-miller-rabin>>
<<make-pair-sum>>
<<map-append-length>>
(show #t " " (prime-sum-pairs 30))
#+end_src

#+RESULTS:
:  ((2 1 3) (3 2 5) (4 1 5) (4 3 7) (5 2 7) (6 1 7) (6 5 11) (7 4 11) (7 6 13) (8 3 11) (8 5 13) (9 2 11) (9 4 13) (9 8 17) (10 1 11) (10 3 13) (10 7 17) (10 9 19) (11 2 13) (11 6 17) (11 8 19) (12 1 13) (12 5 17) (12 7 19) (12 11 23) (13 4 17) (13 6 19) (13 10 23) (14 3 17) (14 5 19) (14 9 23) (15 2 17) (15 4 19) (15 8 23) (15 14 29) (16 1 17) (16 3 19) (16 7 23) (16 13 29) (16 15 31) (17 2 19) (17 6 23) (17 12 29) (17 14 31) (18 1 19) (18 5 23) (18 11 29) (18 13 31) (19 4 23) (19 10 29) (19 12 31) (19 18 37) (20 3 23) (20 9 29) (20 11 31) (20 17 37) (21 2 23) (21 8 29) (21 10 31) (21 16 37) (21 20 41) (22 1 23) (22 7 29) (22 9 31) (22 15 37) (22 19 41) (22 21 43) (23 6 29) (23 8 31) (23 14 37) (23 18 41) (23 20 43) (24 5 29) (24 7 31) (24 13 37) (24 17 41) (24 19 43) (24 23 47) (25 4 29) (25 6 31) (25 12 37) (25 16 41) (25 18 43) (25 22 47) (26 3 29) (26 5 31) (26 11 37) (26 15 41) (26 17 43) (26 21 47) (27 2 29) (27 4 31) (27 10 37) (27 14 41) (27 16 43) (27 20 47) (27 26 53) (28 1 29) (28 3 31) (28 9 37) (28 13 41) (28 15 43) (28 19 47) (28 25 53) (29 2 31) (29 8 37) (29 12 41) (29 14 43) (29 18 47) (29 24 53) (30 1 31) (30 7 37) (30 11 41) (30 13 43) (30 17 47) (30 23 53) (30 29 59))

#+begin_src scheme :exports both :results value :noweb-ref unique-pairs
  (define (unique-pairs n)
    (flatmap
     (lambda (i)
       (map (lambda (j) (list i j))
	    (enumerate-interval 1 (- i 1))))
     (enumerate-interval 1 n)))
#+end_src

#+begin_src scheme :exports both :results value
  <<unique-pairs>>
  <<flatmap>>
  <<enumerate-interval>>
  <<accumulate>>
  (unique-pairs 3)
#+end_src

#+RESULTS:
| 2 | 1 |
| 3 | 1 |
| 3 | 2 |

#+begin_src scheme :exports both :results value :noweb-ref prime-sum-pairs-unique-pairs
  (define (prime-sum-pairs n)
    (map make-pair-sum
	  (filter prime-sum? (unique-pairs n))))
#+end_src

#+begin_src scheme :exports both :results value
<<unique-pairs>>
<<prime-sum-pairs-unique-pairs>>
<<enumerate-interval>>
<<flatmap>>
<<accumulate>>
<<prime-sum>>
<<filter>>
<<fast-prime>>
<<fermat-primetest>>
<<expmod-miller-rabin>>
<<make-pair-sum>>
<<map-append-length>>
(prime-sum-pairs 10)
#+end_src

#+RESULTS:
|  2 | 1 |  3 |
|  3 | 2 |  5 |
|  4 | 1 |  5 |
|  4 | 3 |  7 |
|  5 | 2 |  7 |
|  6 | 1 |  7 |
|  6 | 5 | 11 |
|  7 | 4 | 11 |
|  7 | 6 | 13 |
|  8 | 3 | 11 |
|  8 | 5 | 13 |
|  9 | 2 | 11 |
|  9 | 4 | 13 |
|  9 | 8 | 17 |
| 10 | 1 | 11 |
| 10 | 3 | 13 |
| 10 | 7 | 17 |
| 10 | 9 | 19 |

I have to note that this deceiptively simple task involves reusing
results of 12 other problems.
 
*** DONE Exercise 2.41 triple-sum
    CLOSED: [2019-09-14 Sat 15:15]
     *Exercise 2.41:* Write a procedure to find all ordered triples of
     distinct positive integers i, j, and k less than or equal to a
     given integer n that sum to a given integer s.

#+begin_src scheme :exports both :results value :noweb-ref unique-triples
    (define (unique-triples n)
      (flatmap
       (lambda (i)
	 (flatmap (lambda (j) 
		(map (lambda (k) (list i j k))
		     (enumerate-interval 1 (- j 1))))
	      (enumerate-interval 1 (- i 1))))
       (enumerate-interval 1 n)))

#+end_src

#+begin_src scheme :exports both :results output
<<accumulate>>
<<enumerate-interval>>
<<flatmap>>
<<unique-triples>>
(show #t " " (unique-triples 5) "\n")
#+end_src

#+RESULTS:
:  ((3 2 1) (4 2 1) (4 3 1) (4 3 2) (5 2 1) (5 3 1) (5 3 2) (5 4 1) (5 4 2) (5 4 3))



#+begin_src scheme :exports both :results value :noweb-ref sum-equal-s
  (define (sum-equal-s? s tuple)
    (if (= s  (accumulate + 0 tuple))
	#t
	#f))
#+end_src

#+begin_src scheme :exports both :results value
<<sum-equal-s>>
<<accumulate>>
(and (sum-equal-s? 30 (list 10 5 5 9 1)) (not (sum-equal-s? 10 (list 3 3 3))))
#+end_src

#+RESULTS:
: #t

#+begin_src scheme :exports both :results value :noweb-ref sum-equal-s-triples
  (define (sum-equal-s-triples s n)
    (filter (lambda (x) (sum-equal-s? s x)) (unique-triples n)))
#+end_src

#+begin_src scheme :exports both :results value
<<enumerate-interval>>
<<flatmap>>
<<sum-equal-s-triples>>
<<accumulate>>
<<sum-equal-s>>
<<filter>>
<<unique-triples>>
(sum-equal-s-triples 15 30)
#+end_src

#+RESULTS:
|  6 | 5 | 4 |
|  7 | 5 | 3 |
|  7 | 6 | 2 |
|  8 | 4 | 3 |
|  8 | 5 | 2 |
|  8 | 6 | 1 |
|  9 | 4 | 2 |
|  9 | 5 | 1 |
| 10 | 3 | 2 |
| 10 | 4 | 1 |
| 11 | 3 | 1 |
| 12 | 2 | 1 |


*** DONE Figure 2.8 A solution to the eight-queens puzzle.

#+begin_src plantuml :exports both :file figure-2-8.png
@startditaa
          +---+---+---+---+---+---+---+---+
          |   |   |   |   |   | Q |   |   |
          +---+---+---+---+---+---+---+---+
          |   |   | Q |   |   |   |   |   |
          +---+---+---+---+---+---+---+---+
          | Q |   |   |   |   |   |   |   |
          +---+---+---+---+---+---+---+---+
          |   |   |   |   |   |   | Q |   |
          +---+---+---+---+---+---+---+---+
          |   |   |   |   | Q |   |   |   |
          +---+---+---+---+---+---+---+---+
          |   |   |   |   |   |   |   | Q |
          +---+---+---+---+---+---+---+---+
          |   | Q |   |   |   |   |   |   |
          +---+---+---+---+---+---+---+---+
          |   |   |   | Q |   |   |   |   |
          +---+---+---+---+---+---+---+---+
@endditaa
#+end_src 

#+RESULTS:
[[file:figure-2-8.png]]

*** DONE Exercise 2.42 k-queens
    CLOSED: [2019-09-17 Tue 22:27]
3:00:00 + 2:00:00 + 1:00:00 = 6:00:00
The commentary to this problem is bad. Firstly, it is *NOT* obvious
that it is even possible to place a queen into every column and every
row. Indeed, in the solution above, this happens to be the case, but
this is by no means obvious.

The second thought: since the algorithm is expected to provide *all*
possible solutions, it should be required have a list of lists... sort
of, to represent the multitude. So ~queens~ should return a list of
lists. 

Secondly, the code given by the authors is totally moronic in at least
two places: 
 1. rest-of-queens? Seriously? Why not "world of queens", or
    "suffix-queens", to make it even more obscure? It should have been
    called "prefix-queens", or, better "queens-already-on-board". We
    are not short of bytes, are we?
 2. who on Earth would call a procedure "queen-cols"? What does it
even mean? Descriptive names -- zero.
 
The third thought: anyone who wants to solve this puzzle, must at
least know what it is for a queen to be "safe". That is, if a queen
number A has a position b_1 then our new queen's B position b_2 must
satisfy : 1) b_2 \neq b_1 2)|b_2 - b_1| \ne B - A. And this must be true
\forall A < B.

The fourth thought: it is *NOT* obvious, but the "rest of queens"
contains the list of queens _in the reversed order_. So ~car~'ing
anything with it represents attaching the queen _to the end_ of the
list. This is why we have *k* supplied as an argument to the ~safe?~
procedure.

#+begin_src scheme :exports both :results value :noweb-ref k-queens
  (define (queens board-size)
    (define (queen-cols k)
      (if (= k 0)
	  (list empty-board)
	  (filter
	   (lambda (positions) (safe? k positions))
	   (flatmap
	    (lambda (rest-of-queens)
	      (map (lambda (new-row)
		     (adjoin-position new-row k rest-of-queens))
		   (enumerate-interval 1 board-size)))
	    (queen-cols (- k 1))))))
    (queen-cols board-size))

#+end_src

#+begin_src scheme :exports both :results output
<<k-queens>>
<<flatmap>>
<<enumerate-interval>>
<<accumulate>>
<<filter>>
  (define empty-board '())
  (define (adjoin-position new-row k rest-of-queens)
    (cons (cons k new-row) rest-of-queens))
  (define (safe? k positions)
    (cond ((null? (cdr positions)) #t)
	  ((= k 1) #t)
	  ((= (cdar positions) (cdadr positions)) #f)
	  ((= (abs (- (cdar positions) (cdadr positions))) (abs (- (caar positions) (caadr positions)))) #f)
	  (else (safe? k (cons (car positions) (cddr positions))))))
(map (lambda (x) (show #t " " x "\n")) (queens 8))
#+end_src

#+RESULTS:
#+begin_example
 ((8 . 4) (7 . 2) (6 . 7) (5 . 3) (4 . 6) (3 . 8) (2 . 5) (1 . 1))
 ((8 . 5) (7 . 2) (6 . 4) (5 . 7) (4 . 3) (3 . 8) (2 . 6) (1 . 1))
 ((8 . 3) (7 . 5) (6 . 2) (5 . 8) (4 . 6) (3 . 4) (2 . 7) (1 . 1))
 ((8 . 3) (7 . 6) (6 . 4) (5 . 2) (4 . 8) (3 . 5) (2 . 7) (1 . 1))
 ((8 . 5) (7 . 7) (6 . 1) (5 . 3) (4 . 8) (3 . 6) (2 . 4) (1 . 2))
 ((8 . 4) (7 . 6) (6 . 8) (5 . 3) (4 . 1) (3 . 7) (2 . 5) (1 . 2))
 ((8 . 3) (7 . 6) (6 . 8) (5 . 1) (4 . 4) (3 . 7) (2 . 5) (1 . 2))
 ((8 . 5) (7 . 3) (6 . 8) (5 . 4) (4 . 7) (3 . 1) (2 . 6) (1 . 2))
 ((8 . 5) (7 . 7) (6 . 4) (5 . 1) (4 . 3) (3 . 8) (2 . 6) (1 . 2))
 ((8 . 4) (7 . 1) (6 . 5) (5 . 8) (4 . 6) (3 . 3) (2 . 7) (1 . 2))
 ((8 . 3) (7 . 6) (6 . 4) (5 . 1) (4 . 8) (3 . 5) (2 . 7) (1 . 2))
 ((8 . 4) (7 . 7) (6 . 5) (5 . 3) (4 . 1) (3 . 6) (2 . 8) (1 . 2))
 ((8 . 6) (7 . 4) (6 . 2) (5 . 8) (4 . 5) (3 . 7) (2 . 1) (1 . 3))
 ((8 . 6) (7 . 4) (6 . 7) (5 . 1) (4 . 8) (3 . 2) (2 . 5) (1 . 3))
 ((8 . 1) (7 . 7) (6 . 4) (5 . 6) (4 . 8) (3 . 2) (2 . 5) (1 . 3))
 ((8 . 6) (7 . 8) (6 . 2) (5 . 4) (4 . 1) (3 . 7) (2 . 5) (1 . 3))
 ((8 . 6) (7 . 2) (6 . 7) (5 . 1) (4 . 4) (3 . 8) (2 . 5) (1 . 3))
 ((8 . 4) (7 . 7) (6 . 1) (5 . 8) (4 . 5) (3 . 2) (2 . 6) (1 . 3))
 ((8 . 5) (7 . 8) (6 . 4) (5 . 1) (4 . 7) (3 . 2) (2 . 6) (1 . 3))
 ((8 . 4) (7 . 8) (6 . 1) (5 . 5) (4 . 7) (3 . 2) (2 . 6) (1 . 3))
 ((8 . 2) (7 . 7) (6 . 5) (5 . 8) (4 . 1) (3 . 4) (2 . 6) (1 . 3))
 ((8 . 1) (7 . 7) (6 . 5) (5 . 8) (4 . 2) (3 . 4) (2 . 6) (1 . 3))
 ((8 . 2) (7 . 5) (6 . 7) (5 . 4) (4 . 1) (3 . 8) (2 . 6) (1 . 3))
 ((8 . 4) (7 . 2) (6 . 7) (5 . 5) (4 . 1) (3 . 8) (2 . 6) (1 . 3))
 ((8 . 5) (7 . 7) (6 . 1) (5 . 4) (4 . 2) (3 . 8) (2 . 6) (1 . 3))
 ((8 . 6) (7 . 4) (6 . 1) (5 . 5) (4 . 8) (3 . 2) (2 . 7) (1 . 3))
 ((8 . 5) (7 . 1) (6 . 4) (5 . 6) (4 . 8) (3 . 2) (2 . 7) (1 . 3))
 ((8 . 5) (7 . 2) (6 . 6) (5 . 1) (4 . 7) (3 . 4) (2 . 8) (1 . 3))
 ((8 . 6) (7 . 3) (6 . 7) (5 . 2) (4 . 8) (3 . 5) (2 . 1) (1 . 4))
 ((8 . 2) (7 . 7) (6 . 3) (5 . 6) (4 . 8) (3 . 5) (2 . 1) (1 . 4))
 ((8 . 7) (7 . 3) (6 . 1) (5 . 6) (4 . 8) (3 . 5) (2 . 2) (1 . 4))
 ((8 . 5) (7 . 1) (6 . 8) (5 . 6) (4 . 3) (3 . 7) (2 . 2) (1 . 4))
 ((8 . 1) (7 . 5) (6 . 8) (5 . 6) (4 . 3) (3 . 7) (2 . 2) (1 . 4))
 ((8 . 3) (7 . 6) (6 . 8) (5 . 1) (4 . 5) (3 . 7) (2 . 2) (1 . 4))
 ((8 . 6) (7 . 3) (6 . 1) (5 . 7) (4 . 5) (3 . 8) (2 . 2) (1 . 4))
 ((8 . 7) (7 . 5) (6 . 3) (5 . 1) (4 . 6) (3 . 8) (2 . 2) (1 . 4))
 ((8 . 7) (7 . 3) (6 . 8) (5 . 2) (4 . 5) (3 . 1) (2 . 6) (1 . 4))
 ((8 . 5) (7 . 3) (6 . 1) (5 . 7) (4 . 2) (3 . 8) (2 . 6) (1 . 4))
 ((8 . 2) (7 . 5) (6 . 7) (5 . 1) (4 . 3) (3 . 8) (2 . 6) (1 . 4))
 ((8 . 3) (7 . 6) (6 . 2) (5 . 5) (4 . 8) (3 . 1) (2 . 7) (1 . 4))
 ((8 . 6) (7 . 1) (6 . 5) (5 . 2) (4 . 8) (3 . 3) (2 . 7) (1 . 4))
 ((8 . 8) (7 . 3) (6 . 1) (5 . 6) (4 . 2) (3 . 5) (2 . 7) (1 . 4))
 ((8 . 2) (7 . 8) (6 . 6) (5 . 1) (4 . 3) (3 . 5) (2 . 7) (1 . 4))
 ((8 . 5) (7 . 7) (6 . 2) (5 . 6) (4 . 3) (3 . 1) (2 . 8) (1 . 4))
 ((8 . 3) (7 . 6) (6 . 2) (5 . 7) (4 . 5) (3 . 1) (2 . 8) (1 . 4))
 ((8 . 6) (7 . 2) (6 . 7) (5 . 1) (4 . 3) (3 . 5) (2 . 8) (1 . 4))
 ((8 . 3) (7 . 7) (6 . 2) (5 . 8) (4 . 6) (3 . 4) (2 . 1) (1 . 5))
 ((8 . 6) (7 . 3) (6 . 7) (5 . 2) (4 . 4) (3 . 8) (2 . 1) (1 . 5))
 ((8 . 4) (7 . 2) (6 . 7) (5 . 3) (4 . 6) (3 . 8) (2 . 1) (1 . 5))
 ((8 . 7) (7 . 1) (6 . 3) (5 . 8) (4 . 6) (3 . 4) (2 . 2) (1 . 5))
 ((8 . 1) (7 . 6) (6 . 8) (5 . 3) (4 . 7) (3 . 4) (2 . 2) (1 . 5))
 ((8 . 3) (7 . 8) (6 . 4) (5 . 7) (4 . 1) (3 . 6) (2 . 2) (1 . 5))
 ((8 . 6) (7 . 3) (6 . 7) (5 . 4) (4 . 1) (3 . 8) (2 . 2) (1 . 5))
 ((8 . 7) (7 . 4) (6 . 2) (5 . 8) (4 . 6) (3 . 1) (2 . 3) (1 . 5))
 ((8 . 4) (7 . 6) (6 . 8) (5 . 2) (4 . 7) (3 . 1) (2 . 3) (1 . 5))
 ((8 . 2) (7 . 6) (6 . 1) (5 . 7) (4 . 4) (3 . 8) (2 . 3) (1 . 5))
 ((8 . 2) (7 . 4) (6 . 6) (5 . 8) (4 . 3) (3 . 1) (2 . 7) (1 . 5))
 ((8 . 3) (7 . 6) (6 . 8) (5 . 2) (4 . 4) (3 . 1) (2 . 7) (1 . 5))
 ((8 . 6) (7 . 3) (6 . 1) (5 . 8) (4 . 4) (3 . 2) (2 . 7) (1 . 5))
 ((8 . 8) (7 . 4) (6 . 1) (5 . 3) (4 . 6) (3 . 2) (2 . 7) (1 . 5))
 ((8 . 4) (7 . 8) (6 . 1) (5 . 3) (4 . 6) (3 . 2) (2 . 7) (1 . 5))
 ((8 . 2) (7 . 6) (6 . 8) (5 . 3) (4 . 1) (3 . 4) (2 . 7) (1 . 5))
 ((8 . 7) (7 . 2) (6 . 6) (5 . 3) (4 . 1) (3 . 4) (2 . 8) (1 . 5))
 ((8 . 3) (7 . 6) (6 . 2) (5 . 7) (4 . 1) (3 . 4) (2 . 8) (1 . 5))
 ((8 . 4) (7 . 7) (6 . 3) (5 . 8) (4 . 2) (3 . 5) (2 . 1) (1 . 6))
 ((8 . 4) (7 . 8) (6 . 5) (5 . 3) (4 . 1) (3 . 7) (2 . 2) (1 . 6))
 ((8 . 3) (7 . 5) (6 . 8) (5 . 4) (4 . 1) (3 . 7) (2 . 2) (1 . 6))
 ((8 . 4) (7 . 2) (6 . 8) (5 . 5) (4 . 7) (3 . 1) (2 . 3) (1 . 6))
 ((8 . 5) (7 . 7) (6 . 2) (5 . 4) (4 . 8) (3 . 1) (2 . 3) (1 . 6))
 ((8 . 7) (7 . 4) (6 . 2) (5 . 5) (4 . 8) (3 . 1) (2 . 3) (1 . 6))
 ((8 . 8) (7 . 2) (6 . 4) (5 . 1) (4 . 7) (3 . 5) (2 . 3) (1 . 6))
 ((8 . 7) (7 . 2) (6 . 4) (5 . 1) (4 . 8) (3 . 5) (2 . 3) (1 . 6))
 ((8 . 5) (7 . 1) (6 . 8) (5 . 4) (4 . 2) (3 . 7) (2 . 3) (1 . 6))
 ((8 . 4) (7 . 1) (6 . 5) (5 . 8) (4 . 2) (3 . 7) (2 . 3) (1 . 6))
 ((8 . 5) (7 . 2) (6 . 8) (5 . 1) (4 . 4) (3 . 7) (2 . 3) (1 . 6))
 ((8 . 3) (7 . 7) (6 . 2) (5 . 8) (4 . 5) (3 . 1) (2 . 4) (1 . 6))
 ((8 . 3) (7 . 1) (6 . 7) (5 . 5) (4 . 8) (3 . 2) (2 . 4) (1 . 6))
 ((8 . 8) (7 . 2) (6 . 5) (5 . 3) (4 . 1) (3 . 7) (2 . 4) (1 . 6))
 ((8 . 3) (7 . 5) (6 . 2) (5 . 8) (4 . 1) (3 . 7) (2 . 4) (1 . 6))
 ((8 . 3) (7 . 5) (6 . 7) (5 . 1) (4 . 4) (3 . 2) (2 . 8) (1 . 6))
 ((8 . 5) (7 . 2) (6 . 4) (5 . 6) (4 . 8) (3 . 3) (2 . 1) (1 . 7))
 ((8 . 6) (7 . 3) (6 . 5) (5 . 8) (4 . 1) (3 . 4) (2 . 2) (1 . 7))
 ((8 . 5) (7 . 8) (6 . 4) (5 . 1) (4 . 3) (3 . 6) (2 . 2) (1 . 7))
 ((8 . 4) (7 . 2) (6 . 5) (5 . 8) (4 . 6) (3 . 1) (2 . 3) (1 . 7))
 ((8 . 4) (7 . 6) (6 . 1) (5 . 5) (4 . 2) (3 . 8) (2 . 3) (1 . 7))
 ((8 . 6) (7 . 3) (6 . 1) (5 . 8) (4 . 5) (3 . 2) (2 . 4) (1 . 7))
 ((8 . 5) (7 . 3) (6 . 1) (5 . 6) (4 . 8) (3 . 2) (2 . 4) (1 . 7))
 ((8 . 4) (7 . 2) (6 . 8) (5 . 6) (4 . 1) (3 . 3) (2 . 5) (1 . 7))
 ((8 . 6) (7 . 3) (6 . 5) (5 . 7) (4 . 1) (3 . 4) (2 . 2) (1 . 8))
 ((8 . 6) (7 . 4) (6 . 7) (5 . 1) (4 . 3) (3 . 5) (2 . 2) (1 . 8))
 ((8 . 4) (7 . 7) (6 . 5) (5 . 2) (4 . 6) (3 . 1) (2 . 3) (1 . 8))
 ((8 . 5) (7 . 7) (6 . 2) (5 . 6) (4 . 3) (3 . 1) (2 . 4) (1 . 8))
#+end_example

Because of really terrible introduction, this exercise took me 6 times
more than it's worth.

*** DONE Exercise 2.43 slow k-queens
    CLOSED: [2019-09-17 Tue 22:55]

To answer this exercise, we need to estimate the complexity of the
canonical solution and Louis' solution.

For the canonical solution, we can safely assume that the ~safe?~
procedure filters out no sequences at all (this would only worsen our
estimate). Therefore, every additional column would multiply the total
computation needed by the size of the column. Roughly speaking, this
would be \(k^k \approx 2^k \rightarrow 2^{}^6 = 64\).

For the Louis's solution, however, the ~(queen-cols (- k 1))~ is
solved for every value of ~k~ from scratch, which is not necessary,
and adds an additional multiplicand of \(k^{k-1}\) for every
~k~. Roughly speaking, this adds an additional power of \(k-1\) to the
solution time. \( (k\cdot T)^k \approx 2^{6k}\rightarrow 2^{36}\). A little bit too much.

*** Remark. Now we are starting the "picture language" chapter. 
It may (and will) require extensive modification to the standard
working environment, because I am not using the most default nowadays
Racket. In this subsection I will implement the required subroutines.

(define wave2 (beside wave (flip-vert wave)))
     (define wave4 (below wave2 wave2))

SICP is incredibly confusing in this chapter. 

The following is one of the most prominent examples:
#+begin_src scheme :exports both :results value
(define (segments->painter segment-list)
       (lambda (frame)
         (for-each
          (lambda (segment)
            (draw-line
             ((frame-coord-map frame) (start-segment segment))
             ((frame-coord-map frame) (end-segment segment))))
          segment-list)))
#+end_src

#+begin_src scheme :exports both :results raw value :noweb-ref draw-line
  (define canvas-size
    (make-parameter
     200
     (lambda (size)
       (if (and (exact-integer? size) (<= 2 size 1000))
	   size
	   (error "invalid canvas size")))))
  (define canvas-file-name
    (make-parameter
     "/tmp/scheme-temp.gif"
     (lambda (name)
       (if (string? name)
	   name
	   (error "invalid canvas file name")))))
  (define (canvas-reset)
    (system "rm" (canvas-file-name))
    (system "convert" "xc:white"
	    "-scale" (string-append
		      (number->string (canvas-size))
		      "x"
		      (number->string (canvas-size)))
	    (canvas-file-name)))
  (define (canvas-refresh)
    (string-append "[[" (canvas-file-name) "]]"))
  (define (draw-line point1 point2)
    (system "mogrify"
	    "-fill" "black"
	    "-draw" (string-append "line "
				   (number->string (* (canvas-size) (car point1)))
				   ","
				   (number->string (* (canvas-size) (cadr point1)))
				   " "
				   (number->string (* (canvas-size) (car point2)))
				   ","
				   (number->string (* (canvas-size) (cadr point2))))
	    (canvas-file-name))
    (display (string-append "[[" (canvas-file-name) "]]"))
    (string-append "[[" (canvas-file-name) "]]"))
  (canvas-reset)
#+end_src

#+begin_src scheme :exports both :results raw value
  <<draw-line>>
  (draw-line (list 0 0) (list 1 1))
  (draw-line (list 0 1) (list 1 0))
#+end_src

#+RESULTS:
[[/tmp/scheme-temp.gif]]

#+begin_src scheme :exports both :results value :noweb-ref pict-frame
  (define (frame-coord-map frame)
    (lambda (v)
     (add-vect
       (origin-frame frame)
              (add-vect (scale-vect (xcor-vect v) (edge1-frame frame))
		 (scale-vect (ycor-vect v) (edge2-frame frame))))))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results value
  <<make-frame>>
  <<pict-frame>>
  <<pict-vect>>
  ((frame-coord-map
	   (make-frame
	    (make-vect 0.1 0.2)
	    (make-vect 1.0 1.0)
	    (make-vect 1.0 1.0))) (make-vect 0 0))
#+end_src

#+RESULTS:
| 0.1 | 0.2 |

#+begin_src scheme :exports both :results raw value :noweb-ref segments-painter
  (define (segments->painter segment-list)
    (lambda (frame)
      (for-each
       (lambda (segment)
	 (draw-line
	  ((frame-coord-map frame)
	   (start-segment segment))
	  ((frame-coord-map frame)
	   (end-segment segment))))
       segment-list)))
#+end_src

*** TODO Figure 2.10 Wave painter
*** TODO Exercise 2.44 
*** TODO Exercise 2.45
*** DONE Exercise 2.46 make-vect
    CLOSED: [2019-09-20 Fri 12:48]
#+begin_src scheme :exports both :results value :noweb-ref pict-vect
  (define (make-vect xcor ycor . o)
    (append (list xcor) (list ycor) o))
  (define (xcor-vect vect)
    (car vect))
  (define (ycor-vect vect)
    (cadr vect))
  (define (scale-vect scale vect)
    (map (lambda (x) (* x scale)) vect))
  (define (add-vect vec1 vec2)
    (map (lambda (cor1 cor2) (+ cor1 cor2)) vec1 vec2))
  (define (sub-vect vec1 vec2)
    (map (lambda (cor1 cor2) (- cor1 cor2)) vec1 vec2))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results output
<<pict-vect>>
(show #t (make-vect 1 2 3) "\n")
(show #t (xcor-vect (make-vect 1 2 3)) "\n")
(show #t (ycor-vect (make-vect 1 2 3)) "\n")
(show #t (scale-vect 2 (make-vect 1 2 3)) "\n")
(show #t (add-vect (make-vect 1 2 3) (make-vect 1 2 3)) "\n")
(show #t (sub-vect (make-vect 1 2 3) (make-vect 1 2 3)) "\n")
#+end_src

#+RESULTS:
: (1 2 3)
: 1
: 2
: (2 4 6)
: (2 4 6)
: (0 0 0)

*** DONE Exercise 2.47 make-frame
    CLOSED: [2019-09-20 Fri 14:48]
#+begin_src scheme :exports both :results value :noweb-ref make-frame
(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))
(define (origin-frame frame)
  (car frame))
(define (edge1-frame frame)
  (cadr frame))
(define (edge2-frame frame)
  (caddr frame))
#+end_src
#+begin_src scheme :exports both :results output
<<make-frame>>
<<pict-vect>>
(make-frame (make-vect 0.1 0.2) (make-vect 0.1 0.2) (make-vect 0.0 0.3))
(origin-frame (make-frame (make-vect 0.1 0.2) (make-vect 0.1 0.2) (make-vect 0.0 0.3)))
(edge1-frame  (make-frame (make-vect 0.1 0.2) (make-vect 0.1 0.2) (make-vect 0.0 0.3)))
(edge2-frame  (make-frame (make-vect 0.1 0.2) (make-vect 0.1 0.2) (make-vect 0.0 0.3)))
#+end_src

#+RESULTS:

#+begin_src scheme :exports both :results output
<<pict-vect>>
  (define (make-frame origin edge1 edge2)
    (cons origin (cons edge1 edge2)))
  (define (origin-frame frame)
    (car frame))
  (define (edge1-frame frame)
    (cadr frame))
  (define (edge2-frame frame)
    (cddr frame))
  (show #t (origin-frame (make-frame (make-vect 0.1 0.2) (make-vect 0.1 0.2) (make-vect 0.0 0.3))) "\n")
  (show #t (edge1-frame (make-frame (make-vect 0.1 0.2) (make-vect 0.1 0.2) (make-vect 0.0 0.3))) "\n")
  (show #t (edge2-frame (make-frame (make-vect 0.1 0.2) (make-vect 0.1 0.2) (make-vect 0.0 0.3))) "\n")
#+end_src

#+RESULTS:
: (0.1 0.2)
: (0.1 0.2)
: (0.0 0.3)

*** DONE Exercise 2.48 make-segment
    CLOSED: [2019-09-20 Fri 16:06]
#+begin_src scheme :exports both :results value :noweb-ref pict-segment
  (define (make-segment start-vector end-vector)
    (list start-vector end-vector))
  (define (start-segment segment)
    (car segment))
  (define (end-segment segment)
    (cadr segment))
#+end_src

#+begin_src scheme :exports both :results raw value
  <<draw-line>>
  <<pict-segment>>
  <<segments-painter>>
  <<pict-vect>>
  <<make-frame>>
  <<pict-frame>>
  ((segments->painter
    (list
     (make-segment (make-vect 0 0) (make-vect 1 1))
     (make-segment (make-vect 0 1) (make-vect 1 0))))
   (make-frame (make-vect 0 0) (make-vect 0 1) (make-vect 1 0)))
  (canvas-refresh)
#+end_src

#+RESULTS:
[[/tmp/scheme-temp.gif]]

*** TODO Exercise 2.49

#+begin_src scheme :exports both :results value :noweb-ref x-painter
(define x-painter
  (segments->painter
    (list
     (make-segment (make-vect 0 0) (make-vect 1 1))
     (make-segment (make-vect 0 1) (make-vect 1 0)))))
#+end_src

#+begin_src scheme :exports both :results raw value
  <<draw-line>>
  <<pict-segment>>
  <<segments-painter>>
  <<pict-vect>>
  <<make-frame>>
  <<pict-frame>>
  <<x-painter>>
  (x-painter
   (make-frame (make-vect 0 0) (make-vect 0 1) (make-vect 1 0)))
  (canvas-refresh)
#+end_src

#+RESULTS:
[[/tmp/scheme-temp.gif]]

This painter is not entirely accurate, because my background is black,
so the lines would coalesce with it. I therefore just moved the lines
a little bit inside.

#+begin_src scheme :exports both :results value :noweb-ref frame-boundary-painter
(define frame-boundary-painter
  (segments->painter
    (list
     (make-segment (make-vect 0.01 0.01) (make-vect 0.01 0.99))
     (make-segment (make-vect 0.01 0.99) (make-vect 0.99 0.99))
     (make-segment (make-vect 0.99 0.99) (make-vect 0.99 0.01))
     (make-segment (make-vect 0.99 0.01) (make-vect 0.01 0.01)))))
#+end_src

#+begin_src scheme :exports both :results raw value
  <<draw-line>>
  <<pict-segment>>
  <<segments-painter>>
  <<pict-vect>>
  <<make-frame>>
  <<pict-frame>>
  <<frame-boundary-painter>>

  (frame-boundary-painter
   (make-frame (make-vect 0.1 0.1) (make-vect 0.1 0.05) (make-vect 0.5 0)))
  (canvas-refresh)
#+end_src

#+RESULTS:
[[/tmp/scheme-temp.gif]]

#+begin_src scheme :exports both :results value :noweb-ref diamond-painter
(define diamond-painter
  (segments->painter
    (list
     (make-segment (make-vect 0.01 0.5) (make-vect 0.5 0.99))
     (make-segment (make-vect 0.5 0.99) (make-vect 0.99 0.5))
     (make-segment (make-vect 0.99 0.5) (make-vect 0.5 0.01))
     (make-segment (make-vect 0.5 0.01) (make-vect 0.01 0.5)))))
#+end_src

#+begin_src scheme :exports both :results raw value
  <<draw-line>>
  <<pict-segment>>
  <<segments-painter>>
  <<pict-vect>>
  <<make-frame>>
  <<pict-frame>>
  <<diamond-painter>>

  (diamond-painter
   (make-frame (make-vect 0 0) (make-vect 0 1) (make-vect 1 0)))
  (canvas-refresh)
#+end_src

#+RESULTS:
[[/tmp/scheme-temp.gif]]


*** TODO Exercise 2.50

*** TODO Exercise 2.51

*** TODO Exercise 2.52
*** Remark. Here the picture language chapter stops

*** TODO Exercise 2.53

*** TODO Exercise 2.54

*** TODO Exercise 2.55

*** TODO Exercise 2.56

*** TODO Exercise 2.57

*** TODO Exercise 2.58

*** TODO Exercise 2.59

*** TODO Exercise 2.60

*** TODO Exercise 2.61

*** TODO Exercise 2.62

*** TODO Exercise 2.63

*** TODO Exercise 2.64

*** TODO Exercise 2.65

*** TODO Exercise 2.66

*** TODO Exercise 2.67

*** TODO Exercise 2.68

*** TODO Exercise 2.69

*** TODO Exercise 2.70

*** TODO Exercise 2.71

*** TODO Exercise 2.72

*** TODO Exercise 2.73

*** TODO Exercise 2.74

*** TODO Exercise 2.75

*** TODO Exercise 2.76

*** TODO Exercise 2.77

*** TODO Exercise 2.78

*** TODO Exercise 2.79

*** TODO Exercise 2.80

*** TODO Exercise 2.81

*** TODO Exercise 2.82

*** TODO Exercise 2.83

*** TODO Exercise 2.84

*** TODO Exercise 2.85

*** TODO Exercise 2.86

*** TODO Exercise 2.87

*** TODO Exercise 2.88

*** TODO Exercise 2.89

*** TODO Exercise 2.90

*** TODO Exercise 2.91

*** TODO Exercise 2.92

*** TODO Exercise 2.93

*** TODO Exercise 2.94

*** TODO Exercise 2.95

*** TODO Exercise 2.96

*** TODO Exercise 2.97

** TODO Chapter 3: Modularity, Objects and State [0/82]


*** TODO Exercise 3.1

*** TODO Exercise 3.2

*** TODO Exercise 3.3

*** TODO Exercise 3.4

*** TODO Exercise 3.5

*** TODO Exercise 3.6

*** TODO Exercise 3.7

*** TODO Exercise 3.8

*** TODO Exercise 3.9

*** TODO Exercise 3.10

*** TODO Exercise 3.11

*** TODO Exercise 3.12

*** TODO Exercise 3.13

*** TODO Exercise 3.14

*** TODO Exercise 3.15

*** TODO Exercise 3.16

*** TODO Exercise 3.17

*** TODO Exercise 3.18

*** TODO Exercise 3.19

*** TODO Exercise 3.20

*** TODO Exercise 3.21

*** TODO Exercise 3.22

*** TODO Exercise 3.23

*** TODO Exercise 3.24

*** TODO Exercise 3.25

*** TODO Exercise 3.26

*** TODO Exercise 3.27

*** TODO Exercise 3.28

*** TODO Exercise 3.29

*** TODO Exercise 3.30

*** TODO Exercise 3.31

*** TODO Exercise 3.32

*** TODO Exercise 3.33

*** TODO Exercise 3.34

*** TODO Exercise 3.35

*** TODO Exercise 3.36

*** TODO Exercise 3.37

*** TODO Exercise 3.38

*** TODO Exercise 3.39

*** TODO Exercise 3.40

*** TODO Exercise 3.41

*** TODO Exercise 3.42

*** TODO Exercise 3.43

*** TODO Exercise 3.44

*** TODO Exercise 3.45

*** TODO Exercise 3.46

*** TODO Exercise 3.47

*** TODO Exercise 3.48

*** TODO Exercise 3.49

*** TODO Exercise 3.50

*** TODO Exercise 3.51

*** TODO Exercise 3.52

*** TODO Exercise 3.53

*** TODO Exercise 3.54

*** TODO Exercise 3.55

*** TODO Exercise 3.56

*** TODO Exercise 3.57

*** TODO Exercise 3.58

*** TODO Exercise 3.59

*** TODO Exercise 3.60

*** TODO Exercise 3.61

*** TODO Exercise 3.62

*** TODO Exercise 3.63

*** TODO Exercise 3.64

*** TODO Exercise 3.65

*** TODO Exercise 3.66

*** TODO Exercise 3.67

*** TODO Exercise 3.68

*** TODO Exercise 3.69

*** TODO Exercise 3.70

*** TODO Exercise 3.71

*** TODO Exercise 3.72

*** TODO Exercise 3.73

*** TODO Exercise 3.74

*** TODO Exercise 3.75

*** TODO Exercise 3.76

*** TODO Exercise 3.77

*** TODO Exercise 3.78

*** TODO Exercise 3.79

*** TODO Exercise 3.80

*** TODO Exercise 3.81

*** TODO Exercise 3.82

** TODO Chapter 4: Metalinguistic Abstraction [0/79]

*** TODO Exercise 4.1

*** TODO Exercise 4.2

*** TODO Exercise 4.3

*** TODO Exercise 4.4

*** TODO Exercise 4.5

*** TODO Exercise 4.6

*** TODO Exercise 4.7

*** TODO Exercise 4.8

*** TODO Exercise 4.9

*** TODO Exercise 4.10

*** TODO Exercise 4.11

*** TODO Exercise 4.12

*** TODO Exercise 4.13

*** TODO Exercise 4.14

*** TODO Exercise 4.15

*** TODO Exercise 4.16

*** TODO Exercise 4.17

*** TODO Exercise 4.18

*** TODO Exercise 4.19

*** TODO Exercise 4.20

*** TODO Exercise 4.21

*** TODO Exercise 4.22

*** TODO Exercise 4.23

*** TODO Exercise 4.24

*** TODO Exercise 4.25

*** TODO Exercise 4.26

*** TODO Exercise 4.27

*** TODO Exercise 4.28

*** TODO Exercise 4.29

*** TODO Exercise 4.30

*** TODO Exercise 4.31

*** TODO Exercise 4.32

*** TODO Exercise 4.33

*** TODO Exercise 4.34

*** TODO Exercise 4.35

*** TODO Exercise 4.36

*** TODO Exercise 4.37

*** TODO Exercise 4.38

*** TODO Exercise 4.39

*** TODO Exercise 4.40

*** TODO Exercise 4.41

*** TODO Exercise 4.42

*** TODO Exercise 4.43

*** TODO Exercise 4.44

*** TODO Exercise 4.45

*** TODO Exercise 4.46

*** TODO Exercise 4.47

*** TODO Exercise 4.48

*** TODO Exercise 4.49

*** TODO Exercise 4.50

*** TODO Exercise 4.51

*** TODO Exercise 4.52

*** TODO Exercise 4.53

*** TODO Exercise 4.54

*** TODO Exercise 4.55

*** TODO Exercise 4.56

*** TODO Exercise 4.57

*** TODO Exercise 4.58

*** TODO Exercise 4.59

*** TODO Exercise 4.60

*** TODO Exercise 4.61

*** TODO Exercise 4.62

*** TODO Exercise 4.63

*** TODO Exercise 4.64

*** TODO Exercise 4.65

*** TODO Exercise 4.66

*** TODO Exercise 4.67

*** TODO Exercise 4.68

*** TODO Exercise 4.69

*** TODO Exercise 4.70

*** TODO Exercise 4.71

*** TODO Exercise 4.72

*** TODO Exercise 4.73

*** TODO Exercise 4.74

*** TODO Exercise 4.75

*** TODO Exercise 4.76

*** TODO Exercise 4.77

*** TODO Exercise 4.78

*** TODO Exercise 4.79

** TODO Chapter 5: Computing with Register Machines [0/52]

*** TODO Exercise 5.1

*** TODO Exercise 5.2

*** TODO Exercise 5.3

*** TODO Exercise 5.4

*** TODO Exercise 5.5

*** TODO Exercise 5.6

*** TODO Exercise 5.7

*** TODO Exercise 5.8

*** TODO Exercise 5.9

*** TODO Exercise 5.10

*** TODO Exercise 5.11

*** TODO Exercise 5.12

*** TODO Exercise 5.13

*** TODO Exercise 5.14

*** TODO Exercise 5.15

*** TODO Exercise 5.16

*** TODO Exercise 5.17

*** TODO Exercise 5.18

*** TODO Exercise 5.19

*** TODO Exercise 5.20

*** TODO Exercise 5.21

*** TODO Exercise 5.22

*** TODO Exercise 5.23

*** TODO Exercise 5.24

*** TODO Exercise 5.25

*** TODO Exercise 5.26

*** TODO Exercise 5.27

*** TODO Exercise 5.28

*** TODO Exercise 5.29

*** TODO Exercise 5.30

*** TODO Exercise 5.31

*** TODO Exercise 5.32

*** TODO Exercise 5.33

*** TODO Exercise 5.34

*** TODO Exercise 5.35

*** TODO Exercise 5.36

*** TODO Exercise 5.37

*** TODO Exercise 5.38

*** TODO Exercise 5.39

*** TODO Exercise 5.40

*** TODO Exercise 5.41

*** TODO Exercise 5.42

*** TODO Exercise 5.43

*** TODO Exercise 5.44

*** TODO Exercise 5.45

*** TODO Exercise 5.46

*** TODO Exercise 5.47

*** TODO Exercise 5.48

*** TODO Exercise 5.49

*** TODO Exercise 5.50

*** TODO Exercise 5.51

*** TODO Exercise 5.52

* Footnotes

[fn:1] This exercise took me 7 hours.


#  LocalWords:  vec vect
