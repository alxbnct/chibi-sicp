# -*- mode: org; geiser-scheme-implementation: chibi;  -*-
# Time-stamp: <2019-10-16 17:06:02 lockywolf>
# Created   : [2019-08-18 Sun 20:11]
# Author    : lockywolf gmail.com

#+STARTUP: inlineimages
#+STARTUP: latexpreview
#+HTML_MATHJAX: align: left indent: 5em tagside: left font: Neo-Euler
#+HTML_MATHJAX: cancel.js noErrors.js
#+OPTIONS: tex:imagemagick


* noweb + common
** Setting chibi arguments. DANGEROUS                       :dangerous:elisp:

#+begin_src elisp :export both :results value
(setq geiser-chibi-extra-command-line-parameters
   '("-m" "chibi" "-m" "srfi 159" 
     "-m" "chibi ast" "-m" "chibi time" "-m" "srfi 27" "-m" "chibi process"))
#+end_src

#+RESULTS:
| -m | chibi | -m | chibi show | -m | chibi show pretty | -m | chibi ast | -m | chibi time | -m | srfi 27 |

** Some common code blocks

#+name: common
#+begin_src scheme :results output :exportss none
  (import (chibi ast))
  (import (chibi show))
   (define (disp sexp)
     (display sexp)
     (newline))
#+end_src

#+RESULTS: common

* SICP [38%]
:PROPERTIES:
:header-args: :noweb yes
:END:

** TODO Chapter 1: Building abstractions with procedures [57/61]
*** Snippet
 #+BEGIN_SRC scheme :exports both :results value :session
   (* (+ 2 (* 4 6))
      (+ 3 5 7))
 #+END_SRC

 #+RESULTS:
 : 390

*** Thought
 Tree accumulation is the process of computing a thing by traversing a tree.

*** DONE Figure 1.1 Tree representation, showing the value of each subcombination :graphviz:plantuml:
    CLOSED: [2019-08-20 Tue 14:35]
 For the sake of pedagogical clarity, I have formatted it as a picture.
 #+BEGIN_SRC plantuml :exports both :file figure-1-1-mm.png
 @startmindmap
 skinparam monochrome true
 +_ 390
 ++_ *
 ++_ 26
 +++_ +
 +++_ 2
 +++_ 24
 ++++_ *
 ++++_ 4
 ++++_ 6
 ++_ 15
 +++_ +
 +++_ 3
 +++_ 5
 +++_ 7
 @endmindmap
 #+END_SRC

 #+RESULTS:
 [[file:figure-1-1-mm.png]]

 # Then next line is the same diagram verbose, using DOT.
 #+begin_src plantuml :exports both :file figure-1-1-dot.png
 @startdot
 graph g {
	 node [shape=plaintext];
	 A1 [label="390"];

	 B1 [label="*"];
	 B2 [label="26"];
	 B3 [label="15"];

	 C1 [label="+"];
	 C2 [label="2"];
	 C3 [label="24"];

	 D1 [label="*"];
	 D2 [label="4"];
	 D3 [label="6"];

	 E1 [label="+"];
	 E2 [label="3"];
	 E3 [label="5"];
	 E4 [label="7"];

 // edges
	 A1 -- B1;
	 A1 -- B2;
	 A1 -- B3;
	
	 B2 -- C1;
	 B2 -- C2;
	 B2 -- C3;

	 C3 -- D1;
	 C3 -- D2;
	 C3 -- D3;

	 B3 -- E1;
	 B3 -- E2;
	 B3 -- E3;
	 B3 -- E4;

 //	B1 -> B3 [label="(g o f)'" tailport=s headport=s];

	 { rank=same; A1 }
	 { rank=same; B1 B2 B3 } 
	 { rank=same; C1 C2 C3 }
	 { rank=same; D1 D2 D3 }
	 { rank=same; E1 E2 E3 E4 }
 } 
 @enddot
 #+end_src 

 #+RESULTS:
 [[file:figure-1-1-dot.png]]

*** Snippet
#+name square
#+begin_src scheme :exports both :results value :session
  (define (square x) (* x x))
  (define (sum-of-squares x y)
    (+ (square x) (square y)))
  (sum-of-squares 3 4)
#+end_src

#+RESULTS:
: 25

*** DONE Exercise 1.1 Interpreter result
    CLOSED: [2019-08-20 Tue 14:23]
 #+begin_src scheme :exports both :results output :session
   (define (disp sexp)
     (display sexp)
     (newline))
   (disp 10)
   (disp (+ 2 3 4))
   (disp (- 9 1))
   (disp (/ 6 2))
   (disp (+ (* 2 4) (- 4 6)))
   (define a 3)
   (define b (+ a 1))
   (disp (+ a b (* a b)))
   (disp (= a b))
   (disp
    (if (and (> b a) (< b (* a b )))
	b
	a))
   (disp (cond ((= a 4) 6)
	((= b 4) (+ 6 7 a))
	(else 25)))
   (disp (+ 2 (if (< b a) b a)))
   (disp (* (cond ((> a b) a)
               ((< a b) b)
               (else -1)) 
            (+ a 1)))
 #+end_src

 #+RESULTS:
 #+begin_example
 10
 9
 8
 3
 6
 19
 #f
 4
 16
 5
 16
 #+end_example

*** DONE Exercise 1.2 Prefix form
    CLOSED: [2019-08-20 Tue 14:25]
 #+begin_src scheme :exports both :results value :session
 (/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))
 #+end_src

 #+RESULTS:
 : -37/150

*** DONE Exercise 1.3 Sum of squares
    CLOSED: [2019-08-20 Tue 14:35]
 #+begin_src scheme :exports both :results value :session
 (define (sum-of-squares x y)
   (+ (square x) (square y)))
 (import (srfi 95))
 (define (sum-of-two-max a b c)
   (let ((num_list (sort (list a b c) (lambda (a b) (if (> a b) a b)))))
    (sum-of-squares (car num_list) (cadr num_list))))
 (sum-of-two-max 1 2 3)
 #+end_src

 #+RESULTS:
 : 13

*** DONE Exercise 1.4 Compound expressions
    CLOSED: [2019-08-20 Tue 14:39]
 #+begin_src scheme :exports both :results output :session
 (define (a-plus-abs-b a b)
   ((if (> b 0) + -) a b))
 (disp (a-plus-abs-b  3 4))
 (disp (a-plus-abs-b  3 -4))
 #+end_src

 #+RESULTS:
 : 7
 : 7

*** DONE Exercise 1.5 Ben's test
    CLOSED: [2019-08-20 Tue 14:50]
 #+begin_src scheme :exports both :results value
 (define (p) (p))
 (define (test x y)
   (if (= x 0) 0 y))
 (test 0 (p))
 #+end_src

 On my interpreter this code goes into an infinite recursion, which
 makes sense, I guess, since the second argument to (test) is evaluated
 before executing (test). However, if we only substitute /p/ into the
 application of test and try to traverse the tree depth-first, this
 code should be able to terminate successfully?

*** DONE Exercise 1.6 If is a special form
    CLOSED: [2019-08-21 Wed 14:05]
The problem with this Alyssa's (new-if) is that both arguments would
be computed, so this (new-if) would be either very inefficient or even
not working at all in the case when one of the arguments is
infeasible.
Consider:

#+begin_src scheme :exports both :results output :session
<<common>>
(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
(define a 1)
(define b 0)
(disp (if (not (= b 0)) (/ a b) a))
(new-if (not (= b 0)) (/ a b) a)
#+end_src

#+RESULTS:
: 1
: {Exception #19 user "divide by zero" () #<procedure #f> (#f . 127)}

However, this issue can be solved using scheme macros.

#+begin_src scheme :exports both :results output :session
  <<common>>
  (define-syntax new-if
    (syntax-rules ()
      ( (new-if predicate then-clause else-clause)
	(cond (predicate then-clause)
	      (else else-clause))
      )
    )
  )
  (define a 1)
  (define b 0)
  (disp (if (not (= b 0)) (/ a b) a))
  (disp (new-if (not (= b 0)) (/ a b) a))

#+end_src

#+RESULTS:
: 1
: 1

The code above works as expected, because the macro does not evaluate
its arguments, and (cond) is a special form.

*** DONE Exercise 1.7 Good enough?
    CLOSED: [2019-08-22 Thu 12:52]
This exercise is a very misleading one. On the first glance is seems
that this is just about formulating a good criterion. Make no mistake,
practically solving this task means really writing all this code
carefully.

The function we are interested in is:
\begin{equation}
\label{eq:5}
f(x) = \sqrt{x}
\end{equation}

The code given in the chapter before is equivalent to the following
Newton's method formula, where $f_i$ denotes the next guess:
\begin{equation}
\label{eq:1} 
f_{i+1}_{} = \frac{f_i + \frac{x}{f_i}}{2}
\end{equation}

How on Earth does this formula even appear? Let's remember some
mathematics, namely, the Taylor series (variables unbound):
\begin{equation}
\label{eq:2}
 f(x) = f(x_{0}_{}) + f'(x_{0})(x-x_{0}) + o(x)
\end{equation}

Let us call `true' value of $\sqrt{x}=f$. Let us call our first guess
$f_{0}$. What is the value of the difference (error) between them?
Clearly, $f-f_0$. Well, the problem is — we don't know $f$. But we do
know $f^2$. Therefore $f^2-f^2_0$ is a number we know. What will be the
error on the next step of the algorithm? Let's find $f_1$ as
$f_1=f_0+\delta$. If $\delta$ is not too big, we can use the Taylor
expansion from ref:eq:1 $\delta$.
\begin{equation}
\label{eq:8}
E = f^2 - f_0^2 = f^2 - (f_0 + \delta)^2 \approx f^2 - f_0^2 - 2f_0\delta
\end{equation}


Be careful. What I expanded here is not the function value. It is the
_error_ value. Now, clearly we want our error to be as small as
possible, desirably as little as machine precision would allow. So
assuming $E=0$, we get an equation to solve:
\begin{align}
\label{eq:9}
E=0 \leftrightarrow& f^2-f_0^2-2f_0\delta=0 \\
\delta =& \frac{f_0^2 -f^2 }{2f_0}
\end{align}

Remember though that we don't need just $\delta$ here. We actually need
$f_1$. But $f_1$ is just $f_0+\delta$.
\begin{align}
\label{eq:10}
f_1 = \frac{f^2 - f_0^2}{2f_0} + f_0
\end{align}
Now if you rearrange this formula, you will get exactly the formula
ref:eq:1.

The code below is copied from SICP verbatim and implements the
algorithm above.

#+begin_src scheme :exports both :results value :session :noweb-ref simple-sqrt-iter
  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
	guess
	(sqrt-iter (improve guess x) x)))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results value :noweb-ref square-improve
  (define (improve guess x)
    (average guess (/ x guess)))
#+end_src

#+begin_src scheme :exports both :results value :session :noweb-ref simple-newton-recursion
  (define (good-enough? guess x)
    (< (abs (- (square guess) x)) 0.001))
  <<square-improve>>
  (define (average x y)
    (/ (+ x y) 2))
  (define (sqrt x)
    (sqrt-iter 1.0 x))

#+end_src

#+name simple-newton
#+begin_src scheme :exports both :results value :session
  <<common>>
  <<square>>
  <<simple-sqrt-iter>>
  <<simple-newton-recursion>>
  (sqrt 9)
#+end_src

#+RESULTS:
: 3.00009155413138

An example of how this fails on small numbers:

#+begin_src scheme :exports both :results value
<<simple-newton>>
(square (sqrt 0.0004))
#+end_src

#+RESULTS:
: 0.0012532224857331766

An example of why this fails on big numbers I didn't manage to
craft. Perhaps chibi-scheme has some clever way to deal with rounding?
Anyway — here is the code:
#+begin_src scheme :exports both :results value
  <<simple-newton>>
  (square (sqrt 9999999999.0))
#+end_src

#+RESULTS:
: 9999999999.0

Why exactly this is not very good algorithms is a good question. The
derivative of the square is well-defined near the 0, although the
derivative of the square root is not. Therefore, the equation ref:eq:8
become very imprecise. As we see, big number seem to be working fine
in my scheme implementation.

Let us write a better sqrt-iter?.

#+begin_src scheme :exports both :results value :noweb-ref better-sqrt-iter
  (define (sqrt-iter guess x)
   (let ((better-guess (improve guess x)))
    (if (good-enough? guess (square better-guess))
	better-guess
	(sqrt-iter better-guess x))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref better-newton
<<common>>
<<square>>
<<better-sqrt-iter>>
<<simple-newton-recursion>>
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results value
<<better-newton>>
(square (sqrt 0.0004))
#+end_src

#+RESULTS:
: 0.0005452233379244715

Works faster and gives a better result. Seemingly. QED[fn:1].

*** DONE Exercise 1.8 Newton's method
    CLOSED: [2019-08-22 Thu 17:36]

This exercise is not very hard. The only difference is that the
`improve' function is not derived from a derivative of a square but
rather from a derivative of a cube.


#+name: cube-improve
#+begin_src scheme :exports both :results value
(define (cube-improve guess x)
    (/ (+ (/ x (* guess guess)) (* 2 guess)) 3))
#+end_src

#+RESULTS: cube-improve
: #<undef>

#+name: cube-good-enough
#+begin_src scheme :exports both :results value
(define (cube-good-enough? guess x)
  (< (abs (- (cube guess) x)) 0.001))
#+end_src

#+RESULTS: cube-good-enough
: #<undef>

#+name: cube-root-iter
#+begin_src scheme :exports both :results value
  (define (cube-root-iter guess x)
    (let ((better-guess (cube-improve guess x)))
      (disp better-guess)
      (if (cube-good-enough? better-guess (cube guess))
	  better-guess
	  (cube-root-iter better-guess x))))
#+end_src

#+RESULTS: cube-root-iter
: #<undef>

#+name: cube-simple
#+begin_src scheme :exports both :results output
<<common>>
<<cube>>
<<cube-improve>>
<<cube-good-enough>>
<<cube-root-iter>>
(cube-root-iter 1.0 27.0)
#+end_src

#+RESULTS: cube-simple
: 9.666666666666666
: 6.540758356453956
: 4.570876778578707
: 3.4780192333867963
: 3.0626891086275365
: 3.001274406506175
: 3.0000005410641766
: 3.0000000000000977

*** TODO Figure 1.2 Procedural decomposition of the sqrt program
TODO
*** TODO Figure 1.3 A linear recursive process for computing \(6!\).
TODO
*** TODO Figure 1.4 A linear iterative process for computing \(6!\).
TODO
*** DONE Exercise 1.9 Iterative or recursive? :macro:er_macro_transformer:chicken:
    CLOSED: [2019-08-29 Thu 15:14]

I didn't find (inc) and (dec) in my scheme, so I define them myself.

I still don't want to overload the "+" and "-" symbols, so I will call
them `plus' and `minus'.

#+name: example-substitution-first
#+begin_src scheme :exports both :results value
  (define (inc x)
    (+ 1 x))
  (define (dec x)
    (- x 1))
  (define-syntax plusF
    (er-macro-transformer
     (lambda (form rename compare?)
       (let ((a (cadr form))
	     (b (caddr form)))
n	 (if (= a 0) b `(inc (plusF ,(dec a) ,b)))))))
  (macroexpand '(plusF 4 5))
#+end_src

#+RESULTS: example-substitution-first
| inc | (inc (inc (inc 5))) |

We can see that the macro expander has expanded the computation in to
a tree of length 4. This happens because the algorithm is genuinely
recursive, the return value is not produced by a call to itself, and
therefore recursion cannot be tail-optimized. 

#+name: example-substitution-second
#+begin_src scheme :exports both :results value
  (define (inc x)
    (+ 1 x))
  (define (dec x)
    (- x 1))
  (define-syntax plusS
    (er-macro-transformer
     (lambda (form rename compare?)
       (let ((a (cadr form))
	     (b (caddr form)))
	 (if (= a 0) b `(plusS ,(dec a) ,(inc b)))))))
  (macroexpand '(plusS 4 5))
#+end_src

#+RESULTS: example-substitution-second
: 9


We can clearly see the difference. The first macro is genuinely
recursive, it expands to a series of calls, and needs to keep the
information about this calls on the stack. The second one is actually
iterative. The macro call only happens as the last step, and no
information is kept, as the return value will be just the last result,
so this macro is expanded until it's just a number.

*** DONE Exercise 1.10 Ackermann's function
    CLOSED: [2019-08-25 Sun 18:31]
Let's run the demos first:
#+name: ackerman
#+begin_src scheme :exports both :results output :session
  <<common>>
  (define (A x y)
    (cond ((= y 0.0) 0.0)
	  ((= x 0.0) (* 2.0 y))
	  ((= y 1.0) 2.0)
	  (else (A (- x 1.0) (A x (- y 1.0))))))
  (disp (A 1 10))
  (disp (A 2 4))
  (disp (A 3 3))
#+end_src

#+RESULTS: ackermann
: 1024.0
: 65536.0
: 65536.0

The values of these expressions are listed above.

#+begin_src scheme :exports both :results value :session
  (define (f n) (A 0 n))
  (define (g n) (A 1 n))
  (define (h n) (A 2 n))
  (define (k n) (* 5 n n))
#+end_src

#+RESULTS:
: #<undef>

The mathematical expressions for these formulae are:
\begin{eqnarray}
\label{eq:3}
f(n) & = & 2y\\
g(n) & = & 2^y \\
h(n) & = & 2^{2^n}\\
k(n) & = & 5n^2\\
\end{eqnarray}

Actually this is not the Ackermann's function as it is most often
defined, for example, see
[[http://mathworld.wolfram.com/AckermannFunction.html]]. But the
recurrent relation is the same. This version of the Ackermann's
function seems to be equivalent to the powers tower.

I may have lied with the coefficients, but essentially, the
Ackermann's function with parameters $n$ and $m$ works by applying the
n-the hyperoperator m times to 2. A hyperoperator is a generalization
of the standard matematical operator sequence `+', `*', `^', see
[[https://googology.wikia.org/wiki/Hyper_operator]]

*** TODO Figure 1.5 The tree-recursive process generated in computing (fib 5)
*** DONE Exercise 1.11 Recursive vs iterative
    CLOSED: [2019-08-25 Sun 19:25]

\begin{equation}
\label{eq:4}
f(n)=\left\{
\begin{array}{l@{\quad:\quad}l}
n & n<3\\
f(n-1) + 2f(n-2) + 3f(n-3) & \ge 3
\end{array}\right.
\end{equation}

#+begin_src scheme :exports both :results value :session
    (define (f-recursive n)
      (cond ((< n 3) n)
	    (else
	     (+
	      (f-recursive (- n 1))
	      (* 2 (f-recursive (- n 2)))
	      (* 3 (f-recursive (- n 3)))))))
    (f-recursive 7)
#+end_src

#+RESULTS:
: 142

#+begin_src scheme :exports both :results value :session
  (define (f-iter m n fn-1 fn-2 fn-3)
    (let ((fn (+ fn-1 (* 2 fn-2) (* 3 fn-3))))
      (cond ((= m n) fn)
	     (else (f-iter m (+ n 1) fn fn-1 fn-2)))))

  (define (f-iterative n)
    (cond ((< n 3) n)
	  (else (f-iter n 3 2 1 0))))

  (f-iterative 7)
#+end_src

#+RESULTS:
: 142

*** DONE Exercise 1.12 Recursive Pascal's triangle
    CLOSED: [2019-08-25 Sun 19:42]

\begin{tabular}{rcccccccccc}
 &    &    &    &    &  1\\\noalign{\smallskip\smallskip}
 &    &    &    &  1 &    &  1\\\noalign{\smallskip\smallskip}
 &    &    &  1 &    &  2 &    &  1\\\noalign{\smallskip\smallskip}
 &    &  1 &    &  3 &    &  3 &    &  1\\\noalign{\smallskip\smallskip}
 &  1 &    &  4 &    &  6 &    &  4 &    &  1\\\noalign{\smallskip\smallskip}
 &    &    &    &  . &  . &  . &    &    &   &   \\\noalign{\smallskip\smallskip}
\end{tabular}

#+BEGIN_SRC scheme
    (define (pascal-number line-number column-number)
      (cond ((= line-number 1) 1)
	    ((= line-number 2) 1)
	    ((= column-number 1) 1)
	    ((= column-number line-number) 1)
	    (else (+
		   (pascal-number (- line-number 1) (- column-number 1))
		   (pascal-number (- line-number 1) column-number)))))
    (pascal-number 5 3)
#+END_SRC

#+RESULTS:
: 6

*** DONE Exercise 1.13 Fibonacci
    CLOSED: [2019-08-25 Sun 23:04]

\begin{equation}
\label{eq:6}
\mbox{Fib}(n)=\left\{ 
\begin{array}{l@{\quad:\quad}l}
0 & n=0\\
1 & n=1\\
\mbox{Fib}(n-1) + \mbox{Fib}(n-2) & \mbox{otherwise}}
\end{array}\right.
\end{equation}

Abelson and Sussman define \(\varphi=(1+\sqrt{5})/2\) and \(\psi=(1-\sqrt{5})/2\).

Knowing that \( \mbox{Fib}(n) = (\varphi^{n} - \psi^n)/\sqrt{5}\) is almost all the
problem done, because \(\psi\) is clearly less than \(1\), so for large
\(n\) it will be exponentially close to \(0\), and this is where the
``closest integer'' comes from.

Let us prove the rest by induction.
\begin{eqnarray}
\label{eq:13}
\frac{\varphi^{n-1} - \psi^{n-1} + \varphi^{n-2} - \psi^{n-2}}{\sqrt{5}} &=& \frac{\varphi^{n} - \psi^{n}}{\sqrt{5}}\\
\varphi^{n-1} - \psi^{n-1} + \varphi^{n-2} - \psi^{n-2} &=& \varphi^{n} - \psi^{n} \\
(\varphi + 1)\varphi^{n-2} - (\psi + 1)\psi^{n-2} &=&  \varphi^{n} - \psi^{n}\\
(\varphi + 1 - \varphi^2)\varphi^{n-2} &=&  (\psi + 1 - \psi^2)\psi^{n-2}\\
(\frac{1+\sqrt{5}}{2} + 1 - (\frac{1+\sqrt{5}}{2})^2)\varphi^{n-2} &=&
(\frac{1-\sqrt{5}}{2} + 1 - (\frac{1-\sqrt{5}}{2}))\psi^{n-2} \\
(\frac{2+2\sqrt{5}}{4} + \frac{4}{4} - \frac{1+2\sqrt{5}+5}{4})\varphi^{n-2} &=&
(\frac{2-2\sqrt{5}}{4} + \frac{4}{4} - \frac{1-2\sqrt{5}+5}{4})\psi^{n-2}\\
0&=&0
\end{eqnarray}

This proves that the recurrent relation for \(\frac{\varphi^n-\psi^n}{\sqrt{5}}\) is the
same as for the Fibonacci sequence. Then if we prove that there exist
such \(n\) and \(n-1\) so that \(\mbox{Fib}(n) =
\frac{\varphi^n-\psi^n}{\sqrt{5}}\), then we're done.

Indeed, let's have a look at \(n=1\): \(\frac{1+\sqrt{5}}{2
\sqrt{5}} - \frac{1-\sqrt{5}}{2 \sqrt{5}} = 1\); and \(n=0\): \(
\frac{1-1}{\sqrt{5}} = 0\).

*** DONE Exercise 1.14 count-change              :macro:er_macro_transformer:
    CLOSED: [2019-08-30 Fri 16:09]

Let us use the non-standard but common er-macro-transformer to plot
the execution tree.

#+begin_src scheme :exports both :results output
  (define-syntax cc
    (er-macro-transformer
     (lambda (form rename compare?)
       (let ((amount (cadr form))
	     (kinds-of-coins (caddr form)))
	 (cond ((= amount 0) 1)
	       ((or (< amount 0) (= kinds-of-coins 0)) 0)
	       (`(+ (cc ,amount
			,(- kinds-of-coins 1))
		    (cc ,(- amount
			    (first-denomination
			     kinds-of-coins))
			,kinds-of-coins))))))))
  (define (first-denomination kinds-of-coins)
    (cond ((= kinds-of-coins 1) 1)
	  ((= kinds-of-coins 2) 5)
	  ((= kinds-of-coins 3) 10)
	  ((= kinds-of-coins 4) 25)
	  ((= kinds-of-coins 5) 50)))
(show #t " "(pretty (macroexpand '(cc 11 5))))
#+end_src

#+RESULTS:
:  (+
:   (+
:    (+
:     (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 1)))))))))))
:        (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 1)))))) (+ (+ 0 1) 0)))
:     (+ (+ (+ 0 1) 0) 0))
:    0)
:   0)

Initially I wrote the same code in Emacs Lisp, I am leaving it here
for future reference.

#+begin_src elisp :exports both :results output
    (defmacro cc (amount kinds-of-coins)
      (cond ((= amount 0) 1)
	    ((or (< amount 0) (= kinds-of-coins 0)) 0)
	    (`(+ (cc ,amount
		    ,(- kinds-of-coins 1))
		(cc ,(- amount
		       (first-denomination
			kinds-of-coins))
		    ,kinds-of-coins)))))
  (defun first-denomination (kinds-of-coins)
    (cond ((= kinds-of-coins 1) 1)
	  ((= kinds-of-coins 2) 5)
	  ((= kinds-of-coins 3) 10)
	  ((= kinds-of-coins 4) 25)
	  ((= kinds-of-coins 5) 50)))
  (pp (macroexpand-all '(cc 11 5)))

#+end_src

#+RESULTS: ?
#+begin_example
(+
 (+
  (+
   (+
    (+ 0
       (+ 0
	  (+ 0
	     (+ 0
		(+ 0
		   (+ 0
		      (+ 0
			 (+ 0
			    (+ 0
			       (+ 0
				  (+ 0 1)))))))))))
    (+
     (+ 0
	(+ 0
	   (+ 0
	      (+ 0
		 (+ 0
		    (+ 0 1))))))
     (+
      (+ 0 1)
      0)))
   (+
    (+
     (+ 0 1)
     0)
    0))
  0)
 0)
#+end_example

The space complexity of the algorithm will be dominated by the depth
of the tree — that is the value to be changed, as there is no need to
keep any additional information.

The time complexity can be estimated as follows: for every additional
value the algorithm will have to go through all passes of the
algorithm without an additional denomination, times the amount divided
by the value of an additional denomination. We can consider the
additional denomination value as a constant, and the amount of steps
for the simplest case of only one denomination is the
amount. Therefore, the algorithm is linear in amount and exponential
in the number of denominations.

\begin{equation}
\label{eq:14}
C = \Theta(n^a)
\end{equation}

*** I found a bug in ob-scheme while doing this Exercise.
 _In process I have found a bug in org-babel!_
#+begin_src scheme :exports both :results output
(display "(+ 0) ")
#+end_src

#+RESULTS:
: 0

#+begin_src scheme :exports both :results output
(display "(+ 0)")
#+end_src

#+RESULTS:
| + | 0 |

(org-babel-script-escape "(+ 0)") (org-babel-script-escape "(+ 0) ")

*** DONE Exercise 1.15 sine                      :macro:er_macro_transformer:
    CLOSED: [2019-08-30 Fri 22:34]

First let us code this thing:

Loop version:

#+begin_src scheme :exports both :results output
  (define niter 0)
  (define (cube x) (* x x x))
  (define (p x)
    (set! niter (+ niter 1))
    (- (* 3 x) (* 4 (cube x))))
  (define (sine angle)
    (if (not (> (abs angle) 0.1))
	angle
	(p (sine (/ angle 3.0)))))
  (display "sine=" )
  (display (sine 12.15))
  (display " niter=")
  (display niter)
#+end_src

#+RESULTS:
: sine=-0.39980345741334 niter=5

Let's have the macro system expand this for us.

#+begin_src scheme :exports both :results output
  (define (cube x)
    (* x x x))
  (define (p x)
    (- (* 3  x)
       (* 4 (cube x))))
  (define-syntax sine
    (er-macro-transformer
     (lambda (form rename compare?)
       (let ((a (cadr form)))
	 (if (< (abs a) 0.1)
	     a
	     `(p (sine ,(/ a 3))))))))
  (show #t " " (pretty (macroexpand '(sine 12.15))))

#+end_src

#+RESULTS:
:  (p (p (p (p (p 0.05)))))

Theoretically, we can expand everything at once. 

#+begin_src scheme :exports both :results output
  (define-syntax cube
    (er-macro-transformer
     (lambda (form rename compare?)
       (let ((x (cadr form)))
	 `(* ,x ,x ,x)))))
  (define-syntax p
    (er-macro-transformer
     (lambda (form rename compare?)
       (let ((x (cadr form)))
	 `(- (* 3 ,x)
	     (* 4 (cube ,x)))))))
  (define-syntax sine
    (er-macro-transformer
     (lambda (form rename compare?)
       (let ((a (cadr form)))
	 (if (< (abs a) 0.1)
	     a
	     `(p (sine ,(/ a 3))))))))
  (show #t " " (pretty (macroexpand '(sine 12.15))))
#+end_src

#+RESULTS:
#+begin_example
 (-
  (* 3
     (-
      (* 3
         (-
          (* 3
             (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                (* 4
                   (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                      (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                      (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
          (* 4
             (*
              (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                 (* 4
                    (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
              (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                 (* 4
                    (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
              (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                 (* 4
                    (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))))))
      (* 4
         (*
          (-
           (* 3
              (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                 (* 4
                    (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
           (* 4
              (*
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))))
          (-
           (* 3
              (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                 (* 4
                    (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
           (* 4
              (*
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))))
          (-
           (* 3
              (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                 (* 4
                    (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
           (* 4
              (*
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))))))))
  (* 4
     (*
      (-
       (* 3
          (-
           (* 3
              (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                 (* 4
                    (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
           (* 4
              (*
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))))))
       (* 4
          (*
           (-
            (* 3
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
            (* 4
               (*
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))))
           (-
            (* 3
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
            (* 4
               (*
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))))
           (-
            (* 3
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
            (* 4
               (*
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))))))))
      (-
       (* 3
          (-
           (* 3
              (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                 (* 4
                    (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
           (* 4
              (*
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))))))
       (* 4
          (*
           (-
            (* 3
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
            (* 4
               (*
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))))
           (-
            (* 3
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
            (* 4
               (*
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))))
           (-
            (* 3
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
            (* 4
               (*
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))))))))
      (-
       (* 3
          (-
           (* 3
              (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                 (* 4
                    (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                       (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
           (* 4
              (*
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))))))
       (* 4
          (*
           (-
            (* 3
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
            (* 4
               (*
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))))
           (-
            (* 3
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
            (* 4
               (*
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))))
           (-
            (* 3
               (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                  (* 4
                     (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                        (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))
            (* 4
               (*
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))))
                (- (* 3 (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05))))
                   (* 4
                      (* (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))
                         (- (* 3 0.05) (* 4 (* 0.05 0.05 0.05)))))))))))))))
#+end_example

As seen from the code above, the amount of steps is 5. It is easily
seen from the fact that the application of ~p~ starts when *x* is
sufficiently small, and that requires \(0.1 > 12.15\cdot(\frac{1}{3})^n \Rightarrow n
= O(\log_3 121.5)\) steps.

~(sine x)~ is expandable in constant space and time, ~(cube x)~ is
expandable in constant space and time if multiplication is an
elementary operation. Therefore the only operation left is
~p~. Therefore, time and space are of equal order of magnitude.

 - \(\left\lceil \log_3 121.5 \right\rceil = 5\)
 - \(O(\ln(a\cdot b))\) where \(a\) is the angle and \(b\) is precision

*** DONE Exercise 1.16 Iterative exponentiation
    CLOSED: [2019-08-30 Fri 23:20]

For the start, let's input the code.

#+begin_src scheme :exports both :results value
  (define (expt b n)
    (if (= n 0)
	1
	(* b (expt b (- n 1)))))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results value
  (define (expt b n)
    (expt-iter b n 1))
  (define (expt-iter b counter product)
    (if (= counter 0)
	product
	(expt-iter b
		   (- counter 1)
		   (* b counter product))))
#+end_src

#+begin_src scheme :exports both :results value
  (define (fast-expt b n)
    (cond ((= n 0) 1)
	  ((even? n) (square (fast-expt b (/ n 2))))
	  (else (* b (fast-expt b (- n 1))))))
  (define (even? n)
    (= (remainder n 2) 0))
  (fast-expt 2 10)
#+end_src

#+RESULTS:
: 1024

#+begin_src scheme :exports both :results value
    (define (fast-expt b n a)
      (cond ((= n 0) a)
	    ((even? n)  (fast-expt (square b) (/ n 2) a))
	    (else (fast-expt b (- n 1) (* a b)))))
    (define (even? n)
      (= (remainder n 2) 0))
    (define (faster-expt b n)
      (fast-expt b n 1))
    (faster-expt 2 10)
#+end_src

#+RESULTS:
: 1024

The answer is the code block above. We just collect some data and put
it into the state variable *a*.

*** DONE Exercise 1.17 Fast multiplication
    CLOSED: [2019-08-30 Fri 23:48]
#+begin_src scheme :exports both :results value
  (define (double a)
    (* 2 a))
  (define (halve a)
    (if (even? a)
	(/ a 2)
	(raise "Error: a not even.")))
  (define (even? n)
	(= (remainder n 2) 0))
  (define (* a b)
    (cond 
     ((= b 0) 0)
     ((even? b) (double (* a (halve b))))
     (else (+ a (* a (- b 1))))))
  (* 137 17)
#+end_src

#+RESULTS:
: 2329

The procedure above uses logarithmic time and space, because for every
subtraction there is also at least one division, so the total
convergence speed is exponential. This could be reformulated as an
iterative procedure, with an accumulator variable, but I am too lazy.

*** DONE Exercise 1.18 Iterative multiplication
    CLOSED: [2019-08-31 Sat 11:43]

In Exercise 1.17 I said that I was too lazy to design an iterative
procedure. Well, now I do it in this exercise.

#+begin_src scheme :exports both :results value
  (define (double a)
    (* 2 a))
  (define (halve a)
    (if (even? a)
	(/ a 2)
	(raise "Error: a not even.")))
  (define (even? n)
	(= (remainder n 2) 0))
  (define (mul a b accumulator)
    (cond 
     ((= b 0) accumulator)
     ((even? b) (mul (double a) (halve b)))
     (else (mul a (- b 1) (+ a accumulator)))))
  (* 137 17)
#+end_src

#+RESULTS:
: 2329

The idea here is exactly the same as in the previous Exercise 1.18.

*** DONE Exercise 1.19 Logarithmic Fibonacci
    CLOSED: [2019-09-01 Sun 20:42]

As usualy, let's first copy the code of ~fib-iter~.

#+begin_src scheme :exports both :results value
  (define (fib n)
    (fib-iter 1 0 n))
  (define (fib-iter a b count)
    (if (= count 0)
	b
	(fib-iter (+ a b) a (- count 1))))
  (fib 10)
#+end_src

#+RESULTS:
: 55

The formula for \(T\) is the following:

\begin{eqnarray}
T_{pq} \begin{pmatrix} a\\ b \end{pmatrix} & = & \begin{pmatrix} aq+bq+ap \\ bp + aq \end{pmatrix} &\\ 
T_{pq} \left( T_{pq} \begin{pmatrix} a\\ b \end{pmatrix} \right) & = & \begin{pmatrix} (aq+bq+ap)q+(bp + aq)q+(aq+bq+ap)p \\ (bp + aq)p + (aq+bq+ap)q \end{pmatrix} &\\
T_{p'q'}\begin{pmatrix} a\\ b \end{pmatrix} & = & \begin{pmatrix}a(2pq + qq) + a(pp+qq) + b(2pq + qq)\\ a(2pq + qq) + b(pp + qq) \end{pmatrix}& \\
\end{eqnarray}
From here we can easily see the values for \(p\prime\) and \(q'\):
# \(a(2pq + qq) + a(pp+qq) + b(2pq + qq)\)
# \(a(2pq + qq) + b(pp + qq)\)

\(p'=pp+qq\), \(q' = 2pq+qq\)

Let us substitute them into the code given by Abelson and Sussman.

#+begin_src scheme :exports both :results value
  (define (fib n)
    (fib-iter 1 0 0 1 n))
  (define (fib-iter a b p q count)
    (cond ((= count 0) b)
	  ((even? count)
	   (fib-iter a
		     b
		     (+ (* p p) (* q q))
		     (+ (* 2 p q) (* q q))
		     (/ count 2)))
	  (else (fib-iter (+ (* b q) (* a q) (* a p))
			  (+ (* b p) (* a q))
			  p
			  q
			  (- count 1)))))
  (fib 10)
#+end_src

#+RESULTS:
: 55

Works.

*** *Interjection* ir-macro-transformer.

#+begin_src scheme :exports both :results value
  (define-syntax swap!
    (ir-macro-transformer
     (lambda (form inject compare?)
       (let ((a (cadr form))
	     (b (caddr form))
	     (tmp (cadr form)))
	     (set! a b)
	     (set! b tmp)))))
  (define x 4)
  (define y 5)
  (swap! x y)
  (list x y)
#+end_src

#+RESULTS:
: "{Exception #19 user \"undefined variable\" (ir-macro-transformer) #<procedure #f> (#f . 3)}"

*** DONE Exercise 1.20 GCD applicative vs normal :er_macro_transformer:macro:
    CLOSED: [2019-09-01 Sun 23:04]
The exercise urges us to recall the difference between the normal
order and the applicative order of evaluation.

 *Normal*: fully expand the computation tree until obtained an
expression involving only primitive operators.

 *Applicative*: evaluate the arguments and then apply.

First let us print the execution tree of the normal order.
#+begin_src scheme :exports both :results output
    (define-syntax gcd-normal
      (er-macro-transformer
       (lambda (form rename compare?)
	 (let ((a (cadr form))
	       (b (caddr form)))
	   (if (= b 0)
		`(if (= ,b 0)
                     ,a
                     (remainder ,a ,b))
		`(if (= ,b 0)
		     (,a (remainder ,a ,b))
		     (gcd-normal ,b ,(remainder a b))))))))
      (display (show #f " " (pretty (macroexpand '(gcd-normal 206 40)))))
#+end_src

#+RESULTS:
:  (if (= 40 0)
:      (206 (remainder 206 40))
:      (if (= 6 0)
:          (40 (remainder 40 6))
:          (if (= 4 0)
:              (6 (remainder 6 4))
:              (if (= 2 0) (4 (remainder 4 2)) (if (= 0 0) 2 (remainder 2 0))))))

Now let us show the applicative order.
#+begin_src scheme :exports both :results output
    (define-syntax gcd-normal
      (er-macro-transformer
       (lambda (form rename compare?)
	 (let ((a (cadr form))
	       (b (caddr form)))
	   (if (= b 0)
		`(if (= ,b 0)
                     ,a
                     'division-by-zero)
		`(if (= ,b 0)
		     (,a (remainder ,a ,b))
		     (gcd-normal ,b ,(remainder a b))))))))
      (display (show #f " " (pretty (macroexpand '(gcd-normal 206 40)))))
#+end_src

#+RESULTS:
:  (if (= 40 0)
:      (206 (remainder 206 40))
:      (if
:       (= 6 0)
:       (40 (remainder 40 6))
:       (if (= 4 0)
:           (6 (remainder 6 4))
:           (if (= 2 0) (4 (remainder 4 2)) (if (= 0 0) 2 'division-by-zero)))))

The problem here would arise, if the ~(if)~ form had a normal
evaluation order, because the last division, ~(remainder 2 0)~ may be
a forbidden operation, involving a division by zero. On the other
hand, the evaluation of ~(remainder x 0)~ could be defined as *x*, and
then the algorithm would evaluate one more (useless) remainder.

*** DONE Exercise 1.21 smallest-divisor
    CLOSED: [2019-09-01 Sun 23:43]

As usual, let us first copy the code for the ~smallest-divisor~.

#+begin_src scheme :exports both :results output :noweb-ref primetest
  (define (smallest-divisor n)
    (find-divisor n 2))
  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
	  ((divides? test-divisor n) test-divisor)
	  (else (find-divisor n (+ test-divisor 1)))))
  (define (divides? a b) (= (remainder b a) 0))

  (define (prime? n)
    (= n (smallest-divisor n)))
#+end_src

#+begin_src scheme :exports both :results output
  <<primetest>>
  (display (smallest-divisor 199))
  (newline)
  (display (smallest-divisor 1999))
  (newline)
  (display (smallest-divisor 19999))
  (newline)
  (display (/ 19999 7))
  (newline)
#+end_src

#+RESULTS:
: 199
: 1999
: 7
: 2857

Well, this problem doesn't look too complicated on the first glance.

*** DONE Exercise 1.22 timed-prime-test
    CLOSED: [2019-09-02 Mon 00:44]

#+begin_src scheme :exports both :results output :noweb-ref timed-primetest
  (define (runtime) (* 1000 (current-second)))

  (define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (runtime)))

  (define (start-prime-test n start-time)
    (if (prime? n)
	(report-prime (- (runtime) start-time))))

  (define (report-prime elapsed-time)
    (display " *** ")
    (display elapsed-time))
  (define (search-for-primes start finish)
    (timed-prime-test start)
    (if (< (+ 1 start) finish)
	(if (even? start)
	    (search-for-primes (+ start 1) finish)
	    (search-for-primes (+ start 2) finish))))
#+end_src

#+begin_src scheme :exports both :results output
  <<primetest>>
  <<timed-primetest>>
  (search-for-primes 1000 1020)
  (newline)
  (search-for-primes 10000 10038)
  (newline)
  (search-for-primes 100000 100044)
  (newline)
  (search-for-primes 1000000 1000038)
#+end_src

#+RESULTS:
#+begin_example

1000
1001
1003
1005
1007
1009 *** 0.006103515625
1011
1013 *** 0.005859375
1015
1017
1019 *** 0.005859375

10000
10001
10003
10005
10007 *** 0.016845703125
10009 *** 0.016845703125
10011
10013
10015
10017
10019
10021
10023
10025
10027
10029
10031
10033
10035
10037 *** 0.016845703125

100000
100001
100003 *** 0.052978515625
100005
100007
100009
100011
100013
100015
100017
100019 *** 0.052978515625
100021
100023
100025
100027
100029
100031
100033
100035
100037
100039
100041
100043 *** 0.052001953125

1000000
1000001
1000003 *** 0.163818359375
1000005
1000007
1000009
1000011
1000013
1000015
1000017
1000019
1000021
1000023
1000025
1000027
1000029
1000031
1000033 *** 0.1650390625
1000035
1000037 *** 0.1640625
#+end_example

 - Write the procedure: done.
 - Find the smallest three primes greater than 1000   : found.
 - Find the smallest three primes greater than 10000  : found.
 - Find the smallest three primes greater than 100000 : found.
 - Find the smallest three primes greater than 1000000: found.
 - The timing data confirms the prediction. \(\sqrt{10}\approx3\), \(0.16 \approx 3\cdot1.05\).
 - The execution time per step for testing 1.000.000 is 1.63e-07. The
   execution time per step for testing 100.000 5.3199e-07. At least on
   my machine the claim doesn't seem to hold very well.

*** DONE Exercise 1.23 (next test-divisor)
    CLOSED: [2019-09-02 Mon 09:56]

#+begin_src scheme :exports both :results value :noweb-ref improved-primetest
  (define (next x)
    (if (= 2 x)
	3
	(+ x 2)))
  (define (smallest-divisor n)
    (find-divisor n 2))
  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
	  ((divides? test-divisor n) test-divisor)
	  (else (find-divisor n (next test-divisor)))))
  (define (divides? a b) (= (remainder b a) 0))

  (define (prime? n)
    (= n (smallest-divisor n)))

#+end_src

#+begin_src scheme :exports both :results output
<<improved-primetest>>
<<timed-primetest>>
(timed-prime-test 1009)
(timed-prime-test 1013)
(timed-prime-test 1019)
(timed-prime-test 10007)
(timed-prime-test 10009)
(timed-prime-test 10037)
(timed-prime-test 100003)
(timed-prime-test 100019)
(timed-prime-test 100043)
(timed-prime-test 1000003)
(timed-prime-test 1000033)
(timed-prime-test 1000037)

#+end_src

#+RESULTS:
#+begin_example

1009 *** 0.010009765625
1013 *** 0.00390625
1019 *** 0.00390625
10007 *** 0.010009765625
10009 *** 0.010009765625
10037 *** 0.010009765625
100003 *** 0.031005859375
100019 *** 0.03076171875
100043 *** 0.030029296875
1000003 *** 0.10205078125
1000033 *** 0.104736328125
1000037 *** 0.10205078125
#+end_example

We can see that the test does show a speed improvement, although not
as impressive as 2 times. We can observe that the number of steps is
not really halved, since ~(+ a b)~ requires one operation, and ~(if (=
2 x) 3 else (+ 3 2))~ requires three operations, so the speed should
improve by 3/2, which we can observe.

*** DONE Exercise 1.24 Fermat method
    CLOSED: [2019-09-02 Mon 11:32]

Firstly we need the ~(fast-prime?)~ procedure.

#+begin_src scheme :exports both :results value :noweb-ref random
(define (random x)
  (random-integer x))
#+end_src

#+RESULTS:
: 30

#+begin_src scheme :exports both :results value :noweb-ref expmod
  (define (expmod base exp m)
    (cond ((= exp 0) 1)
	  ((even? exp)
	   (remainder
	    (square (expmod base (/ exp 2) m))
	    m))
	  (else
	   (remainder
	    (* base (expmod base (- exp 1) m))
	    m))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref fermat-primetest
<<random>>
  (define (fermat-test n)
    (define (try-it a)
      (= (expmod a n n) a))
    (try-it (+ 1 (random (- n 1)))))
  (define prime-test fermat-test)
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref fast-prime
  (define (fast-prime? n times)
    (cond ((= times 0) true)
	  ((prime-test n) (fast-prime? n (- times 1)))
	  (else false)))
  (define true #t)
  (define false #f)
  (define (prime? x)
    (fast-prime? x 10))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results output
<<expmod>>
<<fermat-primetest>>
<<fast-prime>>
<<timed-primetest>>
(timed-prime-test 1009)
(timed-prime-test 1013)
(timed-prime-test 1019)
(timed-prime-test 10007)
(timed-prime-test 10009)
(timed-prime-test 10037)
(timed-prime-test 100003)
(timed-prime-test 100019)
(timed-prime-test 100043)
(timed-prime-test 1000003)
(timed-prime-test 1000033)
(timed-prime-test 1000037)
(timed-prime-test 1000)
(timed-prime-test 6601)
#+end_src

#+RESULTS:
#+begin_example

1009 *** 0.0830078125
1013 *** 0.057861328125
1019 *** 0.060791015625
10007 *** 0.072998046875
10009 *** 0.071044921875
10037 *** 0.07275390625
100003 *** 0.083251953125
100019 *** 0.0849609375
100043 *** 0.085693359375
1000003 *** 0.09521484375
1000033 *** 0.09619140625
1000037 *** 0.09814453125
1000
6601 *** 0.0478515625
#+end_example

Firstly, observe that the interpreter seems to be doing some black magic, so
that the test for 1009 takes more time than the test for 1013.

Secondly, observe that indeed, the speed seems to have reduced its dependence
on the length of a number, and if we want to test even bigger numbers, the
dependency should become even smaller, as \(\log(n)\) grows very slowly. In
particular, comparing the range around 1000 and 1000.000, the ratio of
\(\frac{\log_{10}(1000000)}{\log_{10}(1000)} = \frac{6}{3} = 2\). This doesn't seem
to be completely the case, but hey, there may be some constants involved, as
well as some interpreter dark magic.

*** DONE Exercise 1.25 expmod
    CLOSED: [2019-09-02 Mon 12:46]

Well, in principle, Alyssa's algorithm should work. The problem here really
is that we would have to store the number \(a^n\), which is a very big number,
especially because we are interested in testing primality of very large
numbers (e.g., 512-bit long cryptography keys), and \((2^{256-1})^{2^{256}}\)
is a very large number.

*** DONE Exercise 1.26 square vs mul
    CLOSED: [2019-09-02 Mon 12:50]

The hint here lies in the name of the person helping Louis. Eva Lu Ator
sounds similar to "evaluator", and the reason for Louis's problem really lies
in the optimization capabilities of the interpreter. That is, if the
evaluating algorithm uses applicative order, then the ~expmod~ is evaluated
twice per step, which makes ~(/ exp 2)~ useless. If, however, the interpreter
can memoize the results, his algorithm would be just as good.

*** DONE Exercise 1.27 Carmichael numbers
    CLOSED: [2019-09-02 Mon 20:50]

First let us recall some Carmichael numbers.

| # |      |
|---+------|
| 1 |  561 |
| 2 | 1105 |
| 3 | 1729 |
| 4 | 2465 |
| 5 | 2821 |
| 6 | 6601 |

We already have a procedure that computes \(a^n\mod n\), and a procedure that
computes \(a\mod n\) is even a scheme primitive. Moreover, we even have all
the code that does the comparison, with the single difference - our existing
code takes an initial guess uniformly at random, whereas we need to check all
\( a < n\).

#+begin_src scheme :exports both :results output
<<expmod>>
  (define (congruent? a n)
    (= (expmod a n n) a))
  (define (carmichael-iter a n)
    (cond ((= a n) #t)
	  ((not (congruent? a n)) #f)
	  (else (carmichael-iter (+ 1 a) n))))
  (define (carmichael-or-prime? n)
    (carmichael-iter 1 n))
  (define (test-carmichael n)
    (display "Testing ")
    (display n)
    (display ": ")
    (if (carmichael-or-prime? n)
      (display "true")
      (display "false"))
    (newline))
  (test-carmichael 561)
  (test-carmichael 1105)
  (test-carmichael 1729)
  (test-carmichael 2465)
  (test-carmichael 2821)
  (test-carmichael 6601)
  (test-carmichael 20)
  (test-carmichael 7)
#+end_src

#+RESULTS:
: Testing 561: true
: Testing 1105: true
: Testing 1729: true
: Testing 2465: true
: Testing 2821: true
: Testing 6601: true
: Testing 20: false
: Testing 7: true

*** DONE Exercise 1.28 Miller-Rabin
    CLOSED: [2019-09-02 Mon 23:28]
#+begin_src scheme :exports both :results value :noweb-ref expmod-miller-rabin
  (define (expmod base exp m)
    (cond ((= exp 0) 1)
	  ((even? exp)
	   (let* ((root (expmod base (/ exp 2) m))
		  (sq (square root)))
	     (if (and (= (remainder sq m) 1) (not (or (= root 1) (= root (- m 1)))))
	      0
	      (remainder sq m))))
	  (else
	   (remainder
	    (* base (expmod base (- exp 1) m))
	    m))))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results value :noweb-ref miller-rabin-primetest
    <<random>>
      (define (rabin-test n)
	(define (try-it a)
	  (let ((result (expmod a (- n 1) n) ))
	    (if (or (= 1 result)  (= n 1) (= n 0))
	    #t
	    #f)))
	(if (not (= n 1)) (try-it (+ 1 (random (- n 1)))) #t))
      (define prime-test rabin-test)

#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results output :noweb-ref rabin-prime
<<expmod-miller-rabin>>
<<miller-rabin-primetest>>
<<fast-prime>>
<<timed-primetest>>
#+end_src

#+RESULTS:

#+begin_src scheme :exports both :results output
<<rabin-prime>>
(timed-prime-test 1009)
(timed-prime-test 1013)
(timed-prime-test 1019)
(timed-prime-test 10007)
(timed-prime-test 10009)
(timed-prime-test 10037)
(timed-prime-test 100003)
(timed-prime-test 100019)
(timed-prime-test 100043)
(timed-prime-test 1000003)
(timed-prime-test 1000033)
(timed-prime-test 1000037)
(timed-prime-test 1000)
(timed-prime-test 6601)

#+end_src

#+RESULTS:
#+begin_example

1009 *** 0.09716796875
1013 *** 0.086669921875
1019 *** 0.087158203125
10007 *** 0.1220703125
10009 *** 0.113037109375
10037 *** 0.113037109375
100003 *** 0.130859375
100019 *** 0.133056640625
100043 *** 0.132080078125
1000003 *** 0.151123046875
1000033 *** 0.172119140625
1000037 *** 0.156982421875
1000
6601
#+end_example

I used the ~(let)~ construction introduced in the later chapters, because I
find bindings with nested procedures confusing.

*** DONE Exercise 1.29 Simpson's integral
    CLOSED: [2019-09-03 Tue 10:36]

Since at the end of the task we are told to compare the result of our
algorithm with the results of the ~integral~ procedure, let us first copy the
integral code.

#+begin_src scheme :exports both :results value :noweb-ref integral-common
  (define (sum term a next b)
    (if (> a b)
	0
	(+ (term a)
	   (sum term (next a) next b))))
  (define (cube x)
    (* x x x))
  (define (next point)
    (+ point 1))
#+end_src

#+begin_src scheme :exports both :results value 
<<integral-common>>
  (define (integral f a b dx)
    (define (add-dx x)
      (+ x dx))
    (* (sum f (+ a (/ dx 2.0)) add-dx b)
       dx))
  (list (integral cube 0 1 0.01) (integral cube 0 1 0.001))

#+end_src

#+RESULTS:
| 0.24998750000000053 | 0.24999987500000106 |

#+begin_src scheme :exports both :results output
  <<integral-common>>
  (define (integral-simpson f a b npoints)
    (define h (/ (- b a) npoints))
    (define h/3 (/ h 3))
    (define (f_k k)
      (* (f (+ a (* k h))) (cond ((= k 0) 1)
				 ((= k npoints) 1)
				 ((odd? k) 4)
				 ((even? k) 2))))
    (* h/3 (sum f_k 0 next npoints)))
  (display (integral-simpson cube 0 1 100))
  (newline)
  (display (integral-simpson cube 0 1 1000))
#+end_src

#+RESULTS:
: 1/4
: 1/4

An impressive result. I don't know at which point of the computation the
interpreter switches to an exact representation, but meh, this result is good.

*** DONE Exercise 1.30 Iterative sum
    CLOSED: [2019-09-03 Tue 11:19]

#+begin_src scheme :exports both :results output
  (define (inc x) (+ x 1))
  (define (identity x) x)
  (define (sum term a next b)
    (define (iter a result)
      (if (= a b)
	  (+ a result)
	  (iter (next a) (+ a result))))
    (iter a 0))

  (sum identity 1 inc 10)

#+end_src

#+RESULTS:
: 55

*** DONE Exercise 1.31 Product
    CLOSED: [2019-09-03 Tue 11:59]
**** DONE a. Defining product
     CLOSED: [2019-09-03 Tue 11:56]
 #+begin_src scheme :exports both :results value
   (define (inc x) (+ x 1))
   (define (identity x) x)
   (define (product term a next b)
     (define (iter a result)
       (if (= a b)
	   (* (term a) result)
	   (iter (next a) (* (term a) result))))
     (iter a 1.0))
   (define (factorial x) (product identity 1 inc 6))
   (factorial 6)
   (define (pi precision)
     (define (enumerator index)
       (cond ((odd?  index) (+ index 1.0))
	     ((even? index) (+ index 2.0))
	     (else (error "Error"))))
     (define (denominator index)
       (cond ((odd?  index) (+ index 2.0))
	     ((even? index) (+ index 1.0))
	     (else (error "Error"))))
     (define (fraction index)
       (/ (enumerator index) (denominator index)))
     (* 4.0 (product fraction 1 inc precision)))
     (pi 1280)
 #+end_src

 #+RESULTS:
 : 3.142818162579486

I can say that it converges very-very slowly.
**** DONE b. A recursive version
     CLOSED: [2019-09-03 Tue 11:59]

#+begin_src scheme :exports both :results value
   (define (inc x) (+ x 1))
   (define (identity x) x)
   (define (product term a next b)
     (define (iter a result)
       (if (= a b)
	   (* (term a) result)
	   (* (iter (next a) (term a)) result)))
     (iter a 1.0))
   (define (factorial x) (product identity 1 inc 6))
   (factorial 6)
#+end_src

#+RESULTS:
: 720.0

Doesn't make too much sense to me, but here you are.

*** DONE Exercise 1.32 Accumulator
    CLOSED: [2019-09-03 Tue 12:23]
I will cheat a little bit in this exercise, I will run ~sum~ as an iterative
procedure and ~product~ as a recursive procedure, so at the end I will have
two implementations, not 4, but that should not be too much of a digression.
#+begin_src scheme :exports both :results value :noweb-ref accumulator-common
   (define (inc x) (+ x 1))
   (define (identity x) x)
#+end_src

**** DONE Implement ~sum~ in terms of an iterative accumulator
     CLOSED: [2019-09-03 Tue 12:23]
#+begin_src scheme :exports both :results value
<<accumulator-common>>
  (define (accumulate combiner null-value term a next b)
       (define (iter a result)
	 (if (>= a b)
	     (combiner (term a) result)
	     (combiner (iter (next a) (term a)) result)))
       (iter a null-value))
  (define (sum term a next b)
    (accumulate + 0 term a next b))
  (sum identity 1 inc 10)
#+end_src

#+RESULTS:
: 55

**** DONE Implement ~product~ in terms of a recursive process
     CLOSED: [2019-09-03 Tue 12:22]

#+begin_src scheme :exports both :results value
<<accumulator-common>>
  (define (accumulate combiner null-value term a next b)
       (define (iter a result)
	 (if (= a b)
	     (combiner (term a) result)
	      (iter (next a) (combiner (term a) result) )))
       (iter a null-value))
  (define (product term a next b)
    (accumulate * 1 term a next b))
  (product identity 1 inc 10)

#+end_src

#+RESULTS:
: 3628800

*** DONE Exercise 1.33 filtered-accumulate
    CLOSED: [2019-09-03 Tue 14:36]
**** DONE a. Sum-of-squares-of-primes
    CLOSED: [2019-09-03 Tue 14:24]
#+begin_src scheme :exports both :results value :noweb-ref filtered-accumulate
  <<accumulator-common>>
  <<rabin-prime>>
    (define (filtered-accumulate combiner filter null-value term a next b)
     (define (iter a result)
       (if (= a b)
	   (combiner (if (filter a) (term a) null-value) result)
	   (iter (next a) (combiner (if (filter a) (term a) null-value) result))))
     (iter a null-value))
     #+end_src
     
#+begin_src scheme :exports both :results value 
    <<filtered-accumulate>>
    (define (sum-square-prime a next b)
      (filtered-accumulate + prime? 0 square a next b))
    (sum-square-prime 1 inc 10)
#+end_src

#+RESULTS:
: 88
**** DONE b. Product of positive integers mutually prime with n
     CLOSED: [2019-09-03 Tue 14:36]

#+begin_src scheme :exports both :results output
  <<filtered-accumulate>>
  (define (product-mutually-prime n)
    (define (filter-gcd x)
      (if (= (gcd n x) 1)
	  #t
	  #f))
    (filtered-accumulate * filter-gcd 1 identity 1 inc n))
  (display (product-mutually-prime 10))
#+end_src

#+RESULTS:
: 189

Here I used the ~gcd~ function from the standard library.

*** DONE Exercise 1.34 lambda
    CLOSED: [2019-09-03 Tue 14:44]

#+begin_src scheme :exports both :results value :noweb-ref example-lambda
(define (f g) (g 2))
#+end_src

#+begin_src scheme :exports both :results value
<<example-lambda>>
(define (square x) (* x x))
(f square)
#+end_src

#+RESULTS:
: 4

#+begin_src scheme :exports both :results value
<<example-lambda>>
(f (lambda (z) (* z (+ z 1))))
#+end_src

#+RESULTS:
: 6

#+begin_src scheme :exports both :results value
<<example-lambda>>
(f f)
#+end_src

#+RESULTS:
: "{Exception #19 user \"non procedure application\" (2) #<procedure #f> (\"/usr/lib64/chibi/init-7.scm\" . 230)}"

Well, no wonder. The final combination reduces to ~(2 2)~, which *IS* a
non-procedure application.

*** DONE Exercise 1.35 fixed-point
    CLOSED: [2019-09-03 Tue 21:05]



\(\varphi = \frac{1+\sqrt{5}}{2}\)
\(x\mapsto 1+\frac{1}{x}\)
Let's substitute:
\( \frac{1+\sqrt{5}}{2} &=& 1+ \frac{2}{1+\sqrt{5}} \)
\( (1+\sqrt{5})^2 = 2(1+\sqrt{5})+ 4\)
\( 1 + 2 \sqrt{5} + 5 = 2 + 2 \sqrt{5} + 4 \)
\(6 = 6\)


#+begin_src scheme :exports both :results value :noweb-ref fixed-point-silent
  (define tolerance 0.00001)
  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2))
	 tolerance))
    (define (try guess)
      (let ((next (f guess)))
	(if (close-enough? guess next)
	    next
	    (try next))))
  (try first-guess))
#+end_src

#+begin_src scheme :exports both :results value
<<fixed-point-silent>>
(fixed-point cos 1.0)
#+end_src

#+RESULTS:
: 0.7390822985224024

#+begin_src scheme :exports both :results value
  <<fixed-point-silent>>
  (define (golden-transform x)
    (+ 1 (/ 1 x)))
  (fixed-point golden-transform 1.0)

#+end_src

#+RESULTS:
: 1.6180327868852458

#+begin_src scheme :exports both :results value
(/ (+ 1 (sqrt 5)) 2)
#+end_src

#+RESULTS:
: 1.618033988749895

The difference is not too big.

*** DONE Exercise 1.36 fixed-point-with-dampening
    CLOSED: [2019-09-03 Tue 21:55]

#+begin_src scheme :exports both :results value :noweb-ref fixed-point-verbose
  (define tolerance 0.00001)
  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (display "Guesses: ")
      (display v1)
      (display " ")
      (display v2)
      (newline)
      (< (abs (- v1 v2))
	 tolerance))
    (define (try guess)
      (let ((next (f guess)))
	(if (close-enough? guess next)
	    next
	    (try next))))
  (try first-guess))
#+end_src

To find a solution to \(x^x=1000\), let us rearrange: \( x = \log_x1000 =
\frac{\log 1000}{\log x}\).

#+begin_src scheme :exports both :results value :noweb-ref log1000
(define (log1000/logx x)
  (/ (log 1000) (log x)))
#+end_src

#+begin_src scheme :exports both :results output
<<fixed-point-verbose>>
<<log1000>>
(display (fixed-point log1000/logx 5))
#+end_src

#+RESULTS:
#+begin_example
Guesses: 5 4.29202967422018
Guesses: 4.29202967422018 4.741863119908242
Guesses: 4.741863119908242 4.438204569837609
Guesses: 4.438204569837609 4.635299887107611
Guesses: 4.635299887107611 4.50397811613643
Guesses: 4.50397811613643 4.589989462723705
Guesses: 4.589989462723705 4.53301150767844
Guesses: 4.53301150767844 4.570475672855484
Guesses: 4.570475672855484 4.545720389670642
Guesses: 4.545720389670642 4.562024936588171
Guesses: 4.562024936588171 4.551263234080531
Guesses: 4.551263234080531 4.55835638768598
Guesses: 4.55835638768598 4.553676852183342
Guesses: 4.553676852183342 4.55676216434628
Guesses: 4.55676216434628 4.554727130670954
Guesses: 4.554727130670954 4.556069054770006
Guesses: 4.556069054770006 4.555184018843625
Guesses: 4.555184018843625 4.5557676565438205
Guesses: 4.5557676565438205 4.555382746639082
Guesses: 4.555382746639082 4.55563658243586
Guesses: 4.55563658243586 4.555469180245326
Guesses: 4.555469180245326 4.555579577901
Guesses: 4.555579577901 4.5555067722873686
Guesses: 4.5555067722873686 4.5555547860484085
Guesses: 4.5555547860484085 4.555523121789556
Guesses: 4.555523121789556 4.555544003742869
Guesses: 4.555544003742869 4.555530232469306
Guesses: 4.555530232469306 4.555539314360711
4.555539314360711
#+end_example

#+begin_src scheme :exports both :results value :noweb-ref fixed-point-verbose-with-dampening
  (define tolerance 0.00001)
  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (display "Guesses: ")
      (display v1)
      (display " ")
      (display v2)
      (newline)
      (< (abs (- v1 v2))
	 tolerance))
    (define (try guess)
      (let ((next (f guess)))
	(if (close-enough? guess next)
	    next
	    (try (/ (+ guess next) 2)))))
  (try first-guess))
#+end_src

#+begin_src scheme :exports both :results output
<<fixed-point-verbose-with-dampening>>
<<log1000>>
(display (fixed-point log1000/logx 5))
#+end_src

#+RESULTS:
: Guesses: 5 4.29202967422018
: Guesses: 4.64601483711009 4.49720773504196
: Guesses: 4.571611286076025 4.544977348996107
: Guesses: 4.558294317536066 4.553717728226165
: Guesses: 4.556006022881116 4.555225576581478
: Guesses: 4.555615799731297 4.555482885419889
: Guesses: 4.555549342575593 4.555526711628406
: Guesses: 4.555538027102 4.555534173941779
: 4.555534173941779

Well, the amount of steps is visibly smaller. Works.

*** DONE Exercise 1.37 cont-frac
    CLOSED: [2019-09-04 Wed 10:34]
**** DONE a. recursive
     CLOSED: [2019-09-04 Wed 11:35]
     #+begin_src scheme :exports both :results value :noweb-ref cont-frac-recursive
  (define (cont-frac n d k)
    (define (next step)
      (if (< step k)
	  (/ (n step) (+ (d step) (next (+ step 1))) )
	  0))
    (next 1))
     #+end_src
    
     #+begin_src scheme :exports both :results value
     <<cont-frac-recursive>>
         (/ 1 (cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 14))
     #+end_src

     #+RESULTS:
     : 1.6180257510729614

Abelson and Sussman tell us to estimate \(k\) needed to approximate the \(\varphi\) to a required
degree (0.0001). I didn't manage to derive the formula myself, however, I can
give a link to the book where this proof is given:

Khinchin, Continued Fractions (1935), chapter 2, section 7, gives an upper
bound on the speed of convergence as \(\frac{1}{k^2}\). Therefore we should
expect \(k \approx \sqrt{1000} \approx 33\). This holds for an arbitrary convergent
continued fraction. In our case, however, when \(N_k=D_k=1\), the constant in
the rate is also known as \(\sqrt{5}\), so the equation we need to solve is
in fact \(k^2 \sqrt{5} = 1000\), and in practice that is
\(\sqrt{\frac{1000}{2.23}} = 21\). How exactly we managed to do it in 14
steps, I don't know.

**** DONE b. iterative
     CLOSED: [2019-09-04 Wed 11:35]

We just start computing from the end.

#+begin_src scheme :exports both :results value :noweb-ref cont-frac
  (define (cont-frac n d k)
    (define (next step accumulator)
      (if (> step 0)
	  (next (- step 1) (/ (n step) (+ (d step) accumulator)))
	  accumulator))
    (next k 0))
#+end_src

#+RESULTS:
: #<undef>
  
#+begin_src scheme :exports both :results value
<<cont-frac>>
  (/ 1 (cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 14))
#+end_src

#+RESULTS:
: 1.6180371352785146


Remark: this exercise took me 7 hours.

*** DONE Exercise 1.38 euler constant
    CLOSED: [2019-09-04 Wed 11:35]

The only difficulty with this exercise is to derive the formula for the
second lambda.

#+begin_src scheme :exports both :results value
  <<cont-frac>>
  (+ 2 
     (cont-frac 
      (lambda (i) 1.0)
      (lambda (i) (if (= (remainder i 3) 2) (+ (* (/ i 3) 2) 2) 1))
      14 ))
#+end_src

#+RESULTS:
: 2.794771662537

*** DONE Exercise 1.39 tan-cf
    CLOSED: [2019-09-04 Wed 12:11]
    :LOGBOOK:

    :END:
#+begin_src scheme :exports both :results output
  <<cont-frac>>
  (define (tan-cf x k)
    (cont-frac
     (lambda (i)
       (if (= i 1) x (- (* x x))))
     (lambda (i)
       (- (* 2 i) 1))
     k))
  (display (tan 0.1))
  (newline)
  (display(tan-cf 0.1 300))
#+end_src

#+RESULTS:
: 0.10033467208545055
: 0.10033467208545055

*** DONE Exercise 1.40 newtons-method
    CLOSED: [2019-09-04 Wed 17:06]
    :LOGBOOK:
    CLOCK: [2019-09-04 Wed 17:21]--[2019-09-04 Wed 17:21] =>  0:00
    :END:

#+begin_src scheme :exports both :results value :noweb-ref deriv
  (define (deriv g)
    (lambda (x) (/ (- (g (+ x dx)) (g x)) dx)))
  (define dx 0.00001)
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref newtons-method
  (define (newton-transform g)
    (lambda (x) (- x (/ (g x) ((deriv g) x)))))
  (define (newtons-method g guess)
    (fixed-point (newton-transform g) guess))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref square
(define (square x)
 (* x x))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref cube
(define (cube x)
  (* x x x))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref cubic
  (define (cubic a b c) 
    (lambda (x) (+ (cube x) (* a (square x)) (* b x) c)))x
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref inc
(define (inc x) (+ x 1))
#+end_src

#+begin_src scheme :exports both :results output
<<fixed-point-silent>>
<<cubic>>
<<cube>>
<<square>>
<<deriv>>
<<newtons-method>>

(display (newtons-method (cubic 5 3 1) 1))
#+end_src

#+RESULTS:
: -4.365230013403046

Theoretically, a cubic may have up to 3 roots, but to find all of them we
would need to try over all possible ones.

*** DONE Exercise 1.41 double-double
    CLOSED: [2019-09-04 Wed 17:21]

#+begin_src scheme :exports both :results value :noweb-ref double-function
(define (double fun)
  (lambda (x) (fun (fun x))))
(define (inc x)
  (+ x 1))
#+end_src

#+begin_src scheme :exports both :results value
<<double-function>>
(((double double) inc) 5)
#+end_src

#+RESULTS:
: 9

#+begin_src scheme :exports both :results value
<<double-function>>
(((double (double double)) inc) 5)
#+end_src

#+RESULTS:
: 21

\(21 = 5 + 16\)
Double really works as a power of a function. \( 2 \Rightarrow 2^2 \Rightarrow2^{2^2} =
\mbox{inc}^{16} 5 \)
*** DONE Exercise 1.42 compose
    CLOSED: [2019-09-04 Wed 17:27]
#+begin_src scheme :exports both :results value :noweb-ref compose
(define (compose f g)
  (lambda (x) (f (g x))))
#+end_src

#+begin_src scheme :exports both :results value
<<compose>>
<<square>>
<<inc>>
((compose square inc) 6)
#+end_src

#+RESULTS:
: 49

*** DONE Exercise 1.43 repeated
    CLOSED: [2019-09-04 Wed 17:54]
#+begin_src scheme :exports both :results value :noweb-ref repeated

  (define (repeated fun n)
    (define (repeat-it n fun combinator)
      (if (= n 1)
	  combinator
	  (repeat-it  (- n 1) fun (lambda (x) (fun (combinator x))))))
      (repeat-it n fun fun))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results value
<<repeated>>

<<square>>

((repeated square 2) 5)
#+end_src

#+RESULTS:
: 625

Hm. Managed to do it without the ~compose~ form.

*** DONE Exercise 1.44 smoothing
    CLOSED: [2019-09-04 Wed 20:17]

#+begin_src scheme :exports both :results value :noweb-ref smooth
  (define dx 0.1)
  (define (smooth f)
    (lambda (x) (/ (+ (f (- x dx))
		 (f x)
		 (f (+ x dx)))
	      3)))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref n-smoothed
  (define (n-smoothed fun n)
    ((repeated smooth n) fun))
#+end_src

#+begin_src scheme :exports both :results output
<<smooth>>
<<n-smoothed>>
<<repeated>>
<<cube>>
(define (ex144-answer x)
  ((n-smoothed cube 3) x))
(display (ex144-answer 10))
#+end_src

#+RESULTS:
: 1000.6

Looks like what we wanted.

*** DONE Exercise 1.45 nth-root
    CLOSED: [2019-09-04 Wed 21:37]

#+begin_src scheme :exports both :results value :noweb-ref average
(define (average x y)
   (/ (+ x y) 2))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref average-damp
(define (average-damp f)
  (lambda (x) (average x (f x))))
#+end_src


#+begin_src scheme :exports both :results value :noweb-ref n-average-damp
(define (n-average-damped f n)
   ((repeated average-damp n) f))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref better-fixed-point
  (define tolerance 0.0001)
  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2))
	 tolerance))
    (define (try guess)
       (let ((next (f guess)))
	(if (close-enough? guess next)
	    next
	    (try next))))
  (try first-guess))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results value :noweb-ref root-n-x
  (define (root n x initial-guess)
    (fixed-point
     (n-average-damped
      (lambda (y) (/ x (pow y (- n 1))))
      n) 
      initial-guess))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref pow-recursive
(define (pow x n)
 (if (= n 1)
   x
   (* x (pow x (- n 1)))))
#+end_src

#+begin_src scheme :exports both :results output
<<average>>
<<average-damp>>
<<repeated>>
<<better-fixed-point>>
<<n-average-damp>>
<<pow-recursive>>
<<root-n-x>>
(display (root 4 4 3.0))

#+end_src

#+RESULTS:
: 1.4144444873765194

The true answer would require to actually estimate the dampening factor, but
we know that *n* is enough, and I am lazy.

*** DONE Exercise 1.46 iterative-improve
    CLOSED: [2019-09-04 Wed 22:25]

#+begin_src scheme :exports both :results value :noweb-ref iterative-improve
  (define (iterative-improve good-enough? improve)
    (define (improver guess)
      (if (good-enough? guess)
	  guess
	  (improver (improve guess))))
  improver)
#+end_src

**** DONE a. sqrt
     CLOSED: [2019-09-04 Wed 22:24]

#+begin_src scheme :exports both :results value
    <<square>>
    <<iterative-improve>>
    (define (ex1.46sqrt x)
      (let (
	    (square-improver
	     (iterative-improve
	      (lambda (y) (< (abs (- (square y) x )) 0.01))
	      (lambda (y) (/ (+ y (/ x y)) 2)))
	     )
	    )
	(square-improver 1)))
    (ex1.46sqrt 2.0)
#+end_src

#+RESULTS:
: 1.4166666666666665

**** DONE b. fixed-point
     CLOSED: [2019-09-04 Wed 22:25]

#+begin_src scheme :exports both :results value
    <<square>>
    <<iterative-improve>>
    (define (fixpoint f)
      (let (
	    (fixpoint-improver
	     (iterative-improve
	      (lambda (y) (< (abs (- (f y) y )) 0.01))
	      (lambda (y) (/ (+ y (f y)) 2)))
	     )
	    )
	(fixpoint-improver 1.0)))
    (fixpoint (lambda (x) (+ 1 (/ 1 x))))
#+end_src

#+RESULTS:
: 1.6147785476652068



I have made it. At [2019-09-04 Wed 22:25] I still haven't implemented all the
pictures, but I already can say that I have solved _all_ problems of the
first chapter of SICP. Some macros are wrong, I need to revise them, but that
will be done on the second pass. (Yes, there will be a second [or, rather, third] pass!)

** TODO Chapter 2: Building abstractions with data [92/110]
*** DONE Exercise 2.1 make-rat
    CLOSED: [2019-09-06 Fri 13:00]


In this exercise I will also define the functions presented by Abelson
and Sussman for general reference.

#+begin_src scheme :exports both :results value :noweb-ref make-rat
  (define (make-rat numerator denominator)
    (let* ((my-gcd (gcd numerator denominator))
	   (numerator (/ numerator my-gcd))
	   (denominator (/ denominator my-gcd))
	   (sign (/ (abs denominator) denominator)))
      (cons (* numerator sign) (* denominator sign))))
  (define (numer x)
    (car x))

  (define (denom x)
    (cdr x))

#+end_src

#+RESULTS:
: unfinished

#+begin_src scheme :exports both :results value 2.2.1-basic-rat
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
		 (* (numer y) (denom x)))
	      (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
		 (* (numer y) (denom x)))
	      (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
	      (* (denom x) (denom y))))

  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
	      (* (denom x) (numer y))))
  (define (equal-rat? x y)
    (= (* (numer x) (denom y))
       (* (numer y) (denom x))))

#+end_src

#+begin_src scheme :exports both :results value :noweb-ref print-rat
  (define (print-rat x)
    (newline)
    (display (numer x))
    (display "/")
    (display (denom x)))
#+end_src

#+begin_src scheme :exports both :results output
<<print-rat>>
<<2.2.1-basic-rat>>
<<make-rat>>
(define one-half (make-rat -65 -5))
(print-rat one-half)
#+end_src

#+RESULTS:
: 
: 13/1

*** TODO Figure 2.1

This figure contains a data-abstraction diagram. I don't know how to
make them yet.

*** DONE Exercise 2.2 make-segment
    CLOSED: [2019-09-06 Fri 13:34]

#+begin_src scheme :exports both :results value :noweb-ref make-segment
  (define (make-segment x1 y1 x2 y2)
    (cons (make-point x1 y1)  (make-point x2 y2)))

  (define (start-segment segment)
    (car segment))

  (define (end-segment segment)
    (cdr segment))

  (define (make-point x y)
    (cons x y))

  (define (x-point point)
    (car point))

  (define (y-point point)
    (cdr point))

  (define (midpoint-segment segment)
    (make-point (/ (+ (x-point (start-segment segment))
		   (x-point (end-segment   segment))) 2)
		(/ (+ (y-point (start-segment segment))
		   (y-point (end-segment   segment))) 2)))

#+end_src

#+begin_src scheme :exports both :results value :noweb-ref print-point
  (define (print-point p)
    (newline)
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")"))
#+end_src

#+begin_src scheme :exports both :results output
<<print-point>>
<<make-segment>>
(print-point (midpoint-segment (make-segment 1 0 0 1)))
#+end_src

#+RESULTS:
: 
: (1/2,1/2)

The task looks pretty straightforward. Just make a cons of points.

*** DONE Exercise 2.3 make-rectangle
    CLOSED: [2019-09-08 Sun 17:58]

I will choose the following two representations:
 - List of points from top left to the right.
 - Two lists of coordinates, x and y.

I will not be using segments from Exercise 2.2, because then I would
have to care about the consistency of the first and the last point in
the four segments.

#+begin_src scheme :exports both :results output :noweb-ref rectangle
  (define (area rectangle)
    (* (get-height rectangle) (get-width rectangle)))
  (define (perimeter rectangle)
    (* 2 (+ (get-height rectangle) (get-width rectangle))))
  (define (get-height rectangle)
    (dist (nth-point 1 rectangle) (nth-point 2 rectangle)))
  (define (get-width rectangle)
    (dist (nth-point 2 rectangle) (nth-point 3 rectangle)))
  (define (dist point1 point2)
    (+ (square (- (x-point point1) (x-point point2))) (square (- (y-point point1) (y-point point2)))))

#+end_src

#+begin_src scheme :exports both :results output :noweb-ref rectangle-point-list
  (define (make-rectangle x1 y1 x2 y2 x3 y3 x4 y4)   
    (list (make-point x1 y1)
	  (make-point x2 y2)
	  (make-point x3 y3)
	  (make-point x4 y4)))
  (define (nth-point n rectangle)
    (if (= n 1)
	(car rectangle)
	(nth-point (- n 1) (cdr rectangle))))
#+end_src


#+begin_src scheme :exports both :results output :noweb-ref rectangle-two-lists
  (define (make-rectangle x1 y1 x2 y2 x3 y3 x4 y4)   
    (cons (list x1 x2 x3 x4) (list y1 y2 y3 y4)))

  (define (nth-point n rectangle)
    (if (= n 1)
	(make-point (caar rectangle) (cadr rectangle))
	(nth-point (- n 1) (cons (cdar rectangle) (cddr rectangle)))))
#+end_src

#+begin_src scheme :exports both :results output
  <<rectangle>>
  <<rectangle-point-list>>
  <<make-segment>>
  (let ((test1 (make-rectangle 0 0 0 1 1 1 1 0)))
    (display "Area=")
    (display (area test1))
    (newline)
    (display "Perimeter=")
    (display (perimeter test1))
    (newline))

#+end_src

#+RESULTS:
: Area=1
: Perimeter=4


#+begin_src scheme :exports both :results output
  <<rectangle>>
  <<rectangle-two-lists>>
  <<make-segment>>
  (let ((test1 (make-rectangle 0 0 0 1 1 1 1 0)))
    (display "Area=")
    (display (area test1))
    (newline)
    (display "Perimeter=")
    (display (perimeter test1))
    (newline))

#+end_src

#+RESULTS:
: Area=1
: Perimeter=4

This is not very efficient, but two implementations were requested --
and they were delivered.

*** DONE Exercise 2.4 cons-lambda
    CLOSED: [2019-09-08 Sun 18:08]

#+begin_src scheme :exports both :results output
  (define (cons x y)
    (lambda (m) (m x y)))
  (define (car z)
    (z (lambda (p q) p)))
  (define (cdr z)
    (z (lambda (p q) q)))

  (display (car (cons 'a 'b)))
  (newline)
  (display (cdr (cons 'a 'b)))
  (newline)
#+end_src

#+RESULTS:
: a
: b

*** DONE Exercise 2.5 cons-pow
    CLOSED: [2019-09-08 Sun 19:07]
    0:00:00 -- 0:56:02 

#+begin_src scheme :exports both :results value :noweb-ref ex2.5cons
(define (cons a b)
  (* (expt 2 a) (expt 3 b)))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results value :noweb-ref ex2.5car
(define (car number)
  (log (gcd (expt 2.0 (floor (log number 2))) number) 2))
(define (cdr number)
  (log (gcd (expt 3.0 (floor (log number 2))) number) 3))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results value
<<ex2.5car>>
<<ex2.5cons>>

(list (car (cons 14 4)) (cdr (cons 14 4)))

#+end_src

#+RESULTS:
| 14.0 | 4.0 |

*** DONE Exercise 2.6 Church Numerals
    CLOSED: [2019-09-08 Sun 19:41]
0:00:00 -- 0:23:58 

In the worst case this exercise can be copied literally right from the
Wikipedia article: https://en.wikipedia.org/wiki/Church_encoding
#+begin_src scheme :exports both :results value :noweb-ref church-zero
  (define identity (lambda (x) x))
  (define zero (lambda (f) identity))
  (define (add-1 n)
    (lambda (f) (lambda (x) (f ((n f) x)))))
#+end_src

#+begin_src scheme :exports both :results output
  <<church-zero>>
  (define one (lambda (f) (lambda (x) (f x))))
  (define two (lambda (f) (lambda (x) (f (f x)))))
  (define (plus a b)
    (lambda (f) (lambda (x) ((a f) ((b f) x)))))

#+end_src

#+RESULTS:

*** DONE Exercise 2.7 make-interval
    CLOSED: [2019-09-08 Sun 20:09]
0:00:00 -- 0:20:09 

#+begin_src scheme :exports both :results value :noweb-ref make-interval
  (define (make-interval a b)
    (cons a b))
  (define (upper-bound interval)
    (max (car interval) (cdr interval)))
  (define (lower-bound interval)
    (min (car interval) (cdr interval)))
#+end_src


#+begin_src scheme :exports both :results value :noweb-ref interval-common
  (define (add-interval x y)
    (make-interval (+ (lower-bound x) (lower-bound y))
		   (+ (upper-bound x) (upper-bound y))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref mul-interval-simple
  (define (mul-interval x y)
    (let ((p1 (* (lower-bound x) (lower-bound y)))
	  (p2 (* (lower-bound x) (upper-bound y)))
	  (p3 (* (upper-bound x) (lower-bound y)))
	  (p4 (* (upper-bound x) (upper-bound y))))
      (make-interval (min p1 p2 p3 p4)
		     (max p1 p2 p3 p4))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref div-interval-lame
  (define (div-interval x y)
    (mul-interval
     x
     (make-interval (/ 1.0 (upper-bound y))
		    (/ 1.0 (lower-bound y)))))
#+end_src

#+begin_src scheme :exports both :results output
<<make-interval>>
<<interval-common>>
<<div-interval-lame>>
<<mul-interval-simple>>
(show #t " " (add-interval (make-interval 5 5.6) (make-interval 6 6.1)) "\n")
(show #t " " (mul-interval (make-interval -0.1 0.1) (make-interval 100 110)) "\n")
(show #t " " (div-interval (make-interval -0.1 0.1) (make-interval 100 110)))
#+end_src

#+RESULTS:
:  (11.0 . 11.7)
:  (-11.0 . 11.0)
:  (-0.001 . 0.001)

*** DONE Exercise 2.8 sub-interval
    CLOSED: [2019-09-08 Sun 23:07]

#+begin_src scheme :exports both :results value :noweb-ref sub-interval
  (define (sub-interval a b)
    (make-interval (- (upper-bound a) (lower-bound b))
		   (- (lower-bound a) (upper-bound b))))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results output
<<make-interval>>
<<sub-interval>>
(show #t " " (sub-interval (make-interval 100 -100) (make-interval -1 101)))
#+end_src

#+RESULTS:
:  (101 . -201)

*** DONE Exercise 2.9 interval-width
    CLOSED: [2019-09-08 Sun 23:15]
 0:06:00
#+begin_src scheme :exports both :results value
  (define (width interval)
    (abs (- (upper-bound interval) (lower-bound interval))))
#+end_src

\( a + \Delta a + b + \Delta b = (a+b) + (\Delta a + \Delta b)\)
\((a+\Delta a)\cdot (b+\Delta b) = (a\cdot b) + (a\Delta b + b\Delta a + \Delta a \Delta b)\)

The formulae above should relatively convincingly explain why the
width is not the function of the initial widths only in the case of
multiplication. 

*** DONE Exercise 2.10 div-interval-better
    CLOSED: [2019-09-08 Sun 23:30]
0:14:50  
The initial Alyssa's construction is:
#+begin_src scheme :exports both :results value :noweb-ref div-interval-better
  (define (div-interval x y)
    (when (and (< (lower-bound y) 0) (> (upper-bound y) 0))
      (error "Division by zero." (list x y)))
      (mul-interval
       x
       (make-interval (/ 1.0 (upper-bound y))
		      (/ 1.0 (lower-bound y)))))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results output
<<div-interval-better>>
<<make-interval>>
(display (div-interval (make-interval 1 2) (make-interval -1 1)))
#+end_src

#+RESULTS:
: '(Exception #19 user "Division by zero." (((1 . 2) (-1 . 1))) #f #f)

*** DONE Exercise 2.11 mul-interval-nine-cases
    CLOSED: [2019-09-09 Mon 00:45]
1:06:58 

| number | lower x | upper x | lower y | upper y |
|--------+---------+---------+---------+---------|
|      2 | +       | +       | +       | +       |
|      2 | +       | +       | -       | +       |
|      2 | +       | +       | -       | -       |
|      2 | -       | +       | +       | +       |
|      3 | -       | +       | -       | +       |
|      2 | -       | +       | -       | -       |
|      2 | -       | -       | +       | +       |
|      2 | -       | -       | -       | +       |
|      2 | -       | -       | -       | -       |


#+begin_src scheme :exports both :results value :noweb-ref mul-interval
  (define (mul-interval x y)
    (let ((x1 (lower-bound x))
	  (x2 (upper-bound x))
	  (y1 (lower-bound y))
	  (y2 (upper-bound y)))
      (cond ((and (> x1 0) (> x2 0) (> y1 0) (> y2 0)) (make-interval (* x1 y1) (* x2 y2)))
	    ((and (> x1 0) (> x2 0) (< y1 0) (> y2 0)) (make-interval (* x2 y1) (* x2 y2)))
	    ((and (> x1 0) (> x2 0) (< y1 0) (< y2 0)) (make-interval (* x2 y1) (* x2 y1)))
	    ((and (< x1 0) (> x2 0) (> y1 0) (> y2 0)) (make-interval (* x1 y2) (* x2 y2)))
	    ((and (< x1 0) (> x2 0) (< y1 0) (> y2 0))
	     (let ((p1 (* (lower-bound x) (lower-bound y)))
		   (p2 (* (lower-bound x) (upper-bound y)))
		   (p3 (* (upper-bound x) (lower-bound y)))
		   (p4 (* (upper-bound x) (upper-bound y))))
	       (make-interval (min p1 p2 p3 p4)
			      (max p1 p2 p3 p4))))
	    ((and (< x1 0) (> x2 0) (< y1 0) (< y2 0)) (make-interval (* x2 y2) (* x2 y1)))
	    ((and (< x1 0) (< x2 0) (> y1 0) (> y2 0)) (make-interval (* x1 y2) (* x2 y1)))
	    ((and (< x1 0) (< x2 0) (< y1 0) (> y2 0)) (make-interval (* x2 y2) (* x1 y1)))
	    ((and (< x1 0) (< x2 0) (< y1 0) (< y2 0)) (make-interval (* x2 y2) (* x1 y1))))))
#+end_src

I don't even want to test it. 

#+begin_src scheme :exports both :results output
<<mul-interval>>
<<make-interval>>
(show #t " " (mul-interval (make-interval -2 2) (make-interval -5 6)))

#+end_src

#+RESULTS:
:  (-12 . 12)

Marvelous.

*** DONE Exercise 2.12 make-center-percent
    CLOSED: [2019-09-09 Mon 10:11]

#+begin_src scheme :exports both :results value :noweb-ref make-center-width
  (define (make-center-width c w)
    (make-interval (- c w) (+ c w)))
  (define (center i)
    (/ (+ (lower-bound i) (upper-bound i)) 2))
  (define (width i)
    (/ (- (upper-bound i) (lower-bound i)) 2))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref make-center-precision
  (define (make-center-percent center percent)
    (let ((delta (* center (/ percent 100))))
      (make-interval  (+ center delta) (- center delta))))
  (define (relative-precision interval)
    (let* ((center (/ (+ (lower-bound interval) (upper-bound interval))
		     2))
	   (percent (/ (abs (- (lower-bound interval) (upper-bound interval))) 2)))
      (/ percent center)))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results output
<<make-center-width>>
<<make-center-precision>>
<<make-interval>>
  (let ((test-interval (make-center-percent 100 2)))
    (show #t " " test-interval "\n")
    (show #t " " (center test-interval) "\n")
    (show #t " " (relative-precision test-interval)) "\n")
#+end_src

#+RESULTS:
:  (102 . 98)
:  100
:  1/50

*** DONE Exercise 2.13 formula for tolerance
    CLOSED: [2019-09-09 Mon 10:16]

\((a+\Delta a)\cdot (b+\Delta b) = (a\cdot b) + (a\Delta b + b\Delta a + \Delta a \Delta b)\)
\(\frac{(a+\Delta a)\cdot (b+\Delta b)}{a\cdot b} = \frac{(a\cdot b)}{a\cdot b} + \frac{(a\Delta b +
b\Delta a + \Delta a \Delta b)}{a \cdot b} \approx 1 + \frac{\Delta a}{a} + \frac{\Delta b}{b}\) 

*** DONE Exercise 2.14 parallel-resistors
    CLOSED: [2019-09-09 Mon 11:24]
0:37:00 +  0:31:07 = 1:06:07
#+begin_src scheme :exports both :results output
  <<make-interval>>
  <<div-interval-better>>
  <<mul-interval>>
  <<interval-common>>
  (define (par1 r1 r2)
    (div-interval (mul-interval r1 r2)
		  (add-interval r1 r2)))
  (define (par2 r1 r2)
    (let ((one (make-interval 1 1)))
      (div-interval
       one (add-interval (div-interval one r1)
			 (div-interval one r2)))))

  (show #t " " (par1 (make-interval 4.9 5.1) (make-interval 6.9 7.1)) "\n")
  (show #t " " (par2 (make-interval 4.9 5.1) (make-interval 6.9 7.1)) "\n")
#+end_src

#+RESULTS:
:  (2.7713114754098367 . 3.0686440677966096)
:  (2.8652542372881356 . 2.968032786885246)

It is worth noticing that ~par2~ uses more operations than
~par1~. Even if the title problem in the exercise wasn't present, we
would still get a less precise result.

#+begin_src scheme :exports both :results output
    <<make-interval>>
    <<mul-interval>>
    <<div-interval-better>>
    (let ((one (make-interval 1.0 1.0))
	  (i2 (make-interval 4.9 5.1))
	  (i3 (make-interval 6.9 7.1)))
      (show #t " " (div-interval one one) "\n")
      (show #t " " (div-interval one i2) "\n")
      (show #t " " (div-interval i2 i2) "\n")
      (show #t " " (div-interval i2 i3) "\n")
      (show #t " " (mul-interval  i2 (div-interval one i2)) "\n"))

#+end_src

#+RESULTS:
:  (1.0 . 1.0)
:  (0.19607843137254904 . 0.2040816326530612)
:  (0.9607843137254903 . 1.040816326530612)
:  (0.6901408450704226 . 0.7391304347826086)
:  (0.9607843137254903 . 1.040816326530612)

The idea here is, in some sense, the non-independence of the random
variables *i2* and *i2*. Regardless of the precision of *i2*, we
_know_ that \(\frac{i_2}{i_2} = 1\). 

The center-percent form I implemented is slightly different from the
one Abelson expected, I guess, but still,
\(\frac{1}{1} \approx 1 \pm 2\Delta\). This is too much.

*** DONE Exercise 2.15 better-intervals
    CLOSED: [2019-09-09 Mon 11:34]

I already answered this question in the Exercise 2.14. The problem is
of the potential independence (which may or may not be the case) of
*a* and *b*, but complete dependence of *a* on *a*, which is \(1\)
regardless of whether *a* is even well-defined.

*** DONE Exercise 2.16 interval-arithmetic
    CLOSED: [2019-09-09 Mon 11:37]

To solve this problem in the general case, on would have to build a
probability distribution of the function on the variables, and use
something of a probabilistic reduction on every step. I am not aware
of such systems if they even exist. It would be indispensable for
quantum modelling though.

Hypothetically, if such systems existed, they would do something like
build a distribution on every step of the computation and track every
quantity occurrence in every distribution.

*** TODO Figure 2.2 Box-and-pointer representation of ~(cons 1 2)~. :graphviz:plantuml:tikz:
https://gitlab.com/graphviz/graphviz/issues/1588
https://gitlab.com/graphviz/graphviz/issues/1589
10:00:00
[2019-09-10 Tue 10:24] I managed to make pgf work with org-mode, but
didn't manage to  make a picture yet. So far this problem happened to
generalize to the case of drawing arbitrary vector graphics. Graphviz
turned out to be less fit for this problem.

#+begin_src plantuml :exports both :file figure-2-2.png
  @startdot
  digraph sicp2_2 {
    node [shape=none];
    source [label=""];
    
    node [shape=plaintext, style="rounded"];
    struct0 [label=<<table BORDER="0" CELLBORDER="1" CELLSPACING="0">
             <tr>
                 <td width="29" height="35" sides="ltrb" port="f1"></td>
                 <td width="29" height="35" sides="lrtb" port="f2"></td>
             </tr>
             </table>>, style="rounded,filled", fillcolor="gray"];
    rankdir=LR;
    node [shape=record, style="rounded"];
    struct2 [label="<f2> 2"];
    struct1 [label="<f1> 1"];
    edge [arrowhead=normal,arrowtail=dot];    
    struct0:f2:c -> struct2:f0 [tailclip=false];
    struct0:f1:c -> struct1:f0 [tailclip=false];
    source -> struct0;
  }

  @enddot
#+end_src 

#+RESULTS:
[[file:figure-2-2.png]]


#+name: tikztest
#+header: :imagemagick yes :iminoptions -density 600 :imoutoptions -geometry 200
#+header: :fit yes :headers '("\\usepackage{tikz}")
#+header: :buffer on
#+begin_src latex :results raw file :exports code :file test.png
  \usetikzlibrary{trees}
  \begin{tikzpicture}[color=white]
    \node [circle, draw, fill=red!70] at (0,0) {1}
      child { 
             node [circle, draw, fill=blue!70] {2}
             child { 
                   node [circle, draw, fill=green!70]  {3} }
             child { 
                   node [circle, draw, fill=yellow!70] {4} }
            };
  \end{tikzpicture}
#+end_src

#+RESULTS: tikztest
[[file:test.png]]

#+begin_src plantuml :exports both :file ditaa.png
@startditaa
               +---+---+     +---+---+         +---+---+     +---+
          ---->| * | *-+---->| * | * |    ---->| * | *------>| 4 |
               +-|-+---+     +-|-+-|-+         +-|-+---+     +---+
                 |             |   |             |
                 V             V   V             V
             +---+---+      +---+ +---+      +---+---+     +---+---+
             | * | * |      | 3 | | 4 |      | * | *-+---->| * | * |
             +-|-+-|-+      +---+ +---+      +-|-+---+     +-|-+-|-+
               |   |                           |             |   |
               V   V                           V             V   V
            +---+ +---+                      +---+        +---+ +---+
            | 1 | | 2 |                      | 1 |        | 2 | | 3 |
            +---+ +---+                      +---+        +---+ +---+

@endditaa
#+end_src 

#+RESULTS:
[[file:ditaa.png]]

*** DONE Exercise 2.17 last-pair
    CLOSED: [2019-09-10 Tue 10:48]
0:20:51 

#+begin_src scheme :exports both :results value :noweb-ref last-pair
  (define (last-pair lst)
    (list-tail lst (- (length lst) 1)))
#+end_src

#+begin_src scheme :exports both :results output
<<last-pair>>
(let ((tmp (last-pair '(1 1))))
(show #t " " (car tmp) " " (cdr tmp)))
#+end_src

#+RESULTS:
:  1 ()

*** DONE Exercise 2.18 reverse
    CLOSED: [2019-09-10 Tue 10:57]
0:03:56 
#+begin_src scheme :exports both :results value :noweb-ref reverse-list
  (define (reverse lst)
    (define (lst-iter x y)
       (if (null? y)
	   x
	   (lst-iter (cons (car y) x) (cdr y))))
    (lst-iter '() lst))
#+end_src

#+begin_src scheme :exports both :results output
<<reverse-list>>
(show #t " " (reverse '(1 2 3)))
#+end_src

#+RESULTS:
:  (3 2 1)

*** DONE Exercise 2.19 coin-values                                   :unsure:
    CLOSED: [2019-09-10 Tue 11:27]

#+begin_src scheme :exports both :results value :noweb-ref coin-values
  (define us-coins (list 50 25 10 5 1))
  (define uk-coins (list 100 50 20 10 5 2 1 0.5))
  (define uk-coins-damaged (list 0.50 100 50 20 10 5 2 1))

  (define (cc amount coin-values)
    (cond ((= amount 0) 1)
	  ((or (< amount 0) (no-more? coin-values)) 0)
	  (else
	   (+ (cc amount
		  (except-first-denomination
		   coin-values))
	      (cc (- amount
		     (first-denomination
		      coin-values))
		  coin-values)))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref first-denomination
  (define (first-denomination coin-values)
    (car coin-values))
  (define (except-first-denomination coin-values)
    (cdr coin-values))
  (define (no-more? coin-values)
    (null? coin-values))
#+end_src

*Warning:* the next code is a bit slow (~1 minute).

#+begin_src scheme :exports both :results output
<<first-denomination>>
<<coin-values>>
(show #t " " (cc 137 us-coins) "\n")
(show #t " " (cc 137 uk-coins) "\n")
#+end_src

#+RESULTS:
:  704
:  443166

#+begin_src scheme :exports both :results output
<<first-denomination>>
<<coin-values>>
(show #t " " (cc 137 uk-coins-damaged) "\n")
#+end_src

#+RESULTS:
:  443166

I don't see why the result would depend on the order of the coins. We
don't seem to be using the order anywhere.

*** DONE Exercise 2.20 dotted-tail notation
    CLOSED: [2019-09-10 Tue 18:55]
1:45:10 
#+begin_src scheme :exports both :results value :noweb-ref same-parity
  (define (same-parity . lst)
    (define (iter-parity lst bit accumulator)
      (cond ((null? lst)
	     accumulator)
	    ((= (remainder (car lst) 2) bit)
	     (iter-parity (cdr lst) bit (cons (car lst) accumulator)))
	    (else
	     (iter-parity (cdr lst) bit accumulator))))
   (reverse (iter-parity lst (remainder (car lst) 2) '())))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results output
<<same-parity>>
(show #t " " (same-parity 2 3 4) "\n")
(show #t " " (same-parity 1 2 3 4) "\n")
#+end_src

#+RESULTS:
:  (2 4)
:  (1 3)

*** DONE Exercise 2.21 map-square-list
    CLOSED: [2019-09-10 Tue 19:14]
0:13:23 
#+begin_src scheme :exports both :results output
  (define nil #f)
  (define (square-list items)

  (if (null? items)
	'()
	(cons (* (car items) (car items)) (square-list (cdr items)))))
  (show #t " " (square-list '(1 2 3 4 5)))
#+end_src

#+RESULTS:
:  (1 4 9 16 25)

#+begin_src scheme :exports both :results output
  (define (square-list items)
    (map (lambda (x) (* x x)) items))

  (show #t " " (square-list '(1 2 3 4 5)))
#+end_src

#+RESULTS:
:  (1 4 9 16 25)

One of the peculiar tricks in this equation is that unlike in older
lisps, *#f* is not entirely the same as ~'()~, although they both
evaluate to false.

*** DONE Exercise 2.22 wrong list order
    CLOSED: [2019-09-10 Tue 19:24]
Referring to Exercise 2.20 is highly recommended. 

The problem with the first solution is that, indeed, he's ~cons~'ing
the pair in such a way that it would produce the reversed list.

The problem with the second solution is that it IS creating a list-ish
construction that is contains all the elements in the right order, but
stores them in ~cdr~'s, not in ~car~'s. 

In lisp without mutations (without ~set-cdr!~ and ~set-car!~), it is
only possible to prepend elements to lists, not really append.

*** DONE Exercise 2.23 for-each
    CLOSED: [2019-09-10 Tue 19:33]
0:04:56 
#+begin_src scheme :exports both :results output
  (define (for-each fun items)
   (unless (null? items)
    (fun (car items))
    (for-each fun (cdr items))))

  (for-each (lambda (x)
	      (newline)
	      (display x))
	    (list 57 321 88))
#+end_src

#+RESULTS:
: 
: 57
: 321
: 88

*** DONE Exercise 2.24 list-plot-result                            :graphviz:
    CLOSED: [2019-09-10 Tue 22:13]
0:48:39 
The result of the interpreter:
#+begin_src scheme :exports both :results output
(show #t " " (list 1 (list 2 (list 3 4))))
#+end_src

#+RESULTS:
:  (1 (2 (3 4)))

The box-and-pointer structure:

#+begin_src plantuml :exports both :file exercise-2-24.png
  @startdot
  digraph sicp2_24 {
    node [shape=plaintext, style="rounded"];
    struct1 [label=<<table BORDER="0" CELLBORDER="1" CELLSPACING="0">
             <tr>
                 <td width="29" height="35" sides="ltrb" port="f0">1</td>
                 <td width="29" height="35" sides="lrtb" port="f1"></td>
             </tr>
             </table>>, style="rounded,filled", fillcolor="gray"];
    rankdir=LR;
    edge [arrowhead=normal,arrowtail=dot,tailclip=false, dir=both];    
    struct1:f1:c -> struct2 [tailclip=false];
    
    node [shape=plaintext, style="rounded"];
    struct2 [label=<<table BORDER="0" CELLBORDER="1" CELLSPACING="0">
             <tr>
                 <td width="29" height="35" sides="ltrb" port="f0"></td>
                 <td width="29" height="35" sides="lrtb" port="f1">'()</td>
             </tr>
             </table>>, style="rounded,filled", fillcolor="gray"];
    
    struct2:f0:c -> struct3 [tailclip=false];
    
    node [shape=plaintext, style="rounded"];
    struct3 [label=<<table BORDER="0" CELLBORDER="1" CELLSPACING="0">
             <tr>
                 <td width="29" height="35" sides="ltrb" port="f0"></td>
                 <td width="29" height="35" sides="lrtb" port="f1"></td>
             </tr>
             </table>>, style="rounded,filled", fillcolor="gray"];

    node [shape=plaintext, style="rounded"];
    struct4 [label=<<table BORDER="0" CELLBORDER="1" CELLSPACING="0">
             <tr>
                 <td width="29" height="35" sides="ltrb" port="f0"></td>
                 <td width="29" height="35" sides="lrtb" port="f1">'()</td>
             </tr>
             </table>>, style="rounded,filled", fillcolor="gray"];
    struct3_3 [label="2",shape=record];
    struct3:f0:c -> struct3_3 [tailclip=false];

    struct3:f1:c -> struct4 [tailclip=false];

    struct5 [label=<<table BORDER="0" CELLBORDER="1" CELLSPACING="0">
             <tr>
                 <td width="29" height="35" sides="ltrb" port="f0">3</td>
                 <td width="29" height="35" sides="lrtb" port="f1"></td>
             </tr>
             </table>>, style="rounded,filled", fillcolor="gray"];
    struct4:f0:c -> struct5;    

    struct6 [label=<<table BORDER="0" CELLBORDER="1" CELLSPACING="0">
             <tr>
                 <td width="29" height="35" sides="ltrb" port="f0">4</td>
                 <td width="29" height="35" sides="lrtb" port="f1">'()</td>
             </tr>
             </table>>, style="rounded,filled", fillcolor="gray"];
    struct5:f1:c -> struct6;

  }

  @enddot
#+end_src 

#+RESULTS:
[[file:exercise-2-24.png]]

Tree interpretation:

 #+begin_src plantuml :exports both :file figure-1-1-dot.png
 @startdot
 graph g {
	 node [shape=plaintext];
	 A1 [label="(1 (2 (3 4)))"];

	 B1 [label="1"];
         B2 [label="(2 (3 4))"];

         C1 [label="2"];
         C2 [label="(3 4)"];

         D1 [label="3"];
         D2 [label="4"];


 // edges
	 A1 -- B1;
	 A1 -- B2;
	
	 B2 -- C1;
	 B2 -- C2;

	 C2 -- D1;
	 C2 -- D2;

	 { rank=same; A1 }
	 { rank=same; B1 B2 } 
	 { rank=same; C1 C2 }
	 { rank=same; D1 D2 }
 } 
 @enddot
 #+end_src 

 #+RESULTS:
 [[file:figure-1-1-dot.png]]

*** DONE Exercise 2.25 caddr
    CLOSED: [2019-09-10 Tue 23:07]
#+begin_src scheme :exports both :results value
(car (cdr (car (cdr (cdr '(1 3 (5 7) 9))))))
#+end_src

#+RESULTS:
: 7

#+begin_src scheme :exports both :results value
(caar '((7)))
#+end_src

#+RESULTS:
: 7

#+begin_src scheme :exports both :results output
(show #t " " (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr '(1 (2 (3 (4 (5 (6 7)))))))))))))))))))
#+end_src

#+RESULTS:
:  7

The task was funny.

*** DONE Exercise 2.26 append cons list
    CLOSED: [2019-09-10 Tue 23:23]

#+begin_src scheme :exports both :results output
(define x (list 1 2 3))
(define y (list 4 5 6))
(show #t " " (append x y) "\n")
(show #t " " (cons x y) "\n")
(show #t " " (list x y) "\n")
#+end_src

#+RESULTS:
:  (1 2 3 4 5 6)
:  ((1 2 3) 4 5 6)
:  ((1 2 3) (4 5 6))

*** DONE Exercise 2.27 deep-reverse
    CLOSED: [2019-09-11 Wed 09:47]
0:14:46 
#+begin_src scheme :exports both :results output
  (define (deep-reverse lst)
    (define (iter-reverse lst1 accumulator)
      (if (null? lst1)
	  accumulator
	  (if (pair? (car lst1))
	      (iter-reverse (cdr lst1) (cons (deep-reverse (car lst1)) accumulator))
	      (iter-reverse (cdr lst1) (cons (car lst1) accumulator)))))
    (iter-reverse lst '()))

  (define x (list (list 1 2) (list 3 4)))
  (show #t " " (reverse x) "\n")
  (show #t " " (deep-reverse x))
#+end_src

#+RESULTS:
:  ((3 4) (1 2))
:  ((4 3) (2 1))

*** DONE Exercise 2.28 fringe
    CLOSED: [2019-09-11 Wed 10:24]
0:37:00
#+begin_src scheme :exports both :results output
      (define (fringe tree)
	(define (fringe-iter tree accumulator)
	  (cond  ((null? tree) '())
		 ((not (pair? tree)) (list tree))
		 (else
		   (append accumulator 
			   (fringe-iter (car tree) '())
			   (fringe-iter (cdr tree) '())))))
	(fringe-iter tree '()))
      (define x (list (list 1 2) (list 3 4)))
      (show #t " " (fringe x) "\n")
      (show #t " " (fringe (list x x)) "\n")

#+end_src

#+RESULTS:
:  (1 2 3 4)
:  (1 2 3 4 1 2 3 4)

*** DONE Exercise 2.29 mobile
    CLOSED: [2019-09-11 Wed 11:47]
1:23:0
#+begin_src scheme :exports both :results value :noweb-ref mobile
  (define (make-mobile left right)
    (list left right))

  (define (make-branch length structure)
    (list length structure))

  (define (left-branch mobile)
    (car mobile))

  (define (right-branch mobile)
    (cadr mobile))

  (define (branch-length branch)
    (car branch))

  (define (branch-structure branch)
    (cadr branch))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref mobile-total-weight
  (define (total-weight mobile)
    (if (pair? mobile)
    (+ (if (pair? (branch-structure (left-branch mobile)))
	   (total-weight (branch-structure (left-branch mobile)))
	   (branch-structure (left-branch mobile)))
       (if (pair? (branch-structure (right-branch mobile)))
	   (total-weight (branch-structure (right-branch mobile)))
	   (branch-structure (right-branch mobile))))
    mobile))
#+end_src

#+begin_src scheme :exports both :results value
  <<mobile>>
  <<mobile-total-weight>>
  (total-weight
   (make-mobile
    (make-branch
     5
     (make-mobile
      (make-branch 1 1)
      (make-branch 2 2)))
    (make-branch 7 2)))
#+end_src

#+RESULTS:
: 5

#+begin_src scheme :exports both :results value :noweb-ref mobile-balanced
    (define (balanced? mobile)
      (and
       (=
	(*
	 (branch-length (left-branch mobile))
	 (total-weight (branch-structure (left-branch mobile))))
	(*
	 (branch-length (right-branch mobile))
	 (total-weight (branch-structure (right-branch mobile))))
	)
       (if (pair? (branch-structure (left-branch mobile)))
	   (balanced? (branch-structure (left-branch mobile)))
	   #t)
       (if (pair? (branch-structure (right-branch mobile)))
	   (balanced? (branch-structure (right-branch mobile)))
	   #t)))
     
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results output
<<mobile-balanced>>
<<mobile-total-weight>>
<<mobile>>
  (show #t " " (balanced?
   (make-mobile
    (make-branch
     5
     (make-mobile
      (make-branch 1 1)
      (make-branch 2 2)))
    (make-branch 7 2))) "\n")
  (show #t " " (balanced? (make-mobile (make-branch 5 5) (make-branch 5 5))) "\n")

#+end_src

#+RESULTS:
:  #f
:  #t

If we replace lists with ~cons~, the only thing that needs to be
changed is that ~cadr~ should be replaced with ~car~.

*** DONE Exercise 2.30 square-tree
    CLOSED: [2019-09-11 Wed 14:11]
 1. A no-high-level version
#+begin_src scheme :exports both :results value :noweb-ref  square-tree
  (define (square-tree tree)
    (cond ((null? tree) '())
	  ((not (pair? tree)) (square tree))
	  (else (cons (square-tree (car tree))
		      (square-tree (cdr tree))))))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results output
<<square-tree>>
  (show #t " " (square-tree
   (list 1
	 (list 2 (list 3 4) 5)
	 (list 6 7))))
#+end_src

#+RESULTS:
:  (1 (4 (9 16) 25) (36 49))
 2. High-level version
#+begin_src scheme :exports both :results output :noweb-ref square-subtree-map
    (define (square-tree tree)
      (map (lambda (sub-tree)
	     (if (pair? sub-tree)
		 (square-tree sub-tree)
		 (square sub-tree)))
	   tree))

#+end_src

#+RESULTS:

#+begin_src scheme :exports both :results output
<<square-subtree-map>>
  (show #t " " (square-tree
   (list 1
	 (list 2 (list 3 4) 5)
	 (list 6 7))))
#+end_src

#+RESULTS:
:  (1 (4 (9 16) 25) (36 49))

Not a very hard problem.

*** DONE Exercise 2.31 tree-map square tree
    CLOSED: [2019-09-11 Wed 14:38]
Not a very hard problem.
#+begin_src scheme :exports both :results output
  (define (square-tree tree) (tree-map square tree))

  (define (tree-map square tree)
    (map (lambda (sub-tree)
	   (if (pair? sub-tree)
	       (tree-map square sub-tree)
	       (square sub-tree)))
	 tree))
  (show #t " " 
	(square-tree
	 (list 1
	       (list 2 (list 3 4) 5)
	       (list 6 7))))

#+end_src

#+RESULTS:
:  (1 (4 (9 16) 25) (36 49))

*** DONE Exercise 2.32 subsets
    CLOSED: [2019-09-11 Wed 14:53]

#+begin_src scheme :exports both :results value :noweb-ref subsets
  (define (subsets s)
    (if (null? s)
	(list '())
	(let ((rest (subsets (cdr s))))
	  (append rest (map (lambda (suffix) (append (list (car s)) suffix)) rest)))))
  (subsets '(1 2 3))
#+end_src

#+RESULTS:
|---+---+---|
| 3 |   |   |
| 2 |   |   |
| 2 | 3 |   |
| 1 |   |   |
| 1 | 3 |   |
| 1 | 2 |   |
| 1 | 2 | 3 |

The explanation is easy. The subsets can be constructed by taking any
element, say, the first, and appending it to every subset of the rest
of the set. That is if we already have a set of subsets of some set
*S*, and we are adding some element *a*, then it may or may not be in
every subset of the enlarged set *S+a*. 

*** TODO Figure 2.7 Signal-flow diagram

*** DONE Exercise 2.33 map-append-length
    CLOSED: [2019-09-11 Wed 23:53]

#+begin_src scheme :exports both :results value :noweb-ref filter
  (define (filter predicate sequence)
    (cond ((null? sequence) '())
	  ((predicate (car sequence))
	   (cons (car sequence)
		 (filter predicate (cdr sequence))))
	  (else (filter predicate (cdr sequence)))))
#+end_src
n
#+begin_src scheme :exports both :results value :noweb-ref accumulate
  (define (accumulate op initial sequence)
    (if (null? sequence)
	initial
	    (accumulate op (op initial (car sequence)) (cdr sequence))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref enumerate-interval
  (define (enumerate-interval low high)
    (if (> low high)
	'()
	(cons low (enumerate-interval (+ low 1) high))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref enumerate-tree
  (define (enumerate-tree tree)
    (cond ((null? tree) '())
	   ((not (pair? tree)) (list tree))
	   (else (append (enumerate-tree (car tree))
			 (enumerate-tree (cdr tree))))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref map-append-length
  (define (map p sequence)
    (accumulate (lambda (x y) (x y)) '() sequence))
  (define (append seq1 seq2)
    (accumulate cons seq2 seq1))
  (define (length sequence)
    (accumulate (lambda (x y) (+ 1 y))))
#+end_src

#+begin_src scheme :exports both :results value
 (length (make-list 100 99))
#+end_src

#+RESULTS:
: 100

*** DONE Exercise 2.34 horners-rule
    CLOSED: [2019-09-12 Thu 00:01]
#+begin_src scheme :exports both :results value
<<accumulate>>
  (define (horner-eval x coefficient-sequence)
    (accumulate (lambda (this-coeff higher-terms) (+ this-coeff (* x higher-terms)))
		0
		coefficient-sequence))
  (horner-eval 2 (list 1 3 0 5 0 1))

#+end_src

#+RESULTS:
: 79

*** DONE Exercise 2.35 count-leaves-accumulate
    CLOSED: [2019-09-12 Thu 00:17]
#+begin_src scheme :exports both :results value
<<accumulate>>
  (define (count-leaves t)
    (accumulate + 0 (map (lambda (x) (if (pair? x)
				    (count-leaves x)
				    1)) t)))
  (count-leaves (list 1 2 3))
#+end_src

#+RESULTS:
: 3

*** DONE Exercise 2.36 accumulate-n
    CLOSED: [2019-09-12 Thu 00:26]
#+begin_src scheme :exports both :results value :noweb-ref accumulate-n
<<accumulate>>
  (define (accumulate-n op init seqs)
    (if (null? (car seqs))
	'()
	(cons (accumulate op init (map car seqs))
              (accumulate-n op init (map cdr seqs)))))
#+end_src
  
#+begin_src scheme :exports both :results value
<<accumulate-n>>
  (accumulate-n + 0 '((1 2 3) (4 5 6) (7 8 9) (10 11 12)))
#+end_src

#+RESULTS:
| 22 | 26 | 30 |

*** DONE Exercise 2.37 matrix-*-vector
    CLOSED: [2019-09-12 Thu 00:50]

#+begin_src scheme :exports both :results value :noweb-ref dot-product
  (define (dot-product v w)
    (accumulate + 0 (map * v w)))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref matrix-operations
  (define (matrix-*-vector m v)
    (map (lambda (x) (dot-product v x)) m))
  (define (transpose mat)
    (accumulate-n cons '() mat))
  (define (matrix-*-matrix m n)
    (let ((cols (transpose n)))
      (map (lambda (x) (matrix-*-vector m x)) n)))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results output
<<accumulate>>
<<accumulate-n>>
<<dot-product>>
<<matrix-operations>>
(show #t " " (matrix-*-vector '((1 2 3 4) (4 5 6 6) (6 7 8 9)) '(1 2 3 4)) "\n")
(show #t " " (transpose '((1 2 3 4) (4 5 6 6) (6 7 8 9))) "\n")
(show #t " " (matrix-*-matrix
               '((1 2 3 4) (4 5 6 6) (6 7 8 9)) 
               '((1 2 3 4) (4 5 6 6) (6 7 8 9)) ) "\n")
#+end_src

#+RESULTS:
:  (30 56 80)
:  ((1 4 6) (2 5 7) (3 6 8) (4 6 9))
:  ((30 56 80) (56 113 161) (80 161 230))

*** DONE Exercise 2.38 fold-left
    CLOSED: [2019-09-12 Thu 09:45]
#+begin_src scheme :exports both :results value :noweb-ref fold-left
  (define (fold-left op initial sequence)
    (define (iter result rest)
      (if (null? rest)
	  result
	  (iter (op result (car rest))
		(cdr rest))))
    (iter initial sequence))
#+end_src

#+begin_src scheme :exports both :results output
<<accumulate>>
<<fold-left>>
(show #t " " (accumulate / 1 (list 1 2 3)) "\n")
(show #t " " (fold-left / 1 (list 1 2 3)) "\n")
(show #t " " (accumulate list '() (list 1 2 3)) "\n")
(show #t " " (fold-left list '() (list 1 2 3)) "\n")
(show #t " " (fold-left + 0 (list 1 2 3)) "\n")
(show #t " " (accumulate + 0 (list 1 2 3)) "\n")
#+end_src

#+RESULTS:
:  3/2
:  1/6
:  (1 (2 (3 ())))
:  (((() 1) 2) 3)
:  6
:  6

Well, it seems that commutative operations, that is the ones for which
\(a+b = b+a\).

*** DONE Exercise 2.39 reverse fold-right fold-left
    CLOSED: [2019-09-12 Thu 09:52]

#+begin_src scheme :exports both :results output
<<accumulate>>
<<fold-left>>
  (define (reverse sequence)
    (accumulate (lambda (x y) (cons x y)) '() sequence))
  (show #t " " (reverse (list 1 2 3)) "\n")
  (define (reverse sequence)
    (fold-left  (lambda (x y) (cons y x)) '() sequence))
  (show #t " " (reverse (list 1 2 3)))

#+end_src

#+RESULTS:
:  (1 2 3)
:  (3 2 1)

*** DONE Exercise 2.40 unique-pairs
    CLOSED: [2019-09-12 Thu 10:34]
0:42:00

#+begin_src scheme :exports both :results value :noweb-ref flatmap
  (define (flatmap proc seq)
    (accumulate append '() (map proc seq)))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref prime-sum
  (define (prime-sum? pair)
    (prime? (+ (car pair) (cadr pair))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref make-pair-sum
(define (make-pair-sum pair)
    (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref prime-sum-pairs
  (define (prime-sum-pairs n)
    (map make-pair-sum
	  (filter prime-sum? (flatmap
			      (lambda (i)
				(map (lambda (j) (list i j))
				     (enumerate-interval 1 (- i 1))))
			      (enumerate-interval 1 n)))))
#+end_src

#+begin_src scheme :exports both :results output
<<prime-sum-pairs>>
<<enumerate-interval>>
<<flatmap>>
<<accumulate>>
<<prime-sum>>
<<filter>>
<<fast-prime>>
<<fermat-primetest>>
<<expmod-miller-rabin>>
<<make-pair-sum>>
<<map-append-length>>
(show #t " " (prime-sum-pairs 30))
#+end_src

#+RESULTS:
:  ((2 1 3) (3 2 5) (4 1 5) (4 3 7) (5 2 7) (6 1 7) (6 5 11) (7 4 11) (7 6 13) (8 3 11) (8 5 13) (9 2 11) (9 4 13) (9 8 17) (10 1 11) (10 3 13) (10 7 17) (10 9 19) (11 2 13) (11 6 17) (11 8 19) (12 1 13) (12 5 17) (12 7 19) (12 11 23) (13 4 17) (13 6 19) (13 10 23) (14 3 17) (14 5 19) (14 9 23) (15 2 17) (15 4 19) (15 8 23) (15 14 29) (16 1 17) (16 3 19) (16 7 23) (16 13 29) (16 15 31) (17 2 19) (17 6 23) (17 12 29) (17 14 31) (18 1 19) (18 5 23) (18 11 29) (18 13 31) (19 4 23) (19 10 29) (19 12 31) (19 18 37) (20 3 23) (20 9 29) (20 11 31) (20 17 37) (21 2 23) (21 8 29) (21 10 31) (21 16 37) (21 20 41) (22 1 23) (22 7 29) (22 9 31) (22 15 37) (22 19 41) (22 21 43) (23 6 29) (23 8 31) (23 14 37) (23 18 41) (23 20 43) (24 5 29) (24 7 31) (24 13 37) (24 17 41) (24 19 43) (24 23 47) (25 4 29) (25 6 31) (25 12 37) (25 16 41) (25 18 43) (25 22 47) (26 3 29) (26 5 31) (26 11 37) (26 15 41) (26 17 43) (26 21 47) (27 2 29) (27 4 31) (27 10 37) (27 14 41) (27 16 43) (27 20 47) (27 26 53) (28 1 29) (28 3 31) (28 9 37) (28 13 41) (28 15 43) (28 19 47) (28 25 53) (29 2 31) (29 8 37) (29 12 41) (29 14 43) (29 18 47) (29 24 53) (30 1 31) (30 7 37) (30 11 41) (30 13 43) (30 17 47) (30 23 53) (30 29 59))

#+begin_src scheme :exports both :results value :noweb-ref unique-pairs
  (define (unique-pairs n)
    (flatmap
     (lambda (i)
       (map (lambda (j) (list i j))
	    (enumerate-interval 1 (- i 1))))
     (enumerate-interval 1 n)))
#+end_src

#+begin_src scheme :exports both :results value
  <<unique-pairs>>
  <<flatmap>>
  <<enumerate-interval>>
  <<accumulate>>
  (unique-pairs 3)
#+end_src

#+RESULTS:
| 2 | 1 |
| 3 | 1 |
| 3 | 2 |

#+begin_src scheme :exports both :results value :noweb-ref prime-sum-pairs-unique-pairs
  (define (prime-sum-pairs n)
    (map make-pair-sum
	  (filter prime-sum? (unique-pairs n))))
#+end_src

#+begin_src scheme :exports both :results value
<<unique-pairs>>
<<prime-sum-pairs-unique-pairs>>
<<enumerate-interval>>
<<flatmap>>
<<accumulate>>
<<prime-sum>>
<<filter>>
<<fast-prime>>
<<fermat-primetest>>
<<expmod-miller-rabin>>
<<make-pair-sum>>
<<map-append-length>>
(prime-sum-pairs 10)
#+end_src

#+RESULTS:
|  2 | 1 |  3 |
|  3 | 2 |  5 |
|  4 | 1 |  5 |
|  4 | 3 |  7 |
|  5 | 2 |  7 |
|  6 | 1 |  7 |
|  6 | 5 | 11 |
|  7 | 4 | 11 |
|  7 | 6 | 13 |
|  8 | 3 | 11 |
|  8 | 5 | 13 |
|  9 | 2 | 11 |
|  9 | 4 | 13 |
|  9 | 8 | 17 |
| 10 | 1 | 11 |
| 10 | 3 | 13 |
| 10 | 7 | 17 |
| 10 | 9 | 19 |

I have to note that this deceiptively simple task involves reusing
results of 12 other problems.
 
*** DONE Exercise 2.41 triple-sum
    CLOSED: [2019-09-14 Sat 15:15]
     *Exercise 2.41:* Write a procedure to find all ordered triples of
     distinct positive integers i, j, and k less than or equal to a
     given integer n that sum to a given integer s.

#+begin_src scheme :exports both :results value :noweb-ref unique-triples
    (define (unique-triples n)
      (flatmap
       (lambda (i)
	 (flatmap (lambda (j) 
		(map (lambda (k) (list i j k))
		     (enumerate-interval 1 (- j 1))))
	      (enumerate-interval 1 (- i 1))))
       (enumerate-interval 1 n)))

#+end_src

#+begin_src scheme :exports both :results output
<<accumulate>>
<<enumerate-interval>>
<<flatmap>>
<<unique-triples>>
(show #t " " (unique-triples 5) "\n")
#+end_src

#+RESULTS:
:  ((3 2 1) (4 2 1) (4 3 1) (4 3 2) (5 2 1) (5 3 1) (5 3 2) (5 4 1) (5 4 2) (5 4 3))



#+begin_src scheme :exports both :results value :noweb-ref sum-equal-s
  (define (sum-equal-s? s tuple)
    (if (= s  (accumulate + 0 tuple))
	#t
	#f))
#+end_src

#+begin_src scheme :exports both :results value
<<sum-equal-s>>
<<accumulate>>
(and (sum-equal-s? 30 (list 10 5 5 9 1)) (not (sum-equal-s? 10 (list 3 3 3))))
#+end_src

#+RESULTS:
: #t

#+begin_src scheme :exports both :results value :noweb-ref sum-equal-s-triples
  (define (sum-equal-s-triples s n)
    (filter (lambda (x) (sum-equal-s? s x)) (unique-triples n)))
#+end_src

#+begin_src scheme :exports both :results value
<<enumerate-interval>>
<<flatmap>>
<<sum-equal-s-triples>>
<<accumulate>>
<<sum-equal-s>>
<<filter>>
<<unique-triples>>
(sum-equal-s-triples 15 30)
#+end_src

#+RESULTS:
|  6 | 5 | 4 |
|  7 | 5 | 3 |
|  7 | 6 | 2 |
|  8 | 4 | 3 |
|  8 | 5 | 2 |
|  8 | 6 | 1 |
|  9 | 4 | 2 |
|  9 | 5 | 1 |
| 10 | 3 | 2 |
| 10 | 4 | 1 |
| 11 | 3 | 1 |
| 12 | 2 | 1 |

*** DONE Figure 2.8 A solution to the eight-queens puzzle.

#+begin_src plantuml :exports both :file figure-2-8.png
@startditaa
          +---+---+---+---+---+---+---+---+
          |   |   |   |   |   | Q |   |   |
          +---+---+---+---+---+---+---+---+
          |   |   | Q |   |   |   |   |   |
          +---+---+---+---+---+---+---+---+
          | Q |   |   |   |   |   |   |   |
          +---+---+---+---+---+---+---+---+
          |   |   |   |   |   |   | Q |   |
          +---+---+---+---+---+---+---+---+
          |   |   |   |   | Q |   |   |   |
          +---+---+---+---+---+---+---+---+
          |   |   |   |   |   |   |   | Q |
          +---+---+---+---+---+---+---+---+
          |   | Q |   |   |   |   |   |   |
          +---+---+---+---+---+---+---+---+
          |   |   |   | Q |   |   |   |   |
          +---+---+---+---+---+---+---+---+
@endditaa
#+end_src 

#+RESULTS:
[[file:figure-2-8.png]]

*** DONE Exercise 2.42 k-queens
    CLOSED: [2019-09-17 Tue 22:27]
3:00:00 + 2:00:00 + 1:00:00 = 6:00:00
The commentary to this problem is bad. Firstly, it is *NOT* obvious
that it is even possible to place a queen into every column and every
row. Indeed, in the solution above, this happens to be the case, but
this is by no means obvious.

The second thought: since the algorithm is expected to provide *all*
possible solutions, it should be required have a list of lists... sort
of, to represent the multitude. So ~queens~ should return a list of
lists. 

Secondly, the code given by the authors is totally moronic in at least
two places: 
 1. rest-of-queens? Seriously? Why not "world of queens", or
    "suffix-queens", to make it even more obscure? It should have been
    called "prefix-queens", or, better "queens-already-on-board". We
    are not short of bytes, are we?
 2. who on Earth would call a procedure "queen-cols"? What does it
even mean? Descriptive names -- zero.
 
The third thought: anyone who wants to solve this puzzle, must at
least know what it is for a queen to be "safe". That is, if a queen
number A has a position b_1 then our new queen's B position b_2 must
satisfy : 1) b_2 \neq b_1 2)|b_2 - b_1| \ne B - A. And this must be true
\forall A < B.

The fourth thought: it is *NOT* obvious, but the "rest of queens"
contains the list of queens _in the reversed order_. So ~car~'ing
anything with it represents attaching the queen _to the end_ of the
list. This is why we have *k* supplied as an argument to the ~safe?~
procedure.

#+begin_src scheme :exports both :results value :noweb-ref k-queens
  (define (queens board-size)
    (define (queen-cols k)
      (if (= k 0)
	  (list empty-board)
	  (filter
	   (lambda (positions) (safe? k positions))
	   (flatmap
	    (lambda (rest-of-queens)
	      (map (lambda (new-row)
		     (adjoin-position new-row k rest-of-queens))
		   (enumerate-interval 1 board-size)))
	    (queen-cols (- k 1))))))
    (queen-cols board-size))

#+end_src

#+begin_src scheme :exports both :results output
<<k-queens>>
<<flatmap>>
<<enumerate-interval>>
<<accumulate>>
<<filter>>
  (define empty-board '())
  (define (adjoin-position new-row k rest-of-queens)
    (cons (cons k new-row) rest-of-queens))
  (define (safe? k positions)
    (cond ((null? (cdr positions)) #t)
	  ((= k 1) #t)
	  ((= (cdar positions) (cdadr positions)) #f)
	  ((= (abs (- (cdar positions) (cdadr positions))) (abs (- (caar positions) (caadr positions)))) #f)
	  (else (safe? k (cons (car positions) (cddr positions))))))
(map (lambda (x) (show #t " " x "\n")) (queens 8))
#+end_src

#+RESULTS:
#+begin_example
 ((8 . 4) (7 . 2) (6 . 7) (5 . 3) (4 . 6) (3 . 8) (2 . 5) (1 . 1))
 ((8 . 5) (7 . 2) (6 . 4) (5 . 7) (4 . 3) (3 . 8) (2 . 6) (1 . 1))
 ((8 . 3) (7 . 5) (6 . 2) (5 . 8) (4 . 6) (3 . 4) (2 . 7) (1 . 1))
 ((8 . 3) (7 . 6) (6 . 4) (5 . 2) (4 . 8) (3 . 5) (2 . 7) (1 . 1))
 ((8 . 5) (7 . 7) (6 . 1) (5 . 3) (4 . 8) (3 . 6) (2 . 4) (1 . 2))
 ((8 . 4) (7 . 6) (6 . 8) (5 . 3) (4 . 1) (3 . 7) (2 . 5) (1 . 2))
 ((8 . 3) (7 . 6) (6 . 8) (5 . 1) (4 . 4) (3 . 7) (2 . 5) (1 . 2))
 ((8 . 5) (7 . 3) (6 . 8) (5 . 4) (4 . 7) (3 . 1) (2 . 6) (1 . 2))
 ((8 . 5) (7 . 7) (6 . 4) (5 . 1) (4 . 3) (3 . 8) (2 . 6) (1 . 2))
 ((8 . 4) (7 . 1) (6 . 5) (5 . 8) (4 . 6) (3 . 3) (2 . 7) (1 . 2))
 ((8 . 3) (7 . 6) (6 . 4) (5 . 1) (4 . 8) (3 . 5) (2 . 7) (1 . 2))
 ((8 . 4) (7 . 7) (6 . 5) (5 . 3) (4 . 1) (3 . 6) (2 . 8) (1 . 2))
 ((8 . 6) (7 . 4) (6 . 2) (5 . 8) (4 . 5) (3 . 7) (2 . 1) (1 . 3))
 ((8 . 6) (7 . 4) (6 . 7) (5 . 1) (4 . 8) (3 . 2) (2 . 5) (1 . 3))
 ((8 . 1) (7 . 7) (6 . 4) (5 . 6) (4 . 8) (3 . 2) (2 . 5) (1 . 3))
 ((8 . 6) (7 . 8) (6 . 2) (5 . 4) (4 . 1) (3 . 7) (2 . 5) (1 . 3))
 ((8 . 6) (7 . 2) (6 . 7) (5 . 1) (4 . 4) (3 . 8) (2 . 5) (1 . 3))
 ((8 . 4) (7 . 7) (6 . 1) (5 . 8) (4 . 5) (3 . 2) (2 . 6) (1 . 3))
 ((8 . 5) (7 . 8) (6 . 4) (5 . 1) (4 . 7) (3 . 2) (2 . 6) (1 . 3))
 ((8 . 4) (7 . 8) (6 . 1) (5 . 5) (4 . 7) (3 . 2) (2 . 6) (1 . 3))
 ((8 . 2) (7 . 7) (6 . 5) (5 . 8) (4 . 1) (3 . 4) (2 . 6) (1 . 3))
 ((8 . 1) (7 . 7) (6 . 5) (5 . 8) (4 . 2) (3 . 4) (2 . 6) (1 . 3))
 ((8 . 2) (7 . 5) (6 . 7) (5 . 4) (4 . 1) (3 . 8) (2 . 6) (1 . 3))
 ((8 . 4) (7 . 2) (6 . 7) (5 . 5) (4 . 1) (3 . 8) (2 . 6) (1 . 3))
 ((8 . 5) (7 . 7) (6 . 1) (5 . 4) (4 . 2) (3 . 8) (2 . 6) (1 . 3))
 ((8 . 6) (7 . 4) (6 . 1) (5 . 5) (4 . 8) (3 . 2) (2 . 7) (1 . 3))
 ((8 . 5) (7 . 1) (6 . 4) (5 . 6) (4 . 8) (3 . 2) (2 . 7) (1 . 3))
 ((8 . 5) (7 . 2) (6 . 6) (5 . 1) (4 . 7) (3 . 4) (2 . 8) (1 . 3))
 ((8 . 6) (7 . 3) (6 . 7) (5 . 2) (4 . 8) (3 . 5) (2 . 1) (1 . 4))
 ((8 . 2) (7 . 7) (6 . 3) (5 . 6) (4 . 8) (3 . 5) (2 . 1) (1 . 4))
 ((8 . 7) (7 . 3) (6 . 1) (5 . 6) (4 . 8) (3 . 5) (2 . 2) (1 . 4))
 ((8 . 5) (7 . 1) (6 . 8) (5 . 6) (4 . 3) (3 . 7) (2 . 2) (1 . 4))
 ((8 . 1) (7 . 5) (6 . 8) (5 . 6) (4 . 3) (3 . 7) (2 . 2) (1 . 4))
 ((8 . 3) (7 . 6) (6 . 8) (5 . 1) (4 . 5) (3 . 7) (2 . 2) (1 . 4))
 ((8 . 6) (7 . 3) (6 . 1) (5 . 7) (4 . 5) (3 . 8) (2 . 2) (1 . 4))
 ((8 . 7) (7 . 5) (6 . 3) (5 . 1) (4 . 6) (3 . 8) (2 . 2) (1 . 4))
 ((8 . 7) (7 . 3) (6 . 8) (5 . 2) (4 . 5) (3 . 1) (2 . 6) (1 . 4))
 ((8 . 5) (7 . 3) (6 . 1) (5 . 7) (4 . 2) (3 . 8) (2 . 6) (1 . 4))
 ((8 . 2) (7 . 5) (6 . 7) (5 . 1) (4 . 3) (3 . 8) (2 . 6) (1 . 4))
 ((8 . 3) (7 . 6) (6 . 2) (5 . 5) (4 . 8) (3 . 1) (2 . 7) (1 . 4))
 ((8 . 6) (7 . 1) (6 . 5) (5 . 2) (4 . 8) (3 . 3) (2 . 7) (1 . 4))
 ((8 . 8) (7 . 3) (6 . 1) (5 . 6) (4 . 2) (3 . 5) (2 . 7) (1 . 4))
 ((8 . 2) (7 . 8) (6 . 6) (5 . 1) (4 . 3) (3 . 5) (2 . 7) (1 . 4))
 ((8 . 5) (7 . 7) (6 . 2) (5 . 6) (4 . 3) (3 . 1) (2 . 8) (1 . 4))
 ((8 . 3) (7 . 6) (6 . 2) (5 . 7) (4 . 5) (3 . 1) (2 . 8) (1 . 4))
 ((8 . 6) (7 . 2) (6 . 7) (5 . 1) (4 . 3) (3 . 5) (2 . 8) (1 . 4))
 ((8 . 3) (7 . 7) (6 . 2) (5 . 8) (4 . 6) (3 . 4) (2 . 1) (1 . 5))
 ((8 . 6) (7 . 3) (6 . 7) (5 . 2) (4 . 4) (3 . 8) (2 . 1) (1 . 5))
 ((8 . 4) (7 . 2) (6 . 7) (5 . 3) (4 . 6) (3 . 8) (2 . 1) (1 . 5))
 ((8 . 7) (7 . 1) (6 . 3) (5 . 8) (4 . 6) (3 . 4) (2 . 2) (1 . 5))
 ((8 . 1) (7 . 6) (6 . 8) (5 . 3) (4 . 7) (3 . 4) (2 . 2) (1 . 5))
 ((8 . 3) (7 . 8) (6 . 4) (5 . 7) (4 . 1) (3 . 6) (2 . 2) (1 . 5))
 ((8 . 6) (7 . 3) (6 . 7) (5 . 4) (4 . 1) (3 . 8) (2 . 2) (1 . 5))
 ((8 . 7) (7 . 4) (6 . 2) (5 . 8) (4 . 6) (3 . 1) (2 . 3) (1 . 5))
 ((8 . 4) (7 . 6) (6 . 8) (5 . 2) (4 . 7) (3 . 1) (2 . 3) (1 . 5))
 ((8 . 2) (7 . 6) (6 . 1) (5 . 7) (4 . 4) (3 . 8) (2 . 3) (1 . 5))
 ((8 . 2) (7 . 4) (6 . 6) (5 . 8) (4 . 3) (3 . 1) (2 . 7) (1 . 5))
 ((8 . 3) (7 . 6) (6 . 8) (5 . 2) (4 . 4) (3 . 1) (2 . 7) (1 . 5))
 ((8 . 6) (7 . 3) (6 . 1) (5 . 8) (4 . 4) (3 . 2) (2 . 7) (1 . 5))
 ((8 . 8) (7 . 4) (6 . 1) (5 . 3) (4 . 6) (3 . 2) (2 . 7) (1 . 5))
 ((8 . 4) (7 . 8) (6 . 1) (5 . 3) (4 . 6) (3 . 2) (2 . 7) (1 . 5))
 ((8 . 2) (7 . 6) (6 . 8) (5 . 3) (4 . 1) (3 . 4) (2 . 7) (1 . 5))
 ((8 . 7) (7 . 2) (6 . 6) (5 . 3) (4 . 1) (3 . 4) (2 . 8) (1 . 5))
 ((8 . 3) (7 . 6) (6 . 2) (5 . 7) (4 . 1) (3 . 4) (2 . 8) (1 . 5))
 ((8 . 4) (7 . 7) (6 . 3) (5 . 8) (4 . 2) (3 . 5) (2 . 1) (1 . 6))
 ((8 . 4) (7 . 8) (6 . 5) (5 . 3) (4 . 1) (3 . 7) (2 . 2) (1 . 6))
 ((8 . 3) (7 . 5) (6 . 8) (5 . 4) (4 . 1) (3 . 7) (2 . 2) (1 . 6))
 ((8 . 4) (7 . 2) (6 . 8) (5 . 5) (4 . 7) (3 . 1) (2 . 3) (1 . 6))
 ((8 . 5) (7 . 7) (6 . 2) (5 . 4) (4 . 8) (3 . 1) (2 . 3) (1 . 6))
 ((8 . 7) (7 . 4) (6 . 2) (5 . 5) (4 . 8) (3 . 1) (2 . 3) (1 . 6))
 ((8 . 8) (7 . 2) (6 . 4) (5 . 1) (4 . 7) (3 . 5) (2 . 3) (1 . 6))
 ((8 . 7) (7 . 2) (6 . 4) (5 . 1) (4 . 8) (3 . 5) (2 . 3) (1 . 6))
 ((8 . 5) (7 . 1) (6 . 8) (5 . 4) (4 . 2) (3 . 7) (2 . 3) (1 . 6))
 ((8 . 4) (7 . 1) (6 . 5) (5 . 8) (4 . 2) (3 . 7) (2 . 3) (1 . 6))
 ((8 . 5) (7 . 2) (6 . 8) (5 . 1) (4 . 4) (3 . 7) (2 . 3) (1 . 6))
 ((8 . 3) (7 . 7) (6 . 2) (5 . 8) (4 . 5) (3 . 1) (2 . 4) (1 . 6))
 ((8 . 3) (7 . 1) (6 . 7) (5 . 5) (4 . 8) (3 . 2) (2 . 4) (1 . 6))
 ((8 . 8) (7 . 2) (6 . 5) (5 . 3) (4 . 1) (3 . 7) (2 . 4) (1 . 6))
 ((8 . 3) (7 . 5) (6 . 2) (5 . 8) (4 . 1) (3 . 7) (2 . 4) (1 . 6))
 ((8 . 3) (7 . 5) (6 . 7) (5 . 1) (4 . 4) (3 . 2) (2 . 8) (1 . 6))
 ((8 . 5) (7 . 2) (6 . 4) (5 . 6) (4 . 8) (3 . 3) (2 . 1) (1 . 7))
 ((8 . 6) (7 . 3) (6 . 5) (5 . 8) (4 . 1) (3 . 4) (2 . 2) (1 . 7))
 ((8 . 5) (7 . 8) (6 . 4) (5 . 1) (4 . 3) (3 . 6) (2 . 2) (1 . 7))
 ((8 . 4) (7 . 2) (6 . 5) (5 . 8) (4 . 6) (3 . 1) (2 . 3) (1 . 7))
 ((8 . 4) (7 . 6) (6 . 1) (5 . 5) (4 . 2) (3 . 8) (2 . 3) (1 . 7))
 ((8 . 6) (7 . 3) (6 . 1) (5 . 8) (4 . 5) (3 . 2) (2 . 4) (1 . 7))
 ((8 . 5) (7 . 3) (6 . 1) (5 . 6) (4 . 8) (3 . 2) (2 . 4) (1 . 7))
 ((8 . 4) (7 . 2) (6 . 8) (5 . 6) (4 . 1) (3 . 3) (2 . 5) (1 . 7))
 ((8 . 6) (7 . 3) (6 . 5) (5 . 7) (4 . 1) (3 . 4) (2 . 2) (1 . 8))
 ((8 . 6) (7 . 4) (6 . 7) (5 . 1) (4 . 3) (3 . 5) (2 . 2) (1 . 8))
 ((8 . 4) (7 . 7) (6 . 5) (5 . 2) (4 . 6) (3 . 1) (2 . 3) (1 . 8))
 ((8 . 5) (7 . 7) (6 . 2) (5 . 6) (4 . 3) (3 . 1) (2 . 4) (1 . 8))
#+end_example

Because of really terrible introduction, this exercise took me 6 times
more than it's worth.

*** DONE Exercise 2.43 slow k-queens
    CLOSED: [2019-09-17 Tue 22:55]

To answer this exercise, we need to estimate the complexity of the
canonical solution and Louis' solution.

For the canonical solution, we can safely assume that the ~safe?~
procedure filters out no sequences at all (this would only worsen our
estimate). Therefore, every additional column would multiply the total
computation needed by the size of the column. Roughly speaking, this
would be \(k^k \approx 2^k \rightarrow 2^{}^6 = 64\).

For the Louis's solution, however, the ~(queen-cols (- k 1))~ is
solved for every value of ~k~ from scratch, which is not necessary,
and adds an additional multiplicand of \(k^{k-1}\) for every
~k~. Roughly speaking, this adds an additional power of \(k-1\) to the
solution time. \( (k\cdot T)^k \approx 2^{6k}\rightarrow 2^{36}\). A little bit too much.

*** Remark. Now we are starting the "picture language" chapter. 
It may (and will) require extensive modification to the standard
working environment, because I am not using the most default nowadays
Racket. In this subsection I will implement the required subroutines.

SICP is incredibly confusing in this chapter. 

The following is one of the most prominent examples:
#+begin_src scheme :exports both :results value
(define (segments->painter segment-list)
       (lambda (frame)
         (for-each
          (lambda (segment)
            (draw-line
             ((frame-coord-map frame) (start-segment segment))
             ((frame-coord-map frame) (end-segment segment))))
          segment-list)))
#+end_src

#+begin_src scheme :exports both :results output :noweb-ref draw-line
  (define canvas-size
    (make-parameter
     200
     (lambda (size)
       (if (and (exact-integer? size) (<= 2 size 1000))
	   size
	   (error "invalid canvas size")))))
  (define canvas-file-name
     (make-parameter
        (string-append "./" (substring (process->string "uuidgen") 0 36) ".png")
	(lambda (name)
	  (if (string? name)
	      name
	      (error "invalid canvas file name")))))
  (define (canvas-reset)
    (system "rm" (canvas-file-name))
    (system "convert" "xc:white"
	    "-scale" (string-append
		      (number->string (canvas-size))
		      "x"
		      (number->string (canvas-size)))
	    (canvas-file-name)))
  (define (canvas-refresh)
    (string-append "[[" (canvas-file-name) "]]"))
  (canvas-reset)
  (define (draw-line point1 point2)
    (system "mogrify"
	    "-fill" "black"
	    "-draw" (string-append "line "
				   (number->string (* (canvas-size) (car point1)))
				   ","
				   (number->string (* (canvas-size) (cadr point1)))
				   " "
				   (number->string (* (canvas-size) (car point2)))
				   ","
				   (number->string (* (canvas-size) (cadr point2))))
	    (canvas-file-name))
    #;(display (string-append "[[" (canvas-file-name) "]]"))
    (string-append "[[" (canvas-file-name) "]]"))
#+end_src

#+RESULTS:


#+begin_src scheme :exports both :results raw value
  <<draw-line>>
  (draw-line (list 0 0) (list 1 1))
  (draw-line (list 0 1) (list 1 0))
#+end_src

#+RESULTS:
[[./d890f987-3ba1-41f4-a2b2-c427aa7c2858.gif]]

#+begin_src scheme :exports both :results value :noweb-ref pict-frame
  (define (frame-coord-map frame)
    (lambda (v)
     (add-vect
       (origin-frame frame)
              (add-vect (scale-vect (xcor-vect v) (edge1-frame frame))
		 (scale-vect (ycor-vect v) (edge2-frame frame))))))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results value
  <<make-frame>>
  <<pict-frame>>
  <<pict-vect>>
  ((frame-coord-map
	   (make-frame
	    (make-vect 0.1 0.2)
	    (make-vect 1.0 1.0)
	    (make-vect 1.0 1.0))) (make-vect 0 0))
#+end_src

#+RESULTS:
| 0.1 | 0.2 |

#+begin_src scheme :exports both :results raw value :noweb-ref segments-painter
  (define (segments->painter segment-list)
    (lambda (frame)
      (for-each
       (lambda (segment)
	 (draw-line
	  ((frame-coord-map frame)
	   (start-segment segment))
	  ((frame-coord-map frame)
	   (end-segment segment))))
       segment-list)))
#+end_src

The next is the "rogers" painter. As usual with SICP, fighting with
the programming system takes more time than actually solving anything.
Took me 3 hours. (3:00:00)

Asked a question here: https://www.imagemagick.org/discourse-server/viewtopic.php?f=1&t=36770


#+begin_src scheme :exports both :results value :noweb-ref magick-vect
    (define (pict-vect->magick-vect vector separator)
      (string-append
       (number->string (+ 1 (* (canvas-size) (xcor-vect vector))))
       separator
       (number->string (+ 1 (* (canvas-size) (ycor-vect vector))))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref rogers
  (define (rogers frame)
    (system "convert" 
             (canvas-file-name)
             "("
	     "+distort" "affine"
	     (string-append 
		"1,1 "    "1,1"
		" 149,1 "   (pict-vect->magick-vect (edge1-frame  frame) ",")
                " 1,180 "  (pict-vect->magick-vect (edge2-frame  frame) ","))
             "-background" "transparent"
	     "-splice" (pict-vect->magick-vect
			(origin-frame frame) "x")
             "./assets/rogers.png" ")" 
             "-composite"            
             (canvas-file-name)))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results raw value
<<pict-vect>>
<<pict-frame>>
<<make-frame>>
<<magick-vect>>
<<rogers>>
<<draw-line>>
(rogers (make-frame (make-vect 0 0) (make-vect 1 0) (make-vect 0 1)))
(canvas-refresh)
#+end_src

#+RESULTS:
[[./755096f1-280f-4e39-bd9f-c17dada9ed69.png]]

#+begin_src scheme :exports both :results value :noweb-ref wave-bitmap
  (define (wave frame)
    #;(convert white.gif \( -distort "Affine" "1,1 1,1  1,149 1,200  180,1 200,1"  rogers.png \) -composite  output.gif)
    #;(convert rogers.png  -alpha set -virtual-pixel transparent +distort affine "1,1 1,1 1,50 1,50 50,1 50,50" -background transparent -splice "50x50" output.png)
    (system "convert" 
	     (canvas-file-name)
	     "("
	     "-alpha" "set" "-virtual-pixel" "transparent"
	     "+distort" "affine"
	     (string-append 
		"1,1 "    "1,1"
		" 152,1 "   (pict-vect->magick-vect
			      (edge1-frame  frame) ",")
		" 1,184 "   (pict-vect->magick-vect
			      (edge2-frame  frame) ","))
	     "-background" "transparent"
	     "-splice" (pict-vect->magick-vect
			(origin-frame frame) "x")
	     "./assets/wave.png" ")"
	     "-composite"
	     (canvas-file-name)))
#+end_src

#+RESULTS:
: #<undef>

*** DONE Exercise 2.44 up-split
    CLOSED: [2019-09-23 Mon 22:54]

#+begin_src scheme :exports both :results value :noweb-ref up-split
  (define (up-split painter n)
    (if (= n 0)
	painter
	(let ((smaller (up-split painter (- n 1))))
	  (below painter (beside smaller smaller)))))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results raw value
<<pict-vect>>
<<make-frame>>
<<pict-segment>>
<<segments-painter>>
<<wave-segment>>
<<transform-painter>>
<<pict-frame>>
<<draw-line>>
<<beside>>
<<below-beside>>
<<rotate270>>
<<rotate90>>
<<up-split>>
((up-split wave 1) (make-frame (make-vect 0.0 1.0) (make-vect 1.0 0.0) (make-vect 0.0 -1.0)))
(canvas-refresh)
#+end_src

#+RESULTS:
[[./47ef240d-2a8b-4886-8431-c7aade49fb09.png]]

*** DONE Exercise 2.45 split
    CLOSED: [2019-09-24 Tue 01:37]

#+begin_src scheme :exports both :results value :noweb-ref split
  (define (split op1 op2)
    (define (split-inner painter n)
      (if (= n 0)
      painter
      (let ((smaller (split-inner painter (- n 1))))
	(op2 painter (op1 smaller smaller)))))
    (lambda (painter n)
      (split-inner painter n)))
  (define up-split (split beside below))
  (define right-split (split below beside))
#+end_src

#+begin_src scheme :exports both :results raw value
<<pict-vect>>
<<make-frame>>
<<pict-segment>>
<<segments-painter>>
<<wave-segment>>
<<transform-painter>>
<<pict-frame>>
<<draw-line>>
<<beside>>
<<below-beside>>
<<rotate270>>
<<rotate90>>
<<split>>
((up-split wave 1) (make-frame (make-vect 0.0 1.0) (make-vect 1.0 0.0) (make-vect 0.0 -1.0)))
(canvas-refresh)
#+end_src

#+RESULTS:
[[./43404b14-9224-4b64-b304-7beebed2c3c8.png]]

#+begin_src scheme :exports both :results raw value
<<pict-vect>>
<<make-frame>>
<<pict-segment>>
<<segments-painter>>
<<wave-segment>>
<<transform-painter>>
<<pict-frame>>
<<draw-line>>
<<beside>>
<<below-beside>>
<<rotate270>>
<<rotate90>>
<<split>>
((right-split wave 1) (make-frame (make-vect 0.0 1.0) (make-vect 1.0 0.0) (make-vect 0.0 -1.0)))
(canvas-refresh)
#+end_src

#+RESULTS:
[[./b96c593e-a711-4824-a79c-4b4e911d1374.png]]

*** DONE Exercise 2.46 make-vect
    CLOSED: [2019-09-20 Fri 12:48]
#+begin_src scheme :exports both :results value :noweb-ref pict-vect
  (define (make-vect xcor ycor . o)
    (append (list xcor) (list ycor) o))
  (define (xcor-vect vect)
    (car vect))
  (define (ycor-vect vect)
    (cadr vect))
  (define (scale-vect scale vect)
    (map (lambda (x) (* x scale)) vect))
  (define (add-vect vec1 vec2)
    (map (lambda (cor1 cor2) (+ cor1 cor2)) vec1 vec2))
  (define (sub-vect vec1 vec2)
    (map (lambda (cor1 cor2) (- cor1 cor2)) vec1 vec2))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results output
<<pict-vect>>
(show #t (make-vect 1 2 3) "\n")
(show #t (xcor-vect (make-vect 1 2 3)) "\n")
(show #t (ycor-vect (make-vect 1 2 3)) "\n")
(show #t (scale-vect 2 (make-vect 1 2 3)) "\n")
(show #t (add-vect (make-vect 1 2 3) (make-vect 1 2 3)) "\n")
(show #t (sub-vect (make-vect 1 2 3) (make-vect 1 2 3)) "\n")
#+end_src

#+RESULTS:
: (1 2 3)
: 1
: 2
: (2 4 6)
: (2 4 6)
: (0 0 0)

*** DONE Exercise 2.47 make-frame
    CLOSED: [2019-09-20 Fri 14:48]
#+begin_src scheme :exports both :results value :noweb-ref make-frame
(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))
(define (origin-frame frame)
  (car frame))
(define (edge1-frame frame)
  (cadr frame))
(define (edge2-frame frame)
  (caddr frame))
#+end_src
#+begin_src scheme :exports both :results output
<<make-frame>>
<<pict-vect>>
(make-frame (make-vect 0.1 0.2) (make-vect 0.1 0.2) (make-vect 0.0 0.3))
(origin-frame (make-frame (make-vect 0.1 0.2) (make-vect 0.1 0.2) (make-vect 0.0 0.3)))
(edge1-frame  (make-frame (make-vect 0.1 0.2) (make-vect 0.1 0.2) (make-vect 0.0 0.3)))
(edge2-frame  (make-frame (make-vect 0.1 0.2) (make-vect 0.1 0.2) (make-vect 0.0 0.3)))
#+end_src

#+RESULTS:

#+begin_src scheme :exports both :results output
<<pict-vect>>
  (define (make-frame origin edge1 edge2)
    (cons origin (cons edge1 edge2)))
  (define (origin-frame frame)
    (car frame))
  (define (edge1-frame frame)
    (cadr frame))
  (define (edge2-frame frame)
    (cddr frame))
  (show #t (origin-frame (make-frame (make-vect 0.1 0.2) (make-vect 0.1 0.2) (make-vect 0.0 0.3))) "\n")
  (show #t (edge1-frame (make-frame (make-vect 0.1 0.2) (make-vect 0.1 0.2) (make-vect 0.0 0.3))) "\n")
  (show #t (edge2-frame (make-frame (make-vect 0.1 0.2) (make-vect 0.1 0.2) (make-vect 0.0 0.3))) "\n")
#+end_src

#+RESULTS:
: (0.1 0.2)
: (0.1 0.2)
: (0.0 0.3)

*** DONE Exercise 2.48 make-segment
    CLOSED: [2019-09-20 Fri 16:06]
#+begin_src scheme :exports both :results value :noweb-ref pict-segment
  (define (make-segment start-vector end-vector)
    (list start-vector end-vector))
  (define (start-segment segment)
    (car segment))
  (define (end-segment segment)
    (cadr segment))
#+end_src

#+begin_src scheme :exports both :results raw value
  <<draw-line>>
  <<pict-segment>>
  <<segments-painter>>
  <<pict-vect>>
  <<make-frame>>
  <<pict-frame>>
  ((segments->painter
    (list
     (make-segment (make-vect 0 0) (make-vect 1 1))
     (make-segment (make-vect 0 1) (make-vect 1 0))))
   (make-frame (make-vect 0 0) (make-vect 0 1) (make-vect 1 0)))
  (canvas-refresh)
#+end_src

#+RESULTS:
[[/tmp/scheme-temp.gif]]

*** DONE Exercise 2.49 segments->painter applications
    CLOSED: [2019-09-20 Fri 23:10]

#+begin_src scheme :exports both :results value :noweb-ref x-painter
(define x-painter
  (segments->painter
    (list
     (make-segment (make-vect 0 0) (make-vect 1 1))
     (make-segment (make-vect 0 1) (make-vect 1 0)))))
#+end_src

#+begin_src scheme :exports both :results raw value
  <<draw-line>>
  <<pict-segment>>
  <<segments-painter>>
  <<pict-vect>>
  <<make-frame>>
  <<pict-frame>>
  <<x-painter>>
  (x-painter
   (make-frame (make-vect 0 0) (make-vect 0 1) (make-vect 1 0)))
  (canvas-refresh)
#+end_src

#+RESULTS:
[[./a58f8946-42b6-43c4-89a5-59e892599394.gif]]

This painter is not entirely accurate, because my background is black,
so the lines would coalesce with it. I therefore just moved the lines
a little bit inside.

#+begin_src scheme :exports both :results value :noweb-ref frame-boundary-painter
(define frame-boundary-painter
  (segments->painter
    (list
     (make-segment (make-vect 0.01 0.01) (make-vect 0.01 0.99))
     (make-segment (make-vect 0.01 0.99) (make-vect 0.99 0.99))
     (make-segment (make-vect 0.99 0.99) (make-vect 0.99 0.01))
     (make-segment (make-vect 0.99 0.01) (make-vect 0.01 0.01)))))
#+end_src

#+begin_src scheme :exports both :results raw value
  <<draw-line>>
  <<pict-segment>>
  <<segments-painter>>
  <<pict-vect>>
  <<make-frame>>
  <<pict-frame>>
  <<frame-boundary-painter>>

  (frame-boundary-painter
   (make-frame (make-vect 0.1 0.1) (make-vect 0.1 0.05) (make-vect 0.5 0)))
  (canvas-refresh)
#+end_src

#+RESULTS:
[[./c03f59fb-c473-4cc1-bb80-20c97e7e7594.gif]]

#+begin_src scheme :exports both :results value :noweb-ref diamond-painter
(define diamond-painter
  (segments->painter
    (list
     (make-segment (make-vect 0.01 0.5) (make-vect 0.5 0.99))
     (make-segment (make-vect 0.5 0.99) (make-vect 0.99 0.5))
     (make-segment (make-vect 0.99 0.5) (make-vect 0.5 0.01))
     (make-segment (make-vect 0.5 0.01) (make-vect 0.01 0.5)))))
#+end_src

#+begin_src scheme :exports both :results raw value
  <<draw-line>>
  <<pict-segment>>
  <<segments-painter>>
  <<pict-vect>>
  <<make-frame>>
  <<pict-frame>>
  <<diamond-painter>>

  (diamond-painter
   (make-frame (make-vect 0 0) (make-vect 0 1) (make-vect 1 0)))
  (canvas-refresh)
#+end_src

#+RESULTS:
[[./90918df1-a802-4df6-a10d-afc50547bc72.gif]]

Remark: the exercise 2.49d is ambiguous. The "Unofficial Texinfo Version"
differs with the official paper version in this respect, since in the paper
version the waving figurine is drawn with segments, whereas the UTF uses a
bitmap.
This is the rough solution to the "segment-based" version.

#+begin_src scheme :exports both :results value :noweb-ref wave-segment
(define wave 
   (segments->painter 
        (list 
               (make-segment (make-vect .25 0) (make-vect .35 .5)) 
               (make-segment (make-vect .35 .5) (make-vect .3 .6)) 
               (make-segment (make-vect .3 .6) (make-vect .15 .4)) 
               (make-segment (make-vect .15 .4) (make-vect 0 .65)) 
               (make-segment (make-vect 0 .65) (make-vect 0 .85)) 
               (make-segment (make-vect 0 .85) (make-vect .15 .6)) 
               (make-segment (make-vect .15 .6) (make-vect .3 .65)) 
               (make-segment (make-vect .3 .65) (make-vect .4 .65)) 
               (make-segment (make-vect .4 .65) (make-vect .35 .85)) 
               (make-segment (make-vect .35 .85) (make-vect .4 1)) 
               (make-segment (make-vect .4 1) (make-vect .6 1)) 
               (make-segment (make-vect .6 1) (make-vect .65 .85)) 
               (make-segment (make-vect .65 .85) (make-vect .6 .65)) 
               (make-segment (make-vect .6 .65) (make-vect .75 .65)) 
               (make-segment (make-vect .75 .65) (make-vect 1 .35)) 
               (make-segment (make-vect 1 .35) (make-vect 1 .15)) 
               (make-segment (make-vect 1 .15) (make-vect .6 .45)) 
               (make-segment (make-vect .6 .45) (make-vect .75 0)) 
               (make-segment (make-vect .75 0) (make-vect .6 0)) 
               (make-segment (make-vect .6 0) (make-vect .5 .3)) 
               (make-segment (make-vect .5 .3) (make-vect .4 0)) 
               (make-segment (make-vect .4 0) (make-vect .25 0)) 
        )
   )
)
#+end_src


#+begin_src scheme :exports both :results raw value
<<pict-vect>>
<<pict-frame>>
<<magick-vect>>
<<make-frame>>
<<pict-segment>>
<<segments-painter>>
<<wave-segment>>
<<draw-line>>
(wave (make-frame (make-vect 0.0 0.9) (make-vect 0.7 0) (make-vect 0 -0.7)))
(canvas-refresh)
#+end_src

#+RESULTS:
[[./d9f0731a-a257-49cf-a71d-f8d3ab9e33ed.png]]

*** DONE Exercise 2.50 flip-horiz and rotate270 and rotate180
    CLOSED: [2019-09-20 Fri 23:37]
0:27:00
#+begin_src scheme :exports both :results value :noweb-ref transform-painter
  (define (transform-painter painter origin corner1 corner2)
    (lambda (frame)
      (let ((m (frame-coord-map frame)))
	(let ((new-origin (m origin)))
	  (painter (make-frame
		    new-origin
		    (sub-vect (m corner1) new-origin)
		    (sub-vect (m corner2) new-origin)))))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref flip-horiz
  (define (flip-horiz painter)
    (transform-painter painter
		       (make-vect 1.0 0.0)
		       (make-vect 0.0 0.0)
		       (make-vect 1.0 1.0)))
#+end_src

#+begin_src scheme :exports both :results raw value
<<flip-horiz>>
<<pict-vect>>
<<pict-segment>>
<<segments-painter>>
<<transform-painter>>
<<make-frame>>
<<pict-frame>>
<<draw-line>>
<<wave-segment>>
(define bltr-line-painter
  (segments->painter
    (list
     (make-segment (make-vect 0.0 0.00) (make-vect 1 1.0)))))
((flip-horiz wave) (make-frame (make-vect 0 1) (make-vect 1 0) (make-vect 0 -1)))
(canvas-refresh)
#+end_src

#+RESULTS:
[[./869de2d3-55f5-429a-ad9d-4941405a8d73.png]]

#+begin_src scheme :exports both :results value :noweb-ref rotate180
  (define (rotate180 painter)
    (transform-painter painter
		       (make-vect 1.0 1.0)
		       (make-vect 0.0 1.0)
		       (make-vect 1.0 0.0)))
#+end_src

#+begin_src scheme :exports both :results raw value
<<rotate180>>
<<pict-vect>>
<<pict-segment>>
<<segments-painter>>
<<transform-painter>>
<<make-frame>>
<<pict-frame>>
<<draw-line>>
<<wave-segment>>
(define ne-arrow-painter
  (segments->painter
    (list
     (make-segment (make-vect 0.0 0.00) (make-vect 0.9 0.9))
     (make-segment (make-vect 0.9 0.9) (make-vect 0.9 0.7))
     (make-segment (make-vect 0.9 0.9) (make-vect 0.7 0.9)))))
#;(ne-arrow-painter (make-frame (make-vect 0 0) (make-vect 0 1) (make-vect 1 0)))
((rotate180 wave) (make-frame (make-vect 0 1) (make-vect 1 0) (make-vect 0 -1)))
(canvas-refresh)
#+end_src

#+RESULTS:
[[./51986072-473e-425b-959a-1bd81f471447.png]]

#+begin_src scheme :exports both :results value :noweb-ref rotate270
  (define (rotate270 painter)
    (transform-painter painter
		       (make-vect 0.0 1.0)
		       (make-vect 0.0 0.0)
		       (make-vect 1.0 1.0)))
#+end_src


#+begin_src scheme :exports both :results raw value
<<pict-vect>>
<<make-frame>>
<<rogers>>
<<transform-painter>>
<<pict-frame>>
<<draw-line>>
<<beside>>
<<below-beside>>
<<rotate270>>
<<pict-segment>>
<<segments-painter>>
<<wave-segment>>
#;((below rogers wave) (make-frame (make-vect 0.0 0.0) (make-vect 1.0 0.0) (make-vect 0.0 1.0)))
((rotate270 wave) (make-frame (make-vect 0.0 1.0) (make-vect 1.0 0.0) (make-vect 0.0 -1.0)))
(canvas-refresh)
#+end_src

#+RESULTS:
[[./33a0bb01-aa51-420c-964d-73d089388c6c.png]]

*** DONE Exercise 2.51 below
    CLOSED: [2019-09-22 Sun 18:50]

#+begin_src scheme :exports both :results value :noweb-ref beside
  (define (beside painter1 painter2)
    (let ((split-point (make-vect 0.5 0.0)))
      (let ((paint-left
	     (transform-painter
	      painter1
	      (make-vect 0.0 0.0)
	      split-point
	      (make-vect 0.0 1.0)))
	    (paint-right
	     (transform-painter
	      painter2
	      split-point
	      (make-vect 1.0 0.0)
	      (make-vect 0.5 1.0))))
	(lambda (frame)
	  (paint-left frame)
	  (paint-right frame)))))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results value :noweb-ref below
  (define (below painter1 painter2)
    (let ((split-point (make-vect 0.0 0.5)))
      (let ((paint-bottom
	     (transform-painter
	      painter1
	      (make-vect 0.0 0.5)
	      (make-vect 1.0 0.5)
	      (make-vect 0.0 1.0)))
	    (paint-top
	     (transform-painter
	      painter2
	      (make-vect 0.0 0.0)
	      (make-vect 1.0 0.0)
	      split-point)))
	(lambda (frame)
	  (paint-top frame)
	  (paint-bottom frame)))))

#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results raw value
<<pict-vect>>
<<make-frame>>
<<wave-segment>>
<<rogers>>
<<below>>
<<transform-painter>>
<<pict-frame>>
<<draw-line>>
((below wave wave) (make-frame (make-vect 0.0 0.0) (make-vect 1.0 0.0) (make-vect 0.0 1.0)))
(canvas-refresh)
#+end_src

#+RESULTS:
[[./24869881-98d4-4a72-87e8-8b3c095f408c.png]]

#+begin_src scheme :exports both :results value :noweb-ref below-beside
  (define (below painter1 painter2)
    (rotate90 (beside (rotate270 painter1) (rotate270 painter2))))
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results value :noweb-ref rotate90
  (define (rotate90 painter)
    (transform-painter painter
		       (make-vect 1.0 0.0)
		       (make-vect 1.0 1.0)
		       (make-vect 0.0 0.0)))

#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results raw value
<<pict-vect>>
<<make-frame>>
<<pict-segment>>
<<segments-painter>>
<<wave-segment>>
<<transform-painter>>
<<pict-frame>>
<<draw-line>>
<<magick-vect>>
<<beside>>
<<below-beside>>
<<rotate270>>
<<rotate90>>
((below wave wave) (make-frame (make-vect 0.0 1.0) (make-vect 1.0 0.0) (make-vect 0.0 -1.0)))
#;((rotate270 rogers) (make-frame (make-vect 0.0 0.0) (make-vect 1.0 0.0) (make-vect 0.0 1.0)))
(canvas-refresh)
#+end_src

#+RESULTS:
[[./13aec801-0171-4497-841c-5fa9c603c73b.png]]


Remark: imagemagick is a horrible piece of software, even though we have
nothing better. 

*** DONE Exercise 2.52 modify square-limit
    CLOSED: [2019-09-24 Tue 12:25]

To complete this exercise, we would first need to implement the square limit.

#+begin_src scheme :exports both :results value :noweb-ref square-limit
    (define (square-limit painter n)
      (let ((combine4 (square-of-four flip-horiz identity
				      rotate180 flip-vert)))
	(combine4 (corner-split painter n))))

    (define (square-of-four tl tr bl br)
      (lambda (painter)
	(let ((top (beside (tl painter) (tr painter)))
	      (bottom (beside (bl painter) (br painter))))
	  (below bottom top))))

    (define (corner-split painter n)
      (if (= n 0)
	  painter
	  (let ((up (up-split painter (- n 1)))
		(right (right-split painter (- n 1))))
	    (let ((top-left (beside up up))
		  (bottom-right (below right right))
		  (corner (corner-split painter (- n 1))))
	      (beside (below painter top-left)
		      (below bottom-right corner))))))
  (define (flip-vert painter)
    (transform-painter painter
		       (make-vect 0.0 1.0)
		       (make-vect 1.0 1.0)
		       (make-vect 0.0 0.0)))
  (define (identity x)
    x)
#+end_src

Because the exercise requires modification of the existing functions (and I
don't want to advise them), I'd just splice all the source code into one block.

#+begin_src scheme :exports both :results raw value
    (define (square-limit painter n)
      (let ((combine4 (square-of-four flip-horiz identity
				      rotate180 flip-vert)))
	(combine4 (corner-split painter n))))

    (define (square-of-four tl tr bl br)
      (lambda (painter)
	(let ((top (beside (flip-horiz (tl painter)) (tr painter)))
	      (bottom (beside (bl painter) (br painter))))
	  (below bottom top))))

    (define (corner-split painter n)
      (if (= n 0)
	  painter
	  (let ((up (up-split painter (- n 1)))
		(right (right-split painter (- n 1))))
	    (let ((top-left (beside up up))
		  (bottom-right (below right right))
		  (corner (corner-split painter (- n 1))))
	      (below (below painter top-left)
		      (below bottom-right corner))))))
  (define (flip-vert painter)
    (transform-painter painter
		       (make-vect 0.0 1.0)
		       (make-vect 1.0 1.0)
		       (make-vect 0.0 0.0)))
  (define (identity x)
    x)
  (define (make-vect xcor ycor . o)
    (append (list xcor) (list ycor) o))
  (define (xcor-vect vect)
    (car vect))
  (define (ycor-vect vect)
    (cadr vect))
  (define (scale-vect scale vect)
    (map (lambda (x) (* x scale)) vect))
  (define (add-vect vec1 vec2)
    (map (lambda (cor1 cor2) (+ cor1 cor2)) vec1 vec2))
  (define (sub-vect vec1 vec2)
    (map (lambda (cor1 cor2) (- cor1 cor2)) vec1 vec2))
  (define (make-frame origin edge1 edge2)
    (list origin edge1 edge2))
  (define (origin-frame frame)
    (car frame))
  (define (edge1-frame frame)
    (cadr frame))
  (define (edge2-frame frame)
    (caddr frame))
  (define (make-segment start-vector end-vector)
    (list start-vector end-vector))
  (define (start-segment segment)
    (car segment))
  (define (end-segment segment)
    (cadr segment))
  (define (segments->painter segment-list)
    (lambda (frame)
      (for-each
       (lambda (segment)
	 (draw-line
	  ((frame-coord-map frame)
	   (start-segment segment))
	  ((frame-coord-map frame)
	   (end-segment segment))))
       segment-list)))
  (define wave 
     (segments->painter 
	  (list 
		 (make-segment (make-vect .25 0) (make-vect .35 .5)) 
		 (make-segment (make-vect .35 .5) (make-vect .3 .6)) 
		 (make-segment (make-vect .3 .6) (make-vect .15 .4)) 
		 (make-segment (make-vect .15 .4) (make-vect 0 .65)) 
		 (make-segment (make-vect 0 .65) (make-vect 0 .85)) 
		 (make-segment (make-vect 0 .85) (make-vect .15 .6)) 
		 (make-segment (make-vect .15 .6) (make-vect .3 .65)) 
		 (make-segment (make-vect .3 .65) (make-vect .4 .65)) 
		 (make-segment (make-vect .4 .65) (make-vect .35 .85)) 
		 (make-segment (make-vect .35 .85) (make-vect .4 1)) 
		 (make-segment (make-vect .4 1) (make-vect .6 1)) 
		 (make-segment (make-vect .6 1) (make-vect .65 .85)) 
		 (make-segment (make-vect .65 .85) (make-vect .6 .65)) 
		 (make-segment (make-vect .6 .65) (make-vect .75 .65)) 
		 (make-segment (make-vect .75 .65) (make-vect 1 .35)) 
		 (make-segment (make-vect 1 .35) (make-vect 1 .15)) 
		 (make-segment (make-vect 1 .15) (make-vect .6 .45)) 
		 (make-segment (make-vect .6 .45) (make-vect .75 0)) 
		 (make-segment (make-vect .75 0) (make-vect .6 0)) 
		 (make-segment (make-vect .6 0) (make-vect .5 .3)) 
		 (make-segment (make-vect .5 .3) (make-vect .4 0)) 
		 (make-segment (make-vect .4 0) (make-vect .25 0))
                 (make-segment (make-vect 0.45 0.5) (make-vect 0.50 0.45))
                 (make-segment (make-vect 0.5 0.45) (make-vect 0.55 0.50)) 
	  )
     )
  )
  (define (transform-painter painter origin corner1 corner2)
    (lambda (frame)
      (let ((m (frame-coord-map frame)))
	(let ((new-origin (m origin)))
	  (painter (make-frame
		    new-origin
		    (sub-vect (m corner1) new-origin)
		    (sub-vect (m corner2) new-origin)))))))
  (define (frame-coord-map frame)
    (lambda (v)
     (add-vect
       (origin-frame frame)
	      (add-vect (scale-vect (xcor-vect v) (edge1-frame frame))
		 (scale-vect (ycor-vect v) (edge2-frame frame))))))
  (define canvas-size
    (make-parameter
     200
     (lambda (size)
       (if (and (exact-integer? size) (<= 2 size 1000))
	   size
	   (error "invalid canvas size")))))
  (define canvas-file-name
     (make-parameter
	(string-append "./" (substring (process->string "uuidgen") 0 36) ".png")
	(lambda (name)
	  (if (string? name)
	      name
	      (error "invalid canvas file name")))))
  (define (canvas-reset)
    (system "rm" (canvas-file-name))
    (system "convert" "xc:white"
	    "-scale" (string-append
		      (number->string (canvas-size))
		      "x"
		      (number->string (canvas-size)))
	    (canvas-file-name)))
  (define (canvas-refresh)
    (string-append "[[" (canvas-file-name) "]]"))
  (canvas-reset)
  (define (draw-line point1 point2)
    (system "mogrify"
	    "-fill" "black"
	    "-draw" (string-append "line "
				   (number->string (* (canvas-size) (car point1)))
				   ","
				   (number->string (* (canvas-size) (cadr point1)))
				   " "
				   (number->string (* (canvas-size) (car point2)))
				   ","
				   (number->string (* (canvas-size) (cadr point2))))
	    (canvas-file-name))
    (string-append "[[" (canvas-file-name) "]]"))
  (define (beside painter1 painter2)
    (let ((split-point (make-vect 0.5 0.0)))
      (let ((paint-left
	     (transform-painter
	      painter1
	      (make-vect 0.0 0.0)
	      split-point
	      (make-vect 0.0 1.0)))
	    (paint-right
	     (transform-painter
	      painter2
	      split-point
	      (make-vect 1.0 0.0)
	      (make-vect 0.5 1.0))))
	(lambda (frame)
	  (paint-left frame)
	  (paint-right frame)))))
  (define (below painter1 painter2)
    (rotate90 (beside (rotate270 painter1) (rotate270 painter2))))
  (define (rotate270 painter)
    (transform-painter painter
		       (make-vect 0.0 1.0)
		       (make-vect 0.0 0.0)
		       (make-vect 1.0 1.0)))
  (define (rotate90 painter)
    (transform-painter painter
		       (make-vect 1.0 0.0)
		       (make-vect 1.0 1.0)
		       (make-vect 0.0 0.0)))

  (define (rotate180 painter)
    (transform-painter painter
		       (make-vect 1.0 1.0)
		       (make-vect 0.0 1.0)
		       (make-vect 1.0 0.0)))
  (define (split op1 op2)
    (define (split-inner painter n)
      (if (= n 0)
      painter
      (let ((smaller (split-inner painter (- n 1))))
	(op2 painter (op1 smaller smaller)))))
    (lambda (painter n)
      (split-inner painter n)))
  (define up-split (split beside below))
  (define right-split (split below beside))
  (define (flip-horiz painter)
    (transform-painter painter
		       (make-vect 1.0 0.0)
		       (make-vect 0.0 0.0)
		       (make-vect 1.0 1.0)))
  ((square-limit wave 1) (make-frame (make-vect 0.0 1.0) (make-vect 1.0 0.0) (make-vect 0.0 -1.0)))
  (canvas-refresh)
#+end_src

#+RESULTS:
[[./f2d16f96-de16-45f7-9f7f-1e31397e4d61.png]]

 a. I added a check-mark at the segments->painter level.
 b. Replaced the last ~beside~ with ~below~ at the lowest level.
 c. Added a ~flip-horiz~ at the level of the ~square-of-four~.

*** Remark. Here the picture language chapter stops
The bitmap loader used by the ~rogers~ painter is not very reliable, so it
will not probably be able to replicate the full ~square-limit~. You can try
though. 
*** DONE Exercise 2.53 quote introduction
    CLOSED: [2019-09-24 Tue 12:36]
#+begin_src scheme :exports both :results output
(show #t (list 'a 'b 'c) "\n")
(show #t (list (list 'george)) "\n")
(show #t (cdr '((x1 x2) (y1 y2))) "\n")
(show #t (cadr '((x1 x2) (y1 y2))) "\n")
(show #t (pair? (car '(a short list))) "\n")
(show #t (memq 'red '((red shoes) (blue socks))) "\n")
(show #t (memq 'red '(red shoes blue socks)) "\n")
#+end_src

#+RESULTS:
: (a b c)
: ((george))
: ((y1 y2))
: (y1 y2)
: #f
: #f
: (red shoes blue socks)

*** DONE Exercise 2.54 equal? implementation
    CLOSED: [2019-09-24 Tue 13:48]
#+begin_src scheme :exports both :results output :noweb-ref equal-implementation
  (define (equal? o1 o2)
    (cond ((eq? o1 o2) #t)
	  ((and (list? o1) (list? o2))     (accumulate (lambda (x y) (and x y)) #t (map equal? o1 o2)))
	  ((and (number? o1) (number? o2)) (= o1 o2))
	  (else #f)))
#+end_src

#+RESULTS:


#+begin_src scheme :exports both :results output
<<accumulate>>

<<equal-implementation>>

(show #t (equal? '(this is a list) '(this is a list)) "\n")
(show #t (equal? '(this is a list) '(this (is a) list)) "\n")
#+end_src

#+RESULTS:
: #t
: #f

*** DONE Exercise 2.55 quote quote
    CLOSED: [2019-09-24 Tue 13:48]
This is really easy.
~(car ''abracadabra)~ is in reality ~(car (quote (quote abracadabra)))~. The
second ~'~ gets automatically translated into a ~quote~ and is not interpreted.
*** DONE Exercise 2.56 differentiation-exponentiation
    CLOSED: [2019-09-24 Tue 23:14]
#+begin_src scheme :exports both :results value :noweb-ref deriv-basic
  (define (deriv exp var)
    (cond ((number? exp) 0)
	  ((variable? exp) (if (same-variable? exp var) 1 0))
	  ((sum? exp) (make-sum (deriv (addend exp) var)
				(deriv (augend exp) var)))
	  ((product? exp)
	   (make-sum
	    (make-product (multiplier exp)
			  (deriv (multiplicand exp) var))
	    (make-product (deriv (multiplier exp) var)
			  (multiplicand exp))))
	  (else
	   (error "unknown expression type: DERIV" exp))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref deriv-components
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1) (variable? v2) (eq? v1 v2)))
  (define (=number? exp num)
    (and (number? exp) (= exp num)))
#+end_src
  
#+begin_src scheme :exports both :results value :noweb-ref deriv-operations
  (define (make-sum a1 a2 . rest)
    (cond ((=number? a1 0) a2)
	  ((=number? a2 0) a1)
	  ((and (number? a1) (number? a2))
	   (+ a1 a2))
	  (else (list '+ a1 a2))))
  (define (make-product m1 m2)
    (cond ((or (=number? m1 0) (=number? m2 0)) 0)
	  ((=number? m1 1) m2)
	  ((=number? m2 1) m1)
	  ((and (number? m1) (number? m2)) (* m1 m2))
	  (else (list '* m1 m2))))
  (define (sum? x) (and (pair? x) (eq? (car x) '+)))
  (define (addend s) (cadr s))
  (define (augend s) (caddr s))
  (define (product? x) (and (pair? x) (eq? (car x) '*)))
  (define (multiplier p) (cadr p))
  (define (multiplicand p) (caddr p))

#+end_src

#+begin_src scheme :exports both :results output
<<deriv-basic>>
<<deriv-components>>
<<deriv-operations>>
(show #t (deriv '(+ x 3) 'x) "\n")
(show #t (deriv '(* x y) 'x) "\n")
(show #t (deriv '(* (* x y) (+ x 3)) 'x) "\n")
#+end_src

#+RESULTS:
: 1
: y
: (+ (* x y) (* y (+ x 3)))

#+begin_src scheme :exports both :results value :noweb-ref deriv-and-exponent

  (define (deriv exp var)
    (cond ((number? exp) 0)
	  ((variable? exp) (if (same-variable? exp var) 1 0))
	  ((sum? exp) (make-sum (deriv (addend exp) var)
				(deriv (augend exp) var)))
	  ((product? exp)
	   (make-sum
	    (make-product 
	     (multiplier exp)
	     (deriv
	      (multiplicand exp)
	      var))
	    (make-product
	     (deriv
	      (multiplier exp)
	      var)
	     (multiplicand exp))))
	  ((exponentiation? exp)
	   (make-product (exponent exp)
			 (make-product
			  (make-exponentiation
			   (base exp)
			   (make-sum (exponent exp) -1))
			  (deriv (base exp) var))))
	  (else
	   (error "unknown expression type: DERIV" exp))))

  (define (make-exponentiation base power)
    (cond ((=number? power 0) 1)
	  ((=number? power 1) base)
	  ((and (number? base) (number? power))
	   (expt base power))
	  (else (list '** base power))))
  (define (exponentiation? x) (and (pair? x) (eq? (car x) '**)))
  (define (base s) (cadr s))
  (define (exponent s) (caddr s))

#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results output
<<deriv-and-exponent>>
<<deriv-components>>
<<deriv-operations>>
(show #t (deriv '(** x 3) 'x) "\n")
(show #t (deriv '(** (* (* x y) (+ x 3)) 5) 'x) "\n")
#+end_src

#+RESULTS:
: (* 3 (** x 2))
: (* 5 (* (** (* (* x y) (+ x 3)) 4) (+ (* x y) (* y (+ x 3)))))

*** DONE Exercise 2.57 differentiate-three-sum
    CLOSED: [2019-09-25 Wed 12:40]
#+begin_src scheme :exports both :results value :noweb-ref deriv-operations-three
  (define (make-sum a1 a2 . rest)
    (if (null? rest)
	(cond ((=number? a1 0) a2)
	      ((=number? a2 0) a1)
	      ((and (number? a1) (number? a2))
	       (+ a1 a2))
	      (else (list '+ a1 a2)))
	(make-sum a1 (apply make-sum a2 (car rest) (cdr rest)))))
  (define (make-product m1 m2 . rest)
    (if (null? rest)
	(cond ((or (=number? m1 0) (=number? m2 0)) 0)
	  ((=number? m1 1) m2)
	  ((=number? m2 1) m1)
	  ((and (number? m1) (number? m2)) (* m1 m2))
	  (else (list '* m1 m2)))
	(make-product m1 (apply make-product m2 (car rest) (cdr rest)))))
  (define (sum? x) (and (pair? x) (eq? (car x) '+)))
  (define (addend s) (cadr s))
  (define (augend s)
    (if (null? (cdddr s))
	(caddr s)
	(apply make-sum (cddr s))))
  (define (product? x) (and (pair? x) (eq? (car x) '*)))
  (define (multiplier p) (cadr p))
  (define (multiplicand p)
    (if (null? (cdddr p))
	(caddr p)
	(apply make-product (cddr p))))

#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results output
<<deriv-and-exponent>>
<<deriv-components>>
<<deriv-operations-three>>
(show #t (deriv '(** x 3) 'x) "\n")
(show #t (deriv '(* x y z) 'y) "\n")
(show #t (deriv '(** (* (* x y z) (+ x 3)) 5) 'x) "\n")
#+end_src

#+RESULTS:
: (* 3 (** x 2))
: (* x z)
: (* 5 (* (** (* (* x y z) (+ x 3)) 4) (+ (* x y z) (* (* y z) (+ x 3)))))

*** DONE Exercise 2.58 infix-notation
    CLOSED: [2019-09-25 Wed 15:21]

This solution is copied from http://community.schemewiki.org/?sicp-ex2.58
almost verbatim. Courtesy of sgm.

#+begin_src scheme :exports both :results output
(define (singleton? lst)
  (= 1 (length lst)))
(define (sum? expr) 
   (eq? '+ (smallest-op expr))) 
  
 (define (product? expr) 
   (eq? '* (smallest-op expr))) 
(define (smallest-op expr) 
   (accumulate (lambda (a b) 
                 (if (operator? b) 
                     (min-precedence a b) 
                     a)) 
               'maxop 
               expr))
(define *precedence-table* 
   '( (maxop . 10000) 
      (minop . -10000) 
      (+ . 0) 
      (* . 1) )) 
  
 (define (operator? x) 
   (define (loop op-pair) 
     (cond ((null? op-pair) #f) 
           ((eq? x (caar op-pair)) #t) 
           (else (loop (cdr op-pair)))))
   (loop *precedence-table*)) 
 (define (min-precedence a b) 
   (if (precedence<? a b) 
       a 
       b))   
 (define (precedence<? a b) 
   (< (precedence a) (precedence b))) 
 (define (precedence op) 
   (define (loop op-pair) 
     (cond ((null? op-pair) 
            (error "Operator not defined -- PRECEDENCE:" op)) 
           ((eq? op (caar op-pair)) 
            (cdar op-pair)) 
           (else 
            (loop (cdr op-pair))))) 
   (loop *precedence-table*)) 
(define (augend expr) 
   (let ((a (cdr (memq '+ expr)))) 
     (if (singleton? a) 
         (car a) 
         a)))

(define (prefix sym list) 
   (if (or (null? list) (eq? sym (car list))) 
       '() 
       (cons (car list) (prefix sym (cdr list))))) 
  
 (define (addend expr) 
   (let ((a (prefix '+ expr))) 
     (if (singleton? a) 
         (car a) 
         a))) 
(define (make-sum a1 a2) 
   (cond ((=number? a1 0) a2) 
         ((=number? a2 0) a1) 
         ((and (number? a1) (number? a2)) 
          (+ a1 a2)) 
         (else (list a1 '+ a2)))) 
(define (multiplier expr) 
   (let ((m (prefix '* expr))) 
     (if (singleton? m) 
         (car m) 
         m))) 
  
 (define (multiplicand expr) 
   (let ((m (cdr (memq '* expr)))) 
     (if (singleton? m) 
         (car m) 
         m))) 
  
 (define (make-product m1 m2) 
   (cond ((=number? m1 1)  m2) 
         ((=number? m2 1)  m1) 
         ((or (=number? m1 0) (=number? m2 0))  0) 
         ((and (number? m1) (number? m2)) 
          (* m1 m2)) 
         (else (list m1 '* m2))))
<<deriv-components>>
<<deriv-and-exponent>>
<<accumulate>>

(show #t (smallest-op '(t + k)) "\n")
(show #t (deriv '(x + 3) 'x) "\n") 
(show #t (deriv '(x * y * (x + 3)) 'x) "\n")
(show #t (deriv '((x * y) * (x + 3)) 'x) "\n")
(show #t (deriv '(x * (y * (x + 3))) 'x) "\n")

#+end_src

#+RESULTS:
: +
: 1
: ((x * y) + (y * (x + 3)))
: ((x * y) + (y * (x + 3)))
: ((x * y) + (y * (x + 3)))


As a side-note: sometimes people say that copying other people's code
prevents us from learning. I disagree. Only copying sgm's code allowed me to
find a serious bug in my implementation of "accumulate". 

*** DONE Exercise 2.59 union-set
    CLOSED: [2019-09-25 Wed 22:00]

#+begin_src scheme :exports both :results value :noweb-ref element-of-set

  (define (element-of-set? x set)
    (cond ((null? set) false)
	  ((equal? x (car set)) true)
	  (else (element-of-set? x (cdr set)))))
#+end_src

#+begin_src scheme :exports both :results value :noweb-ref union-set
<<element-of-set>>
  (define (union-set set1 set2)
    (append set1 (filter (lambda (x) (not (element-of-set? x set1))) set2)))

  (define true #t)
  (define false #f)
#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results output
<<union-set>>
<<filter>>
(show #t " " (union-set '(1 2 3 4) '(3 4 5 6)))
#+end_src

#+RESULTS:
:  (1 2 3 4 5 6)

*** DONE Exercise 2.60 duplicate-set
    CLOSED: [2019-09-25 Wed 22:17]

#+begin_src scheme :exports both :results output
  (define (element-of-set? x set)
    (cond ((null? set) false)
	  ((equal? x (car set)) true)
	  (else (element-of-set? x (cdr set)))))
  #;(The element-of-set? predicate stays the same)
  (define (adjoin x set)
    (cons x set))

  (define (intersection-set set1 set2)
    (cond ((or (null? set1) (null? set2)) '())
	  ((element-of-set? (car set1) set2)
	   (cons (car set1) (intersection-set (cdr set1) set2)))
	  (else (intersection-set (cdr set1) set2))))
  #;(The intersection-set stays the same, moreover, every time it is called, 
  the duplicates are removed.)

  (define (union-set set1 set2)
    (append set1 set2))
  (define true #t)
  (define false #f)  

  (show #t " " (element-of-set? 2 '(1 2 3)) "\n")
  (show #t " " (adjoin 2 '(1 2)) "\n")
  (show #t " " (intersection-set '(1 2 3 4 5) '(2 2 2 2 2)) "\n")
  (show #t " " (union-set '(1 2 3 4 5) '(1 2 2 2 2 3 4)) "\n")
#+end_src

#+RESULTS:
:  #t
:  (2 1 2)
:  (2)
:  (1 2 3 4 5 1 2 2 2 2 3 4)

The efficiency of ~element-of-set?~ is still O(n), although on average sets
would be larger. ~adjoin~ takes O(1), instead of O(n). ~intersection-set~
takes the same \(O(n^2)\), although again, the sets may be larger. ~union-set~
takes \(O(1)\) instead of \(O(n^2)\), which sounds even too good to be true.

Well, if the amount of calls to ~intersection-set~ is big enough, I think
that this representation would be good enough, or even faster.

*** DONE Exercise 2.61 sets as ordered lists
    CLOSED: [2019-09-26 Thu 21:44]

#+begin_src scheme :exports both :results value
  (define (adjoin-set x set)
    (cond ((null? set) x)
	  ((= x (car set)) set)
	  ((< x (car set)) (cons x set))
	  (else (cons (car set) (adjoin-set x (cdr set))))))
  (adjoin-set 3 '(1 2 4 5))
#+end_src

#+RESULTS:
| 1 | 2 | 3 | 4 | 5 |

*** DONE Exercise 2.62 ordered-union-set (ordered list)
    CLOSED: [2019-09-26 Thu 21:38]

#+begin_src scheme :exports both :results raw value :noweb-ref ordered-set
  (define (element-of-set? x set)
    (cond ((null? set) false)
	  ((= x (car set)) true)
	  ((< x (car set)) false)
	  (else (element-of-set? x (cdr set)))))
  (define (intersection-set set1 set2)
    (if (or (null? set1) (null? set2))
	'()
	(let ((x1 (car set1)) (x2 (car set2)))
	  (cond ((= x1 x2)
		 (cons x1
		       (intersection-set (cdr set1)
					 (cdr set2))))
		((< x1 x2)
		 (intersection-set (cdr set1) set2))
		((< x2 x1)
		 (intersection-set set1 (cdr set2)))))))

  (define (remove-duplicates-set set)
    (define (r-d-iter set accumulator)
      (cond ((null? set) accumulator)
	    ((null? accumulator) (r-d-iter (cdr set) (cons (car set) accumulator)))
	    ((= (car set) (car accumulator)) (r-d-iter (cdr set) accumulator))
	    (else (r-d-iter (cdr set) (cons (car set) accumulator)))))
    (reverse (r-d-iter set '())))


  (define (union-set set1 set2)
    (define (union-iter set1 set2 result)
      (cond ((null? set1) (append (reverse result) set2))
	    ((null? set2) (append (reverse result) set1))
	    ((<= (car set1) (car set2)) (union-iter (cdr set1) set2 (cons (car set1) result)))
	    ((<= (car set2) (car set1)) (union-iter set1 (cdr set2) (cons (car set2) result)))))
    (remove-duplicates-set (union-iter set1 set2 '())))
#+end_src

#+begin_src scheme :exports both :results raw value 
<<ordered-set>>
(cons (union-set '(1 3 10) '(1 2 4 5))
(intersection-set '(1 3 10) '(1 2 4 5)))
#+end_src

#+RESULTS:
| (1 2 3 4 5 10) | 1 |

*** TODO Figure 2.16 Various binary trees that represent the set {1,3,5,7,9,11}.
*** DONE Exercise 2.63 tree->list (binary search tree)
    CLOSED: [2019-09-26 Thu 23:37]

Let me copy the two code pieces here, I will need them later.

#+begin_src scheme :exports both :results raw value
  (define (tree->list-1 tree)
    (if (null? tree)
	'()
	(append (tree->list-1 (left-branch tree))
		(cons (entry tree)
		      (tree->list-1 (right-branch tree))))))
#+end_src

#+begin_src scheme :exports both :results raw value :noweb-ref tree-list
  (define (tree->list-2 tree)
    (define (copy-to-list tree result-list)
      (if (null? tree)
	  result-list
	  (copy-to-list (left-branch tree)
			(cons (entry tree)
			      (copy-to-list (right-branch tree)
					    result-list)))))
    (copy-to-list tree '()))

#+end_src


 a. The difference between the two functions is the order of traversing the
 tree. The function ~tree->list-1~ traverses the tree from the left, whereas
 the function ~tree->list-2~ does it from the right. The outcome would be the
 same, and for the trees on the figure 2.16 would give the same answer: 
 ~'(1 2 3 4 5 6 7 8 9 10 11)~.
 b. The difference in performance would be significant. The function 2 uses
 ~cons~, which uses O(1) operations, so the opppprder of growth is ~O(n)~ in
 total. ~append~ in the function 1 takes O(n) operations in the worst case,
 which would make the total complexity \(O(n^2)\).p
*** DONE Exercise 2.64 balanced-tree
    CLOSED: [2019-09-29 Sun 17:22]

Firstly, I want to see what it is exactly that the function outputs.

#+begin_src scheme :exports both :results output :noweb-ref list-tree
     (define (entry tree) (car tree))

     (define (left-branch tree) (cadr tree))

     (define (right-branch tree) (caddr tree))

     (define (make-tree entry left right)
       (list entry left right))


  (define (list->tree elements)
    (car (partial-tree elements (length elements))))

  (define (partial-tree elts n)
    (if (= n 0)
	(cons '() elts)
	(let ((left-size (quotient (- n 1) 2)))
	  (let ((left-result (partial-tree elts left-size)))
	    (let ((left-tree (car left-result))
		  (non-left-elts (cdr left-result))
		  (right-size (- n (+ left-size 1))))
	      (let ((this-entry (car non-left-elts))
		    (right-result (partial-tree (cdr non-left-elts)
						right-size)))
		(let ((right-tree (car right-result))
		      (remaining-elts (cdr right-result)))
		  (cons (make-tree this-entry left-tree right-tree)
			remaining-elts))))))))
#+end_src

#+begin_src scheme :exports both :results output
<<list-tree>>
(show #t " " (pretty (list->tree '(1 3 5 7 9 11))))
#+end_src

#+RESULTS:
:  (5 (1 () (3 () ())) (9 (7 () ()) (11 () ())))

Since I already got the result, I will just draw it.

 #+begin_src plantuml :exports both :file figure-1-1-dot.png
 @startdot
 graph g {
	 node [shape=plaintext];
	 A1 [label="5"];

	 B1 [label="1"];

	 B3 [label="9"];

	 C1 [label="7"];
	 C2 [label="11"];
         C0 [label="'()"];
         C3 [label="3"]

 // edges
	 A1 -- B1;
	 A1 -- B3;
         
         B1 -- C0;
         B1 -- C3;
	 
          
	 B3 -- C1;
	 B3 -- C2;
	 
	 { rank=same; A1 }
	 { rank=same; B1 B3 } 
	 { rank=same; C1 C2 C3 }
 } 
 @enddot
 #+end_src 

 #+RESULTS:
 [[file:figure-1-1-dot.png]]

   a. How exactly did this tree appear? The algorithm given by Abelson
and Sussman is actually quite straightforward: divide a list into two
roughly equal parts, separated by the middle element, make the element into a
node, and attach the right and the left sub-lists of the list as its left and
right children.

   b. The function ~partial-tree~ doesn't contain any full passes through the list,
works in constant time, and is evaluated once per node. Therefore the
complexity is O(1).

*** DONE Exercise 2.65 tree-union-set
    CLOSED: [2019-10-09 Wed 12:13]
Well, I am required to make a union-set and an intersection-set.
So far, we have the operations tree->list, which works in O(n); list->tree,
which works as O(n) too, and union-set and intersection-set for list-based
set implementations, which both work in O(n). The solution then seems
straightforward. 



#+begin_src scheme :exports both :results raw value :noweb-ref set-tree
  (define (union-set-tree set1 set2)
    (list->tree (union-set (tree->list-2 set1) (tree->list-2 set2))))

  (define (intersection-set-tree set1 set2)
    (list->tree (intersection-set (tree->list-2 set1) (tree->list-2 set2))))
#+end_src

#+begin_src scheme :exports both :results output
<<list-tree>>
<<tree-list>>
<<ordered-set>>
<<set-tree>>

(show #t (union-set-tree (list->tree '(1 3 10)) (list->tree '(1 2 4 5))) "\n")
(show #t (intersection-set-tree (list->tree '(1 3 10)) (list->tree '(1 2 4 5))) "\n")
   
#+end_src

#+RESULTS:
: (3 (1 () (2 () ())) (5 (4 () ()) (10 () ())))
: (1 () ())

*** DONE Exercise 2.66 tree-lookup
    CLOSED: [2019-10-09 Wed 13:03]

The excellent property of the ~list->tree~ procedure is that is asserts that
the list given as an argument is already sorted in some way appropriate for
this represented data. Therefore we can use the function verbatim.

#+begin_src scheme :exports both :results raw value :noweb-ref tree-lookup
  (define-record-type dict-entry-type
  (dict-entry x y)
  dict-entry?
  (x entry-key)
  (y entry-value))

  (define (tree-lookup key dictionary)
    (cond ((null? dictionary) #f)
	  ((= (entry-key (entry dictionary)) key) (entry dictionary))
	  ((<= key (entry-key (entry dictionary))) (tree-lookup key (left-branch dictionary)))
	  ((>= key (entry-key (entry dictionary))) (tree-lookup key (right-branch dictionary)))
	  (else (error "Corrupt dictionary"))))

#+end_src

#+begin_src scheme :exports both :results output
<<list-tree>>
<<tree-lookup>>
(show #t " " (list->tree (list (dict-entry 1 'John) (dict-entry 2 'James) (dict-entry 3 'Baloo) (dict-entry 4 'Carry))) "\n")
(show #t " " (tree-lookup 3 (list->tree (list (dict-entry 1 'John) (dict-entry 2 'James) (dict-entry 3 'Baloo) (dict-entry 4 'Carry)))) "\n")
#+end_src

#+RESULTS:
:  ({dict-entry-type #63 2 James} ({dict-entry-type #63 1 John} () ()) ({dict-entry-type #63 3 Baloo} () ({dict-entry-type #63 4 Carry} () ())))
:  {dict-entry-type #63 3 Baloo}

This exercise used the r7rs ~define-record-type~. It is not strictly
necessary here, but I used it do add more "encapsulation" to the data base.
*** DONE Exercise 2.67 Huffman decode a simple message
    CLOSED: [2019-10-09 Wed 20:20]

#+begin_src scheme :exports both :results value :noweb-ref huffman-base
     (define (make-leaf symbol weight)
       (list 'leaf symbol weight))

     (define (leaf? object)
       (eq? (car object) 'leaf))

     (define (symbol-leaf x) (cadr x))

     (define (weight-leaf x) (caddr x))

     (define (make-code-tree left right)
       (list left
             right
             (append (symbols left) (symbols right))
             (+ (weight left) (weight right))))
     (define (left-branch tree) (car tree))

     (define (right-branch tree) (cadr tree))

     (define (symbols tree)
       (if (leaf? tree)
           (list (symbol-leaf tree))
           (caddr tree)))

     (define (weight tree)
       (if (leaf? tree)
           (weight-leaf tree)
           (cadddr tree)))
     (define (decode bits tree)
       (define (decode-1 bits current-branch)
         (if (null? bits)
             '()
             (let ((next-branch
                    (choose-branch (car bits) current-branch)))
               (if (leaf? next-branch)
                   (cons (symbol-leaf next-branch)
                         (decode-1 (cdr bits) tree))
                   (decode-1 (cdr bits) next-branch)))))
       (decode-1 bits tree))

     (define (choose-branch bit branch)
       (cond ((= bit 0) (left-branch branch))
             ((= bit 1) (right-branch branch))
             (else (error "bad bit -- CHOOSE-BRANCH" bit))))
     (define (adjoin-set x set)
       (cond ((null? set) (list x))
             ((< (weight x) (weight (car set))) (cons x set))
             (else (cons (car set)
                         (adjoin-set x (cdr set))))))
     (define (make-leaf-set pairs)
       (if (null? pairs)
           '()
           (let ((pair (car pairs)))
             (adjoin-set (make-leaf (car pair)    #;(symbol)
                                    (cadr pair))  #;(frequency)
                         (make-leaf-set (cdr pairs))))))

#+end_src

#+RESULTS:
: #<undef>

#+begin_src scheme :exports both :results value :noweb-ref huffman-sample-tree
  (define sample-tree
    (make-code-tree (make-leaf 'A 4)
		    (make-code-tree
		     (make-leaf 'B 2)
		     (make-code-tree (make-leaf 'D 1)
				     (make-leaf 'C 1)))))
  (define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))

#+end_src

#+begin_src scheme :exports both :results value

<<huffman-base>>
<<huffman-sample-tree>>
  (decode sample-message sample-tree)
#+end_src

#+RESULTS:
| A | D | A | B | B | C | A |

This is a rather easy exercise, who's main goal is to make us test that the
chapter code is actually working.

*** DONE Exercise 2.68 Huffman encode a simple message
    CLOSED: [2019-10-09 Wed 20:53]

#+begin_src scheme :exports both :results raw value :noweb-ref huffman-encode
	(define (encode message tree)
	  (if (null? message)
	      '()
	      (append (encode-symbol (car message) tree)
		      (encode (cdr message) tree))))
	(define (encode-symbol symbol tree)
	  (cond ((not (element-of-set? symbol (symbols tree)))
		 (error "Error: Huffman tree does not support encoding symbol" symbol))
		((leaf? tree) '())
		((element-of-set? symbol (symbols (left-branch tree))) (cons 0 (encode-symbol symbol (left-branch tree))))
		((element-of-set? symbol (symbols (right-branch tree))) (cons 1 (encode-symbol symbol (right-branch tree))))))
	      
#+end_src

#+begin_src scheme :exports both :results value
(define true #t)
(define false #f)
<<huffman-base>>
<<huffman-encode>>
<<element-of-set>>
<<huffman-sample-tree>>
(encode (list 'A  'D  'A  'B  'B  'C  'A) sample-tree)
#+end_src

#+RESULTS:
| 0 | 1 | 1 | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 1 | 1 | 0 |

My implementation of encode-symbol is not iterative, but for educational
purposes it should be enough.

*** DONE Exercise 2.69 Generate Huffman tree
    CLOSED: [2019-10-10 Thu 11:28]

I spent an hour trying to debug why my code doesn't work, and it turns out
that although Abelson and Sussman use the word "pair" for the (symbol,
weight) tuples, they are actually lists.

#+begin_src scheme :exports both :results value :noweb-ref huffman-generate-tree
     (define (generate-huffman-tree pairs)
       (successive-merge (make-leaf-set pairs)))
     #;(leaf-set is sorted by weight)
     (define (successive-merge leaf-set)
       (cond ((null? leaf-set) '())
	     ((null? (cdr leaf-set)) (car leaf-set))
	     (else (successive-merge (adjoin-set
				      (make-code-tree
				       (car leaf-set)
				       (cadr leaf-set))
				      (cddr leaf-set))))))
#+end_src

#+begin_src scheme :exports both :results output
(define true #t)
(define false #f)
<<huffman-base>>
<<huffman-encode>>
<<element-of-set>>
<<huffman-sample-tree>>
<<huffman-generate-tree>>
(define pairs (list (list 'A 4) (list 'B 2) (list 'C 1) (list 'D 1)))
n#;(generate-huffman-tree (list (cons 'A 4) (cons 'B 2) (cons 'C 1) (cons 'D 1)))
#n;(make-leaf-set pairs)
(show #t  "Sample-tree:" (pretty (generate-huffman-tree pairs)) "\n")
(show #t  "Our tree   :" (pretty sample-tree) "\n")
#+end_src

#+RESULTS:
#+begin_example
Sample-tree:((leaf A 4)
             ((leaf B 2) ((leaf D 1) (leaf C 1) (D C) 2) (B D C) 4)
             (A B D C)
             8)

Our tree   :((leaf A 4)
             ((leaf B 2) ((leaf D 1) (leaf C 1) (D C) 2) (B D C) 4)
             (A B D C)
             8)

#+end_example

*** DONE Exercise 2.70 Generate a tree and encode a song
    CLOSED: [2019-10-10 Thu 13:11]
This exercise has a small caveat. The scheme used to create examples for SICP
back when it was written, had a case-independent reader, therefore the text
of the book ignores the case difference between, say, 'Sha, 'SHA, and 'sha.
Luckily, in the given song, there are no instances of the same symbol
consisting of letters of different cases, so to make the code work, the only
thing needed is to correct the case in the dictionary.

Let's generate a tree first:

#+begin_src scheme :exports both :results output
  (define true #t)
  (define false #f)
  <<huffman-base>>
  <<huffman-encode>>
  <<element-of-set>>
  <<huffman-sample-tree>>
  <<huffman-generate-tree>>
  (define pairs 
    (list
     (list 'a 4) (list 'Get 2) (list 'Sha 1) (list 'Wah 1)
     (list 'boom 1) (list 'job 2) (list 'na 16) (list 'yip 9)))
  (define coding-tree (generate-huffman-tree pairs))
  (show #t  "Tree:" (pretty coding-tree) "\n")
  (define song '(
		     Get a job
		     Sha na na na na na na na na
		     Get a job
		     Sha na na na na na na na na
		     Wah yip yip yip yip yip yip yip yip yip
		     Sha boom
		     ))
  (define encoded-song (encode song coding-tree))
  (show #t encoded-song "\n")
  (show #t (decode encoded-song coding-tree) "\n")
#+end_src

#+RESULTS:
#+begin_example
Tree:((leaf na 16)
      ((leaf yip 9)
       (((leaf Get 2) ((leaf boom 1) (leaf Wah 1) (boom Wah) 2)
                      (Get boom Wah)
                      4)
        (((leaf Sha 1) (leaf job 2) (Sha job) 3) (leaf a 4) (Sha job a) 7)
        (Get boom Wah Sha job a)
        11)
       (yip Get boom Wah Sha job a)
       20)
      (na yip Get boom Wah Sha job a)
      36)

(1 1 0 0 1 1 1 1 1 1 1 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 1 1 1 1 1 1 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 1 1 0 1 1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1 1 0 0 1 1 0 1 0)
(Get a job Sha na na na na na na na na Get a job Sha na na na na na na na na Wah yip yip yip yip yip yip yip yip yip Sha boom)
#+end_example

*** DONE Exercise 2.71 Huffman tree for frequencies 5 and 10
    CLOSED: [2019-10-10 Thu 19:22]

#+begin_src scheme :exports both :results output
  (define true #t)
  (define false #f)
  <<huffman-base>>
  <<huffman-encode>>
  <<element-of-set>>
  <<huffman-sample-tree>>
  <<huffman-generate-tree>>
  (define pairs 
    (list
     (list 'a 1) (list 'b 2) (list 'c 4) (list 'd 8)))
  (define coding-tree (generate-huffman-tree pairs))
  (show #t  "Tree:" (pretty coding-tree) "\n")

#+end_src 

#+RESULTS:
: Tree:((((leaf a 1) (leaf b 2) (a b) 3) (leaf c 4) (a b c) 7) (leaf d 8)
:                                                              (a b c d)
:                                                              15)
: 

#+begin_src plantuml :exports both :file Exercise-2.71.png 
@startmindmap
skinparam monochrome true
+_ ((((leaf a 1)\n (leaf b 2) (a b) 3)\n (leaf c 4) (a b c) 7)\n (leaf d 8) (a b c d) 15)
++_ (leaf d 8)
++_ (((leaf a 1)\n (leaf b 2) (a b) 3) \n(leaf c 4) (a b c) 7)
+++_ (leaf c 4)
+++_ ((leaf a 1) \n(leaf b 2) (a b) 3)
++++_ (leaf b 2)
++++_ (leaf a 1)
@endmindmap
#+end_src 

#+RESULTS:
[[file:Exercise-2.71.png]]

#+begin_src scheme :exports both :results output
  (define true #t)
  (define false #f)
  <<huffman-base>>
  <<huffman-encode>>
  <<element-of-set>>
  <<huffman-sample-tree>>
  <<huffman-generate-tree>>
  (define pairs 
    (list
     (list 'a 1) (list 'b 2) (list 'c 4) (list 'd 8)
     (list 'e 16) (list 'f 32) (list 'g 64) (list 'h 128) (list 'j 256)))
  (define coding-tree (generate-huffman-tree pairs))
  (show #t  "Tree:" (pretty coding-tree) "\n")

#+end_src 

#+RESULTS:
#+begin_example
Tree:(((((((((leaf a 1) (leaf b 2) (a b) 3) (leaf c 4) (a b c) 7) (leaf d 8)
                                                                  (a b c d)
                                                                  15)
          (leaf e 16)
          (a b c d e)
          31) (leaf f 32)
              (a b c d e f)
              63) (leaf g 64)
                  (a b c d e f g)
                  127) (leaf h 128)
                       (a b c d e f g h)
                       255) (leaf j 256)
                            (a b c d e f g h j)
                            511)

#+end_example

#+begin_src plantuml :exports both :file Exercise-2.71.png 
@startmindmap
skinparam monochrome true
+_ (a b c d e f g h j) 511
++_ (leaf j 256)
++_ (a b c d e f g h) 255
+++_ (leaf h 128)
+++_ (a b c d e f g) 127
++++_ (a b c d e f) 63
++++_ (leaf g 64)
+++++_ (a b c d e) 31
+++++_ (leaf f 32)
++++++_ (a b c d) 15
++++++_ (leaf e 16)
+++++++_ (a b c) 7
+++++++_ (leaf d 8) 
++++++++_ (a b) 3
++++++++_ (leaf c 4)
+++++++++_ (leaf a 1)
+++++++++_ (leaf b 2)
@endmindmap
#+end_src 

#+RESULTS:
[[file:Exercise-2.71.png]]

We can clearly see that if the probabilities decrease exponentially, the
length of the tree is n. So to encode the most frequent symbol we would need
just one bit, and the least frequent would require 8 bit.

*** DONE Exercise 2.72 Huffman order of growth
    CLOSED: [2019-10-10 Thu 20:34]

If we consider Exercise 2.71, we'll see that the amount of elements mentioned
at every level of k the tree is n-k.  Therefore, if we want to encode the most
frequent element, we would need to perform O(n-k) operations on every level
of the tree. Since we would need to eventually reach the bottom-most level,
the total number of operations would be \(\sum_1^n (n-k) = O(n^2)\).

The most frequent element is always on
level 1, so to encode it we would need O(1) operations, and we don't even
need to go through the list.

*** Remark Complex packages

The following several exercises can only be considered "functional"
loosely. 

In this subsection I will copy the source of the two complex packages given
as examples.

#+begin_src scheme :exports both :results output
     (define (install-rectangular-package)
       ;; internal procedures
       (define (real-part z) (car z))
       (define (imag-part z) (cdr z))
       (define (make-from-real-imag x y) (cons x y))
       (define (magnitude z)
         (sqrt (+ (square (real-part z))
                  (square (imag-part z)))))
       (define (angle z)
         (atan (imag-part z) (real-part z)))
       (define (make-from-mag-ang r a)
         (cons (* r (cos a)) (* r (sin a))))

       ;; interface to the rest of the system
       (define (tag x) (attach-tag 'rectangular x))
       (put 'real-part '(rectangular) real-part)
       (put 'imag-part '(rectangular) imag-part)
       (put 'magnitude '(rectangular) magnitude)
       (put 'angle '(rectangular) angle)
       (put 'make-from-real-imag 'rectangular
            (lambda (x y) (tag (make-from-real-imag x y))))
       (put 'make-from-mag-ang 'rectangular
            (lambda (r a) (tag (make-from-mag-ang r a))))
       'done)

#+end_src

#+RESULTS:

#+begin_src scheme :exports both :results output
     (define (install-polar-package)
       ;; internal procedures
       (define (magnitude z) (car z))
       (define (angle z) (cdr z))
       (define (make-from-mag-ang r a) (cons r a))
       (define (real-part z)
         (* (magnitude z) (cos (angle z))))
       (define (imag-part z)
         (* (magnitude z) (sin (angle z))))
       (define (make-from-real-imag x y)
         (cons (sqrt (+ (square x) (square y)))
               (atan y x)))

       ;; interface to the rest of the system
       (define (tag x) (attach-tag 'polar x))
       (put 'real-part '(polar) real-part)
       (put 'imag-part '(polar) imag-part)
       (put 'magnitude '(polar) magnitude)
       (put 'angle '(polar) angle)
       (put 'make-from-real-imag 'polar
            (lambda (x y) (tag (make-from-real-imag x y))))
       (put 'make-from-mag-ang 'polar
            (lambda (r a) (tag (make-from-mag-ang r a))))
       'done)
#+end_src

#+RESULTS:

*** Remark Reference to the put and get functions
~put~ and ~get~ functions are defined later, however, you can use them if
tangling in the block called: <<put-and-get>>. It is a stateful block, so be
sure to include it first.
*** DONE Exercise 2.73 data-driven-deriv
    CLOSED: [2019-10-11 Fri 11:05]

#+begin_src scheme :exports both :results output :noweb-ref data-driven-deriv
          (define (deriv exp var)
             (cond ((number? exp) 0)
                   ((variable? exp) (if (same-variable? exp var) 1 0))
                   (else ((get 'deriv (operator exp)) (operands exp)
                                                      var))))
          (define (operator exp) (car exp))
          (define (operands exp) (cdr exp))
#+end_src

**** DONE a
     CLOSED: [2019-10-11 Fri 10:29]
 We replaced the fixed ~product?~ and ~sum?~ predicate functions with the
ones dispatched on the table. Both of these predicates require their tested
variable to be a ~cons~. This is why ~number?~ and ~variable?~ cannot be
replaced with a dispatched version − they are not a pair.

**** DONE b
Surprise-surprise, the prototype of the two ~deriv~ functions we are
supposed to write is incompatible with the derivatives we had to write in the Exercise-2.56.

#+begin_src scheme :exports both :results output :noweb-ref data-driven-sum-mul
  (define (differentiate-sum operands var)
    (make-sum (deriv (car  operands) var)
	      (deriv (cadr operands) var)))
  (define (differentiate-multiplication operands var)
    (make-sum
     (make-product (car  operands)
		   (deriv (cadr operands) var))
     (make-product (deriv (car  operands) var)
		   (cadr operands))))
  (put 'deriv '+ differentiate-sum)
  (put 'deriv '* differentiate-multiplication)
#+end_src

#+begin_src scheme :exports both :results output
<<put-and-get>>
<<deriv-components>>
<<deriv-operations>>
<<data-driven-deriv>>
<<data-driven-sum-mul>>
(show #t "Test:" (deriv '(+ a (* b a)) 'a) "\n")
#+end_src

#+RESULTS:
: Test:(+ 1 b)

**** DONE c
     CLOSED: [2019-10-11 Fri 11:03]

#+begin_src scheme :exports both :results output :noweb-ref data-driven-exponentiation
(define (make-exponentiation base power)
    (cond ((=number? power 0) 1)
	  ((=number? power 1) base)
	  ((and (number? base) (number? power))
	   (expt base power))
	  (else (list '** base power))))

(define (differentiate-exponentiation exp var)
	   (make-product (cadr exp)
			 (make-product
			  (make-exponentiation
			   (car exp)
			   (make-sum (cadr exp) -1))
			  (deriv (car exp) var))))

(put 'deriv '** differentiate-exponentiation)
#+end_src

#+begin_src scheme :exports both :results output
(define false #f)
<<put-and-get>>
<<deriv-components>>
<<deriv-operations>>
<<data-driven-deriv>>
<<data-driven-sum-mul>>
<<data-driven-exponentiation>>
(show #t "Test:" (deriv '(+ a (* b (** a c))) 'a) "\n")

#;(show #t "Test:" (deriv '(** a b) 'a) "\n")
#+end_src

#+RESULTS:
: Test:(+ 1 (* b (* c (** a (+ c -1)))))

**** DONE d
     CLOSED: [2019-10-11 Fri 11:05]

The only change needed is to change the order of parameters in ~put~ just as
it is changed in ~get~. The rest should be absolutely the same.

*** DONE Exercise 2.74 Insatiable Enterprises
    CLOSED: [2019-10-11 Fri 20:56]

This task is a bit weird and too vaguely formulated. For the start, let's
assume that the company only has two divisions.

#+begin_src scheme :exports both :results output :noweb-ref insatiable-enterprises-data
  (define division-1-set-of-records
     (cons 'division-1 (list (list 'Jack (cons 'salary 100) (cons 'address #f)) (list 'Jill (cons 'salary 200) '(address #t)))))
  (define (division-1-get-record record-set key)
    (define (crawler records key)
      (cond ((null? records) '())
	    ((eq? key (caar records)) (car records))
	    (else (crawler (cdr records) key))))
    (crawler (cdr record-set) key))

  (define (division-1-get-salary record)
     (cdr (list-ref record 1)))

  (define division-2-set-of-records
    (cons 'division-2 (list (list 'placeholder 'WangYi 'salary 100 'address 'neverland) (list 'placeholder 'ZhangEr 'salary 200 'address 'this-world))))

  (define (division-2-get-record record-set key)
    (define (crawler records key)
      (cond ((null? records) '())
	    ((eq? key (list-ref (car records) 1)) (car records))
	    (else (crawler (cdr records) key))))
    (crawler (cdr record-set) key))
  (define (division-2-get-salary record)
     (list-ref record 3))

(put 'get-record 'division-1 division-1-get-record)
(put 'get-record 'division-2 division-2-get-record)
(put 'get-salary 'division-1 division-1-get-salary)
(put 'get-salary 'division-2 division-2-get-salary)



#+end_src

#+begin_src scheme :exports both :results output
<<put-and-get>>
<<insatiable-enterprises-data>>

(show #t "Division-1: " (division-1-get-record division-1-set-of-records 'Jack) "\n")
(show #t "Division-2: " (division-2-get-record division-2-set-of-records 'WangYi) "\n")
(show #t "Division-2: " (division-2-get-record division-2-set-of-records 'ZhangEr) "\n")
(show #t "Salary-1:   " (division-1-get-salary (division-1-get-record division-1-set-of-records 'Jill)) "\n")
(show #t "Salary-2:   " (division-2-get-salary (division-2-get-record division-2-set-of-records 'WangYi)) "\n")
(show #t "Division-1: " ((get 'get-record 'division-1) division-1-set-of-records 'Jack) "\n")
(show #t "Division-2: " ((get 'get-record 'division-2) division-2-set-of-records 'WangYi) "\n")
(show #t "Division-1: " ((get 'get-salary 'division-1) (division-1-get-record division-1-set-of-records 'Jill)) "\n")
(show #t "Division-2: " ((get 'get-salary 'division-2) (division-2-get-record division-2-set-of-records 'WangYi)) "\n")

#+end_src

#+RESULTS:
: Division-1: (Jack (salary . 100) (address . #f))
: Division-2: (placeholder WangYi salary 100 address neverland)
: Division-2: (placeholder ZhangEr salary 200 address this-world)
: Salary-1:   200
: Salary-2:   100
: Division-1: (Jack (salary . 100) (address . #f))
: Division-2: (placeholder WangYi salary 100 address neverland)
: Division-1: 200
: Division-2: 100

**** DONE a
     CLOSED: [2019-10-11 Fri 18:39]

The key thing in our implementation of the two datasets is that we have a
department tag at the beginning. This lets us dispatch on the origin of the
data.

#+begin_src scheme :exports both :results output :noweb-ref insatiable-a
(define (get-record dataset key)
   ((get 'get-record (car dataset)) dataset key))
#+end_src

#+begin_src scheme :exports both :results output
<<put-and-get>>
<<insatiable-enterprises-data>>
<<insatiable-a>>

(show #t (get-record division-1-set-of-records 'Jill) "\n")
(show #t (get-record division-2-set-of-records 'ZhangEr) "\n")
#+end_src

#+RESULTS:
: (Jill (salary 200) (address #t))
: (placeholder ZhangEr salary 200 address this-world)

**** DONE b
     CLOSED: [2019-10-11 Fri 20:22]

#+begin_src scheme :exports both :results output :noweb-ref insatiable-b
  (define (get-salary records key)
    (let ((record (get-record records key)))
      (if record
	  ((get 'get-salary (car records)) record)
	  #f)))
#+end_src

#+RESULTS:


#+begin_src scheme :exports both :results output
<<put-and-get>>
<<insatiable-enterprises-data>>
<<insatiable-a>>
<<insatiable-b>>
(show #t "Salary wrong  : " (get-salary division-2-set-of-records 'Jill) "\n")
(show #t "Salary correct: " (get-salary division-1-set-of-records 'Jill) "\n")
#+end_src

#+RESULTS:
: Salary wrong  : #f
: Salary correct: 200

Because all the dispatch is organized on a tag in the file records, there is
no specific requirements to the record structure.

**** DONE c
     CLOSED: [2019-10-11 Fri 20:54]

#+begin_src scheme :exports both :results output :noweb-ref insatiable-find-employee-record
    <<accumulate>>
      (define (find-employee-record key . record-files)
	(car (accumulate
	      append
	      '()
	      (map (lambda (x)
		     (list (get-record x key))) record-files))))
#+end_src

#+begin_src scheme :exports both :results output
<<put-and-get>>
<<insatiable-enterprises-data>>
<<insatiable-a>>
<<insatiable-b>>
<<insatiable-find-employee-record>>
(show #t "Result: " (find-employee-record 'Jill division-1-set-of-records division-2-set-of-records) "\n")
#+end_src

#+RESULTS:
: Result: (Jill (salary . 200) (address #t))

**** DONE d
     CLOSED: [2019-10-11 Fri 20:56]
The new company would need to prepend their files with ~('companyname)~, and
their functions ~get-record~ and ~get-salary~ need to be registered with the
new the function table.

*** DONE Exercise 2.75 make-from-mag-ang message passing
    CLOSED: [2019-10-11 Fri 21:24]

#+begin_src scheme :exports both :results output :noweb-ref message-mag-angle
     (define (make-from-mag-angle mag angle)
       (define (dispatch op)
         (cond ((eq? op 'real-part) (* mag (cos angle)))
               ((eq? op 'imag-part) (* mag (sin angle)))
               ((eq? op 'magnitude) mag)
               ((eq? op 'angle) angle)
               (else
                (error "Unknown op -- MAKE-FROM-REAL-IMAG" op))))
       dispatch)
#+end_src

#+begin_src scheme :exports both :results output
<<message-mag-angle>>
(show #t "Magnitude: " ((make-from-mag-angle 1 1) 'magnitude) "\n")
(show #t "Angle    : " ((make-from-mag-angle 1 1) 'angle    ) "\n")
(show #t "Real-part: " ((make-from-mag-angle 1 1) 'real-part) "\n")
(show #t "Imag-part: " ((make-from-mag-angle 1 1) 'imag-part) "\n")
#+end_src

#+RESULTS:
: Magnitude: 1
: Angle    : 1
: Real-part: 0.5403023058681398
: Imag-part: 0.8414709848078965

*** DONE Exercise 2.76 types or functions?
    CLOSED: [2019-10-11 Fri 21:29]

Dispatching on the types seems more appropriate for the case when there are
more operations that types. This way there is no need to adjust types when
new operations are created. Just add new operations to the table.

The message-passing style seems more appropriate for the situations when
new operations are relatively rare, but new types appear often. Existing
operations would work with the new types, if the types satisfy some contract.

*** Remark Three arithmetic packages
#+begin_src scheme :exports both :results output :noweb-ref generic-arithmetic-packages
     (define (add x y) (apply-generic 'add x y))
     (define (sub x y) (apply-generic 'sub x y))
     (define (mul x y) (apply-generic 'mul x y))
     (define (div x y) (apply-generic 'div x y))

     (define (install-scheme-number-package)
       (define (tag x)
         (attach-tag 'scheme-number x))
       (put 'add '(scheme-number scheme-number)
            (lambda (x y) (tag (+ x y))))
       (put 'sub '(scheme-number scheme-number)
            (lambda (x y) (tag (- x y))))
       (put 'mul '(scheme-number scheme-number)
            (lambda (x y) (tag (* x y))))
       (put 'div '(scheme-number scheme-number)
            (lambda (x y) (tag (/ x y))))
       (put 'make 'scheme-number
            (lambda (x) (tag x)))
       'done)

     (define (make-scheme-number n)
       ((get 'make 'scheme-number) n))

     (define (install-rational-package)
       (define (numer x) (car x))
       (define (denom x) (cdr x))
       (define (make-rat n d)
         (let ((g (gcd n d)))
           (cons (/ n g) (/ d g))))
       (define (add-rat x y)
         (make-rat (+ (* (numer x) (denom y))
                      (* (numer y) (denom x)))
                   (* (denom x) (denom y))))
       (define (sub-rat x y)
         (make-rat (- (* (numer x) (denom y))
                      (* (numer y) (denom x)))
                   (* (denom x) (denom y))))
       (define (mul-rat x y)
         (make-rat (* (numer x) (numer y))
                   (* (denom x) (denom y))))
       (define (div-rat x y)
         (make-rat (* (numer x) (denom y))
                   (* (denom x) (numer y))))

       (define (tag x) (attach-tag 'rational x))
       (put 'add '(rational rational)
            (lambda (x y) (tag (add-rat x y))))
       (put 'sub '(rational rational)
            (lambda (x y) (tag (sub-rat x y))))
       (put 'mul '(rational rational)
            (lambda (x y) (tag (mul-rat x y))))
       (put 'div '(rational rational)
            (lambda (x y) (tag (div-rat x y))))

       (put 'make 'rational
            (lambda (n d) (tag (make-rat n d))))
       'done)

     (define (make-rational n d)
       ((get 'make 'rational) n d))

     (define (install-rectangular-package)

       (define (real-part z) (car z))
       (define (imag-part z) (cdr z))
       (define (make-from-real-imag x y) (cons x y))
       (define (magnitude z)
         (sqrt (+ (square (real-part z))
                  (square (imag-part z)))))
       (define (angle z)
         (atan (imag-part z) (real-part z)))
       (define (make-from-mag-ang r a)
         (cons (* r (cos a)) (* r (sin a))))

       (define (tag x) (attach-tag 'rectangular x))
       (put 'real-part '(rectangular) real-part)
       (put 'imag-part '(rectangular) imag-part)
       (put 'magnitude '(rectangular) magnitude)
       (put 'angle '(rectangular) angle)
       (put 'make-from-real-imag 'rectangular
            (lambda (x y) (tag (make-from-real-imag x y))))
       (put 'make-from-mag-ang 'rectangular
            (lambda (r a) (tag (make-from-mag-ang r a))))
       'done)

     (define (install-polar-package)

       (define (magnitude z) (car z))
       (define (angle z) (cdr z))
       (define (make-from-mag-ang r a) (cons r a))
       (define (real-part z)
         (* (magnitude z) (cos (angle z))))
       (define (imag-part z)
         (* (magnitude z) (sin (angle z))))
       (define (make-from-real-imag x y)
         (cons (sqrt (+ (square x) (square y)))
               (atan y x)))

       (define (tag x) (attach-tag 'polar x))
       (put 'real-part '(polar) real-part)
       (put 'imag-part '(polar) imag-part)
       (put 'magnitude '(polar) magnitude)
       (put 'angle '(polar) angle)
       (put 'make-from-real-imag 'polar
            (lambda (x y) (tag (make-from-real-imag x y))))
       (put 'make-from-mag-ang 'polar
            (lambda (r a) (tag (make-from-mag-ang r a))))
       'done)

     (define (install-complex-package)
       (define (make-from-real-imag x y)
         ((get 'make-from-real-imag 'rectangular) x y))
       (define (make-from-mag-ang r a)
         ((get 'make-from-mag-ang 'polar) r a))
       (define (add-complex z1 z2)
         (make-from-real-imag (+ (real-part z1) (real-part z2))
                              (+ (imag-part z1) (imag-part z2))))
       (define (sub-complex z1 z2)
         (make-from-real-imag (- (real-part z1) (real-part z2))
                              (- (imag-part z1) (imag-part z2))))
       (define (mul-complex z1 z2)
         (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                            (+ (angle z1) (angle z2))))
       (define (div-complex z1 z2)
         (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                            (- (angle z1) (angle z2))))
       (define (tag z) (attach-tag 'complex z))
       (put 'add '(complex complex)
            (lambda (z1 z2) (tag (add-complex z1 z2))))
       (put 'sub '(complex complex)
            (lambda (z1 z2) (tag (sub-complex z1 z2))))
       (put 'mul '(complex complex)
            (lambda (z1 z2) (tag (mul-complex z1 z2))))
       (put 'div '(complex complex)
            (lambda (z1 z2) (tag (div-complex z1 z2))))
       (put 'make-from-real-imag 'complex
            (lambda (x y) (tag (make-from-real-imag x y))))
       (put 'make-from-mag-ang 'complex
            (lambda (r a) (tag (make-from-mag-ang r a))))
       'done)

     (define (make-complex-from-real-imag x y)
       ((get 'make-from-real-imag 'complex) x y))

     (define (make-complex-from-mag-ang r a)
       ((get 'make-from-mag-ang 'complex) r a))


#+end_src

#+RESULTS:


#+begin_src scheme :exports both :results output :noweb-ref apply-generic
     (define (attach-tag type-tag contents)
       (cons type-tag contents))

     (define (type-tag datum)
       (if (pair? datum)
           (car datum)
           (error "Bad tagged datum -- TYPE-TAG" datum)))

     (define (contents datum)
       (if (pair? datum)
           (cdr datum)
           (error "Bad tagged datum -- CONTENTS" datum)))

     (define (rectangular? z)
       (eq? (type-tag z) 'rectangular))

     (define (polar? z)
       (eq? (type-tag z) 'polar))

     (define (apply-generic op . args)
       (let ((type-tags (map type-tag args)))
         (let ((proc (get op type-tags)))
           (if proc
               (apply proc (map contents args))
               (error
                 "No method for these types -- APPLY-GENERIC"
                 (list op type-tags))))))

     (define (real-part z) (apply-generic 'real-part z))
     (define (imag-part z) (apply-generic 'imag-part z))
     (define (magnitude z) (apply-generic 'magnitude z))
     (define (angle z) (apply-generic 'angle z))

#+end_src

*** DONE Exercise 2.77 generic-algebra-magnitude
    CLOSED: [2019-10-12 Sat 16:01]
Yeah, great, Dr. Abelson. You're casually referring to the ~apply-generic~,
not really specifying which one to use. Also, I never had to use the
~type-tag~ and ~contents~, which suddenly appear here.

#+begin_src scheme :exports both :results output :noweb-ref alyssa-complex-suggestion
          (put 'real-part '(complex) real-part)
          (put 'imag-part '(complex) imag-part)
          (put 'magnitude '(complex) magnitude)
          (put 'angle '(complex) angle)
#+end_src

#+begin_src scheme :exports both :results output
(define false #f)
(define true  #t)
<<put-and-get>>
<<apply-generic>>

<<generic-arithmetic-packages>>

(install-rectangular-package)
(install-complex-package)

<<alyssa-complex-suggestion>>

(show #t "Louis's result: " (magnitude (make-complex-from-real-imag 3 4)) "\n")

#+end_src

#+RESULTS:
: Louis's result: 5

This example illustrates what can, perhaps, be called "double
dispatch". Indeed,  our "complex" implementation still keeps the 'rectangular
and 'polar tags, so the only thing that the complex ~magnitude~ should do is
to call (through the dispatch table) the old function ~magnitude~, which
will, by itself, dispatch on the old tags. ~apply-generic~ is called twice,
first for a 'complex tag, an later for the 'polar tag. 

Remark: this "easy" exercise took more than 4 hours to debug and consists of
227 lines of code.

*** DONE Exercise 2.78 Ordinary numbers for scheme
    CLOSED: [2019-10-12 Sat 21:06]

#+begin_src scheme :exports both :results output :noweb-ref simplified-scheme-number
     (define (add x y) (apply-generic 'add x y))
     (define (sub x y) (apply-generic 'sub x y))
     (define (mul x y) (apply-generic 'mul x y))
     (define (div x y) (apply-generic 'div x y))
     (define (attach-tag type-tag contents)
       (if (eq? type-tag 'scheme-number)
           contents
           (cons type-tag contents)))

     (define (type-tag datum)
       (cond ((pair? datum) (car datum))
             ((number? datum) 'scheme-number)
             (else (error "Bad tagged datum -- TYPE-TAG" datum))))

     (define (contents datum)
       (cond ((pair? datum) (cdr datum))
             ((number? datum) datum)
             (else (error "Bad tagged datum -- CONTENTS" datum))))

     (define (apply-generic op . args)
       (let ((type-tags (map type-tag args)))
         (let ((proc (get op type-tags)))
           (if proc
               (apply proc (map contents args))
               (error
                 "No method for these types -- APPLY-GENERIC"
                 (list op type-tags))))))

     (define (install-scheme-number-package)
       (define (tag x)
         (attach-tag 'scheme-number x))
       (put 'add '(scheme-number scheme-number)
            (lambda (x y) (tag (+ x y))))
       (put 'sub '(scheme-number scheme-number)
            (lambda (x y) (tag (- x y))))
       (put 'mul '(scheme-number scheme-number)
            (lambda (x y) (tag (* x y))))
       (put 'div '(scheme-number scheme-number)
            (lambda (x y) (tag (/ x y))))
       (put 'make 'scheme-number
            (lambda (x) (tag x)))
       'done)

     (define (make-scheme-number n)
       ((get 'make 'scheme-number) n))
#+end_src

#+begin_src scheme :exports both :results output
<<put-and-get>>
<<simplified-scheme-number>>
(install-scheme-number-package)
(show #t "Adding: (+ 1 2) : " (add (make-scheme-number 1) (make-scheme-number 2)) "\n")
#+end_src

#+RESULTS:
: Adding: (+ 1 2) : 3

The task is to "Modify the definitions of `type-tag', `contents', and
`attach-tag'", therefore (as this doesn't seem really useful), I am only
copying those functions for modification in this particular exercise.

*** DONE Exercise 2.79 generic-equality
    CLOSED: [2019-10-14 Mon 15:58]

In this exercise I am copying the whole package again, as due to the poor
architecture of the algebra system, adding such a tiny feature is not additive.

#+begin_src scheme :exports both :results output

  (define false #f)
  (define true  #t)
  (define (make-table)
    (let ((local-table (list '*table*)))
      (define (lookup key-1 key-2)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (cdr record)
		    false))
	      false)))
      (define (insert! key-1 key-2 value)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (set-cdr! record value)
		    (set-cdr! subtable
			      (cons (cons key-2 value)
				    (cdr subtable)))))
	      (set-cdr! local-table
			(cons (list key-1
				    (cons key-2 value))
			      (cdr local-table)))))
	'ok)
      (define (dispatch m)
	(cond ((eq? m 'lookup-proc) lookup)
	      ((eq? m 'insert-proc!) insert!)
	      (else (error "Unknown operation -- TABLE" m))))
      dispatch))

  (define operation-table (make-table))
  (define get (operation-table 'lookup-proc))
  (define put (operation-table 'insert-proc!))
  (define (attach-tag type-tag contents)
    (cons type-tag contents))

  (define (type-tag datum)
    (if (pair? datum)
	(car datum)
	(error "Bad tagged datum -- TYPE-TAG" datum)))

  (define (contents datum)
    (if (pair? datum)
	(cdr datum)
	(error "Bad tagged datum -- CONTENTS" datum)))

  (define (rectangular? z)
    (eq? (type-tag z) 'rectangular))

  (define (polar? z)
    (eq? (type-tag z) 'polar))

  (define (apply-generic op . args)
    (let ((type-tags (map type-tag args)))
      (let ((proc (get op type-tags)))
	(if proc
	    (apply proc (map contents args))
	    (error
	      "No method for these types -- APPLY-GENERIC"
	      (list op type-tags))))))

  (define (real-part z) (apply-generic 'real-part z))
  (define (imag-part z) (apply-generic 'imag-part z))
  (define (magnitude z) (apply-generic 'magnitude z))
  (define (angle z) (apply-generic 'angle z))

  (define (add x y) (apply-generic 'add x y))
  (define (sub x y) (apply-generic 'sub x y))
  (define (mul x y) (apply-generic 'mul x y))
  (define (div x y) (apply-generic 'div x y))
   
  (define (equ? x y) (apply-generic 'equ? x y))

  (define (install-scheme-number-package)
    (define (tag x)
      (attach-tag 'scheme-number x))
    (put 'add '(scheme-number scheme-number)
	 (lambda (x y) (tag (+ x y))))
    (put 'sub '(scheme-number scheme-number)
	 (lambda (x y) (tag (- x y))))
    (put 'mul '(scheme-number scheme-number)
	 (lambda (x y) (tag (* x y))))
    (put 'div '(scheme-number scheme-number)
	 (lambda (x y) (tag (/ x y))))
    (put 'make 'scheme-number
	 (lambda (x) (tag x)))
    (put 'equ? '(scheme-number scheme-number)
         (lambda (x y) (= x y)))
    'done)

  (define (make-scheme-number n)
    ((get 'make 'scheme-number) n))

  (define (install-rational-package)
    (define (numer x) (car x))
    (define (denom x) (cdr x))
    (define (make-rat n d)
      (let ((g (gcd n d)))
	(cons (/ n g) (/ d g))))
    (define (add-rat x y)
      (make-rat (+ (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (sub-rat x y)
      (make-rat (- (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (mul-rat x y)
      (make-rat (* (numer x) (numer y))
		(* (denom x) (denom y))))
    (define (div-rat x y)
      (make-rat (* (numer x) (denom y))
		(* (denom x) (numer y))))

    (define (tag x) (attach-tag 'rational x))
    (put 'add '(rational rational)
	 (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
	 (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
	 (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
	 (lambda (x y) (tag (div-rat x y))))

    (put 'make 'rational
	 (lambda (n d) (tag (make-rat n d))))
    (put 'equ? '(rational rational)
         (lambda (x y) (= 0 (numer (sub-rat x y)))))
    'done)

  (define (make-rational n d)
    ((get 'make 'rational) n d))

  (define (install-rectangular-package)

    (define (real-part z) (car z))
    (define (imag-part z) (cdr z))
    (define (make-from-real-imag x y) (cons x y))
    (define (magnitude z)
      (sqrt (+ (square (real-part z))
	       (square (imag-part z)))))
    (define (angle z)
      (atan (imag-part z) (real-part z)))
    (define (make-from-mag-ang r a)
      (cons (* r (cos a)) (* r (sin a))))

    (define (tag x) (attach-tag 'rectangular x))
    (put 'real-part '(rectangular) real-part)
    (put 'imag-part '(rectangular) imag-part)
    (put 'magnitude '(rectangular) magnitude)
    (put 'angle '(rectangular) angle)
    (put 'make-from-real-imag 'rectangular
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'rectangular
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-polar-package)

    (define (magnitude z) (car z))
    (define (angle z) (cdr z))
    (define (make-from-mag-ang r a) (cons r a))
    (define (real-part z)
      (* (magnitude z) (cos (angle z))))
    (define (imag-part z)
      (* (magnitude z) (sin (angle z))))
    (define (make-from-real-imag x y)
      (cons (sqrt (+ (square x) (square y)))
	    (atan y x)))

    (define (tag x) (attach-tag 'polar x))
    (put 'real-part '(polar) real-part)
    (put 'imag-part '(polar) imag-part)
    (put 'magnitude '(polar) magnitude)
    (put 'angle '(polar) angle)
    (put 'make-from-real-imag 'polar
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'polar
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-complex-package)
    (define (make-from-real-imag x y)
      ((get 'make-from-real-imag 'rectangular) x y))
    (define (make-from-mag-ang r a)
      ((get 'make-from-mag-ang 'polar) r a))
    (define (add-complex z1 z2)
      (make-from-real-imag (+ (real-part z1) (real-part z2))
			   (+ (imag-part z1) (imag-part z2))))
    (define (sub-complex z1 z2)
      (make-from-real-imag (- (real-part z1) (real-part z2))
			   (- (imag-part z1) (imag-part z2))))
    (define (mul-complex z1 z2)
      (make-from-mag-ang (* (magnitude z1) (magnitude z2))
			 (+ (angle z1) (angle z2))))
    (define (div-complex z1 z2)
      (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
			 (- (angle z1) (angle z2))))
    (define (tag z) (attach-tag 'complex z))
    (put 'add '(complex complex)
	 (lambda (z1 z2) (tag (add-complex z1 z2))))
    (put 'sub '(complex complex)
	 (lambda (z1 z2) (tag (sub-complex z1 z2))))
    (put 'mul '(complex complex)
	 (lambda (z1 z2) (tag (mul-complex z1 z2))))
    (put 'div '(complex complex)
	 (lambda (z1 z2) (tag (div-complex z1 z2))))
    (put 'make-from-real-imag 'complex
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'complex
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    (put 'equ? '(complex complex)
         (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
                      (= 0 (imag-part (sub-complex x y))))))
    'done)

  (define (make-complex-from-real-imag x y)
    ((get 'make-from-real-imag 'complex) x y))

  (define (make-complex-from-mag-ang r a)
    ((get 'make-from-mag-ang 'complex) r a))



  (install-rectangular-package)
  (install-polar-package)
  (install-rational-package)
  (install-scheme-number-package)
  (install-complex-package)

  (show #t "Scheme-number: " (equ? (make-scheme-number 1) (make-scheme-number 2)) "\n")
  (show #t "Rational: " (equ? (make-rational 1 2) (make-rational 2 4)) "\n")
  (show #t "Complex: " (equ? (make-complex-from-mag-ang 1 0)
                             (make-complex-from-real-imag 1 0)) "\n")
#+end_src

#+RESULTS:
: Scheme-number: #f
: Rational: #t
: Complex: #t

*** DONE Exercise 2.80 Generic arithmetic zero?
    CLOSED: [2019-10-14 Mon 17:18]

#+begin_src scheme :exports both :results output

  (define false #f)
  (define true  #t)
  (define (make-table)
    (let ((local-table (list '*table*)))
      (define (lookup key-1 key-2)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (cdr record)
		    false))
	      false)))
      (define (insert! key-1 key-2 value)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (set-cdr! record value)
		    (set-cdr! subtable
			      (cons (cons key-2 value)
				    (cdr subtable)))))
	      (set-cdr! local-table
			(cons (list key-1
				    (cons key-2 value))
			      (cdr local-table)))))
	'ok)
      (define (dispatch m)
	(cond ((eq? m 'lookup-proc) lookup)
	      ((eq? m 'insert-proc!) insert!)
	      (else (error "Unknown operation -- TABLE" m))))
      dispatch))

  (define operation-table (make-table))
  (define get (operation-table 'lookup-proc))
  (define put (operation-table 'insert-proc!))
  (define (attach-tag type-tag contents)
    (cons type-tag contents))

  (define (type-tag datum)
    (if (pair? datum)
	(car datum)
	(error "Bad tagged datum -- TYPE-TAG" datum)))

  (define (contents datum)
    (if (pair? datum)
	(cdr datum)
	(error "Bad tagged datum -- CONTENTS" datum)))

  (define (rectangular? z)
    (eq? (type-tag z) 'rectangular))

  (define (polar? z)
    (eq? (type-tag z) 'polar))

  (define (apply-generic op . args)
    (let ((type-tags (map type-tag args)))
      (let ((proc (get op type-tags)))
	(if proc
	    (apply proc (map contents args))
	    (error
	      "No method for these types -- APPLY-GENERIC"
	      (list op type-tags))))))

  (define (real-part z) (apply-generic 'real-part z))
  (define (imag-part z) (apply-generic 'imag-part z))
  (define (magnitude z) (apply-generic 'magnitude z))
  (define (angle z) (apply-generic 'angle z))

  (define (add x y) (apply-generic 'add x y))
  (define (sub x y) (apply-generic 'sub x y))
  (define (mul x y) (apply-generic 'mul x y))
  (define (div x y) (apply-generic 'div x y))
   
  (define (equ? x y) (apply-generic 'equ? x y))
  (define (zero? x) (apply-generic 'zero? x))

  (define (install-scheme-number-package)
    (define (tag x)
      (attach-tag 'scheme-number x))
    (put 'add '(scheme-number scheme-number)
	 (lambda (x y) (tag (+ x y))))
    (put 'sub '(scheme-number scheme-number)
	 (lambda (x y) (tag (- x y))))
    (put 'mul '(scheme-number scheme-number)
	 (lambda (x y) (tag (* x y))))
    (put 'div '(scheme-number scheme-number)
	 (lambda (x y) (tag (/ x y))))
    (put 'make 'scheme-number
	 (lambda (x) (tag x)))
    (put 'equ? '(scheme-number scheme-number)
         (lambda (x y) (= x y)))
    (put 'zero? '(scheme-number)
          (lambda (x) (= 0 x)))
    'done)

  (define (make-scheme-number n)
    ((get 'make 'scheme-number) n))

  (define (install-rational-package)
    (define (numer x) (car x))
    (define (denom x) (cdr x))
    (define (make-rat n d)
      (let ((g (gcd n d)))
	(cons (/ n g) (/ d g))))
    (define (add-rat x y)
      (make-rat (+ (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (sub-rat x y)
      (make-rat (- (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (mul-rat x y)
      (make-rat (* (numer x) (numer y))
		(* (denom x) (denom y))))
    (define (div-rat x y)
      (make-rat (* (numer x) (denom y))
		(* (denom x) (numer y))))

    (define (tag x) (attach-tag 'rational x))
    (put 'add '(rational rational)
	 (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
	 (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
	 (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
	 (lambda (x y) (tag (div-rat x y))))

    (put 'make 'rational
	 (lambda (n d) (tag (make-rat n d))))
    (put 'equ? '(rational rational)
         (lambda (x y) (= 0 (numer (sub-rat x y)))))
    (put 'zero? '(rational) (lambda (x) (= 0 (numer x))))
    'done)

  (define (make-rational n d)
    ((get 'make 'rational) n d))

  (define (install-rectangular-package)

    (define (real-part z) (car z))
    (define (imag-part z) (cdr z))
    (define (make-from-real-imag x y) (cons x y))
    (define (magnitude z)
      (sqrt (+ (square (real-part z))
	       (square (imag-part z)))))
    (define (angle z)
      (atan (imag-part z) (real-part z)))
    (define (make-from-mag-ang r a)
      (cons (* r (cos a)) (* r (sin a))))

    (define (tag x) (attach-tag 'rectangular x))
    (put 'real-part '(rectangular) real-part)
    (put 'imag-part '(rectangular) imag-part)
    (put 'magnitude '(rectangular) magnitude)
    (put 'angle '(rectangular) angle)
    (put 'make-from-real-imag 'rectangular
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'rectangular
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-polar-package)

    (define (magnitude z) (car z))
    (define (angle z) (cdr z))
    (define (make-from-mag-ang r a) (cons r a))
    (define (real-part z)
      (* (magnitude z) (cos (angle z))))
    (define (imag-part z)
      (* (magnitude z) (sin (angle z))))
    (define (make-from-real-imag x y)
      (cons (sqrt (+ (square x) (square y)))
	    (atan y x)))

    (define (tag x) (attach-tag 'polar x))
    (put 'real-part '(polar) real-part)
    (put 'imag-part '(polar) imag-part)
    (put 'magnitude '(polar) magnitude)
    (put 'angle '(polar) angle)
    (put 'make-from-real-imag 'polar
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'polar
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-complex-package)
    (define (make-from-real-imag x y)
      ((get 'make-from-real-imag 'rectangular) x y))
    (define (make-from-mag-ang r a)
      ((get 'make-from-mag-ang 'polar) r a))
    (define (add-complex z1 z2)
      (make-from-real-imag (+ (real-part z1) (real-part z2))
			   (+ (imag-part z1) (imag-part z2))))
    (define (sub-complex z1 z2)
      (make-from-real-imag (- (real-part z1) (real-part z2))
			   (- (imag-part z1) (imag-part z2))))
    (define (mul-complex z1 z2)
      (make-from-mag-ang (* (magnitude z1) (magnitude z2))
			 (+ (angle z1) (angle z2))))
    (define (div-complex z1 z2)
      (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
			 (- (angle z1) (angle z2))))
    (define (tag z) (attach-tag 'complex z))
    (put 'add '(complex complex)
	 (lambda (z1 z2) (tag (add-complex z1 z2))))
    (put 'sub '(complex complex)
	 (lambda (z1 z2) (tag (sub-complex z1 z2))))
    (put 'mul '(complex complex)
	 (lambda (z1 z2) (tag (mul-complex z1 z2))))
    (put 'div '(complex complex)
	 (lambda (z1 z2) (tag (div-complex z1 z2))))
    (put 'make-from-real-imag 'complex
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'complex
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    (put 'equ? '(complex complex)
         (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
                      (= 0 (imag-part (sub-complex x y))))))
    (put 'equ? '(rectangular polar) equ?)
    (put 'equ? '(polar rectangular) equ?)
    (put 'zero? '(complex)
         (lambda (x) (equ? (tag x) (tag (make-from-real-imag 0 0)))))
    'done)

  (define (make-complex-from-real-imag x y)
    ((get 'make-from-real-imag 'complex) x y))

  (define (make-complex-from-mag-ang r a)
    ((get 'make-from-mag-ang 'complex) r a))



  (install-rectangular-package)
  (install-polar-package)
  (install-rational-package)
  (install-scheme-number-package)
  (install-complex-package)

  (show #t "Scheme-number: " (zero? (make-scheme-number 0)) "\n")
  (show #t "Rational: " (zero? (make-rational 0 2)) "\n")
  (show #t "Complex: " (zero? (make-complex-from-mag-ang 0 0)) "\n")
#+end_src

#+RESULTS:
: Scheme-number: #t
: Rational: #t
: Complex: #t

*** Snippet put-coercion
I added the ~put-coercion~ and ~get-coercion~ procedures to the
<<put-and-get>> noweb fragment. This doesn't seem to be much of a problem,
because these operations are not used before this point.
*** Snippet coercion procedures

We are modifying ~apply-generic~ in this snippet, which means that we may
need to do a lot of copying of the old code in order to make it work with the
new code.

#+begin_src scheme :exports both :results output :noweb-ref coercion-procedures-apply-generic
  (define (scheme-number->complex n)
    (make-complex-from-real-imag (contents n) 0))
  (put-coercion 'scheme-number
		'complex
		scheme-number->complex)

  (define (apply-generic op . args)
    (let ((type-tags (map type-tag args)))
      (let ((proc (get op type-tags)))
	(if proc
	    (apply proc (map contents args))
	    (if (= (length args) 2)
		(let ((type1 (car type-tags))
		      (type2 (cadr type-tags))
		      (a1 (car args))
		      (a2 (cadr args)))
		  (let ((t1->t2 (get-coercion type1 type2))
			(t2->t1 (get-coercion type2 type1)))
		    (cond (t1->t2
			   (apply-generic op (t1->t2 a1) a2))
			  (t2->t1
			   (apply-generic op a1 (t2->t1 a2)))
			  (else
			   (error "No method for these types"
				  (list op type-tags))))))
		(error "No method for these types"
		       (list op type-tags)))))))


#+end_src

#+RESULTS:
: Exception: {Exception #19 user "undefined variable" (put-coercion) #<procedure #f> (#f . 4)}

*** DONE Exercise 2.81 coercion to-itself
    CLOSED: [2019-10-15 Tue 11:16]
Another extremely ill-defined problem.
Let us try to do some mind-reading to understand which parts of code we need
to tangle to solve it letter by letter.

**** a

I will tangle in the version of the algebra package from the Exercise-2.80,
but I will replace the ~apply-generic~ with a coercing version.

#+begin_src scheme :exports both :results output
  (define false #f)
  (define true  #t)
  (define (make-table)
    (let ((local-table (list '*table*)))
      (define (lookup key-1 key-2)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (cdr record)
		    false))
	      false)))
      (define (insert! key-1 key-2 value)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (set-cdr! record value)
		    (set-cdr! subtable
			      (cons (cons key-2 value)
				    (cdr subtable)))))
	      (set-cdr! local-table
			(cons (list key-1
				    (cons key-2 value))
			      (cdr local-table)))))
	'ok)
      (define (dispatch m)
	(cond ((eq? m 'lookup-proc) lookup)
	      ((eq? m 'insert-proc!) insert!)
	      (else (error "Unknown operation -- TABLE" m))))
      dispatch))

  (define operation-table (make-table))
  (define get (operation-table 'lookup-proc))
  (define put (operation-table 'insert-proc!))

  (define coercion-table (make-table))
  (define get-coercion (coercion-table 'lookup-proc))
  (define put-coercion (coercion-table 'insert-proc!))

  (define (attach-tag type-tag contents)
    (cons type-tag contents))

  (define (type-tag datum)
    (if (pair? datum)
	(car datum)
	(error "Bad tagged datum -- TYPE-TAG" datum)))

  (define (contents datum)
    (if (pair? datum)
	(cdr datum)
	(error "Bad tagged datum -- CONTENTS" datum)))

  (define (rectangular? z)
    (eq? (type-tag z) 'rectangular))

  (define (polar? z)
    (eq? (type-tag z) 'polar))

  (define (apply-generic op . args)
    (let ((type-tags (map type-tag args)))
	 (let ((proc (get op type-tags)))
	   (if proc
	       (apply proc (map contents args))
	       (if (= (length args) 2)
		   (let ((type1 (car type-tags))
			 (type2 (cadr type-tags))
			 (a1 (car args))
			 (a2 (cadr args)))
		     (let ((t1->t2 (get-coercion type1 type2))
			   (t2->t1 (get-coercion type2 type1)))
		       (cond (t1->t2
			      (apply-generic op (t1->t2 a1) a2))
			     (t2->t1
			      (apply-generic op a1 (t2->t1 a2)))
			     (else
			      (error "No method for these types"
				     (list op type-tags))))))
		   (error "No method for these types"
			  (list op type-tags)))))))


  (define (real-part z) (apply-generic 'real-part z))
  (define (imag-part z) (apply-generic 'imag-part z))
  (define (magnitude z) (apply-generic 'magnitude z))
  (define (angle z) (apply-generic 'angle z))

  (define (add x y) (apply-generic 'add x y))
  (define (sub x y) (apply-generic 'sub x y))
  (define (mul x y) (apply-generic 'mul x y))
  (define (div x y) (apply-generic 'div x y))

  (define (equ? x y) (apply-generic 'equ? x y))
  (define (zero? x) (apply-generic 'zero? x))

  (define (exp x y) (apply-generic 'exp x y))

  (define (install-scheme-number-package)
    (define (tag x)
      (attach-tag 'scheme-number x))
    (put 'add '(scheme-number scheme-number)
	 (lambda (x y) (tag (+ x y))))
    (put 'sub '(scheme-number scheme-number)
	 (lambda (x y) (tag (- x y))))
    (put 'mul '(scheme-number scheme-number)
	 (lambda (x y) (tag (* x y))))
    (put 'div '(scheme-number scheme-number)
	 (lambda (x y) (tag (/ x y))))
    (put 'make 'scheme-number
	 (lambda (x) (tag x)))
    (put 'equ? '(scheme-number scheme-number)
	 (lambda (x y) (= x y)))
    (put 'zero? '(scheme-number)
	  (lambda (x) (= 0 x)))
    (put 'exp '(scheme-number scheme-number)
	  (lambda (x y) (tag (expt x y))))

    'done)

  (define (make-scheme-number n)
    ((get 'make 'scheme-number) n))

  (define (install-rational-package)
    (define (numer x) (car x))
    (define (denom x) (cdr x))
    (define (make-rat n d)
      (let ((g (gcd n d)))
	(cons (/ n g) (/ d g))))
    (define (add-rat x y)
      (make-rat (+ (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (sub-rat x y)
      (make-rat (- (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (mul-rat x y)
      (make-rat (* (numer x) (numer y))
		(* (denom x) (denom y))))
    (define (div-rat x y)
      (make-rat (* (numer x) (denom y))
		(* (denom x) (numer y))))

    (define (tag x) (attach-tag 'rational x))
    (put 'add '(rational rational)
	 (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
	 (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
	 (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
	 (lambda (x y) (tag (div-rat x y))))

    (put 'make 'rational
	 (lambda (n d) (tag (make-rat n d))))
    (put 'equ? '(rational rational)
	 (lambda (x y) (= 0 (numer (sub-rat x y)))))
    (put 'zero? '(rational) (lambda (x) (= 0 (numer x))))
    'done)

  (define (make-rational n d)
    ((get 'make 'rational) n d))

  (define (install-rectangular-package)

    (define (real-part z) (car z))
    (define (imag-part z) (cdr z))
    (define (make-from-real-imag x y) (cons x y))
    (define (magnitude z)
      (sqrt (+ (square (real-part z))
	       (square (imag-part z)))))
    (define (angle z)
      (atan (imag-part z) (real-part z)))
    (define (make-from-mag-ang r a)
      (cons (* r (cos a)) (* r (sin a))))

    (define (tag x) (attach-tag 'rectangular x))
    (put 'real-part '(rectangular) real-part)
    (put 'imag-part '(rectangular) imag-part)
    (put 'magnitude '(rectangular) magnitude)
    (put 'angle '(rectangular) angle)
    (put 'make-from-real-imag 'rectangular
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'rectangular
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-polar-package)

    (define (magnitude z) (car z))
    (define (angle z) (cdr z))
    (define (make-from-mag-ang r a) (cons r a))
    (define (real-part z)
      (* (magnitude z) (cos (angle z))))
    (define (imag-part z)
      (* (magnitude z) (sin (angle z))))
    (define (make-from-real-imag x y)
      (cons (sqrt (+ (square x) (square y)))
	    (atan y x)))

    (define (tag x) (attach-tag 'polar x))
    (put 'real-part '(polar) real-part)
    (put 'imag-part '(polar) imag-part)
    (put 'magnitude '(polar) magnitude)
    (put 'angle '(polar) angle)
    (put 'make-from-real-imag 'polar
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'polar
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-complex-package)
    (define (make-from-real-imag x y)
      ((get 'make-from-real-imag 'rectangular) x y))
    (define (make-from-mag-ang r a)
      ((get 'make-from-mag-ang 'polar) r a))
    (define (add-complex z1 z2)
      (make-from-real-imag (+ (real-part z1) (real-part z2))
			   (+ (imag-part z1) (imag-part z2))))
    (define (sub-complex z1 z2)
      (make-from-real-imag (- (real-part z1) (real-part z2))
			   (- (imag-part z1) (imag-part z2))))
    (define (mul-complex z1 z2)
      (make-from-mag-ang (* (magnitude z1) (magnitude z2))
			 (+ (angle z1) (angle z2))))
    (define (div-complex z1 z2)
      (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
			 (- (angle z1) (angle z2))))
    (define (tag z) (attach-tag 'complex z))
    (put 'add '(complex complex)
	 (lambda (z1 z2) (tag (add-complex z1 z2))))
    (put 'sub '(complex complex)
	 (lambda (z1 z2) (tag (sub-complex z1 z2))))
    (put 'mul '(complex complex)
	 (lambda (z1 z2) (tag (mul-complex z1 z2))))
    (put 'div '(complex complex)
	 (lambda (z1 z2) (tag (div-complex z1 z2))))
    (put 'make-from-real-imag 'complex
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'complex
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    (put 'equ? '(complex complex)
	 (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
		      (= 0 (imag-part (sub-complex x y))))))
    (put 'equ? '(rectangular polar) equ?)
    (put 'equ? '(polar rectangular) equ?)
    (put 'zero? '(complex)
	 (lambda (x) (equ? (tag x) (tag (make-from-real-imag 0 0)))))
    'done)

  (define (make-complex-from-real-imag x y)
    ((get 'make-from-real-imag 'complex) x y))

  (define (make-complex-from-mag-ang r a)
    ((get 'make-from-mag-ang 'complex) r a))



  (install-rectangular-package)
  (install-polar-package)
  (install-rational-package)
  (install-scheme-number-package)
  (install-complex-package)

  (define (scheme-number->scheme-number n) n)
  (define (complex->complex z) z)
  (put-coercion 'scheme-number 'scheme-number
                 scheme-number->scheme-number)
  (put-coercion 'complex 'complex complex->complex)

(show #t (displayed (exp (make-complex-from-mag-ang 2 0) (make-complex-from-mag-ang 2 0))))

#+end_src

#+RESULTS:
: Geiser-eval--retort-output returned nil.
: The interpreter produced no output
: or there is a bug in geiser (likely!)

We can see that this code doesn't work as expected. Why? 
The answer is because the new version of ~apply-generic~ only checks if the
coercions exist, not whether the function on the new coerced types exists.

This seems like making sense, as in order to "find a common denominator",
more than one coercion may be needed, but the result is not good in the sense
that if the final function doesn't exist, ~apply-generic~ ends up applying
itself over and over. So the strategy proposed by Louis is not very good.

**** b

#+begin_src scheme :exports both :results output
  (define false #f)
  (define true  #t)
  (define (make-table)
    (let ((local-table (list '*table*)))
      (define (lookup key-1 key-2)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (cdr record)
		    false))
	      false)))
      (define (insert! key-1 key-2 value)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (set-cdr! record value)
		    (set-cdr! subtable
			      (cons (cons key-2 value)
				    (cdr subtable)))))
	      (set-cdr! local-table
			(cons (list key-1
				    (cons key-2 value))
			      (cdr local-table)))))
	'ok)
      (define (dispatch m)
	(cond ((eq? m 'lookup-proc) lookup)
	      ((eq? m 'insert-proc!) insert!)
	      (else (error "Unknown operation -- TABLE" m))))
      dispatch))

  (define operation-table (make-table))
  (define get (operation-table 'lookup-proc))
  (define put (operation-table 'insert-proc!))

  (define coercion-table (make-table))
  (define get-coercion (coercion-table 'lookup-proc))
  (define put-coercion (coercion-table 'insert-proc!))

  (define (attach-tag type-tag contents)
    (cons type-tag contents))

  (define (type-tag datum)
    (if (pair? datum)
	(car datum)
	(error "Bad tagged datum -- TYPE-TAG" datum)))

  (define (contents datum)
    (if (pair? datum)
	(cdr datum)
	(error "Bad tagged datum -- CONTENTS" datum)))

  (define (rectangular? z)
    (eq? (type-tag z) 'rectangular))

  (define (polar? z)
    (eq? (type-tag z) 'polar))

  (define (apply-generic op . args)
    (let ((type-tags (map type-tag args)))
	 (let ((proc (get op type-tags)))
	   (if proc
	       (apply proc (map contents args))
	       (if (= (length args) 2)
		   (let ((type1 (car type-tags))
			 (type2 (cadr type-tags))
			 (a1 (car args))
			 (a2 (cadr args)))
		     (let ((t1->t2 (get-coercion type1 type2))
			   (t2->t1 (get-coercion type2 type1)))
		       (cond (t1->t2
			      (apply-generic op (t1->t2 a1) a2))
			     (t2->t1
			      (apply-generic op a1 (t2->t1 a2)))
			     (else
			      (error "No method for these types"
				     (list op type-tags))))))
		   (error "No method for these types"
			  (list op type-tags)))))))


  (define (real-part z) (apply-generic 'real-part z))
  (define (imag-part z) (apply-generic 'imag-part z))
  (define (magnitude z) (apply-generic 'magnitude z))
  (define (angle z) (apply-generic 'angle z))

  (define (add x y) (apply-generic 'add x y))
  (define (sub x y) (apply-generic 'sub x y))
  (define (mul x y) (apply-generic 'mul x y))
  (define (div x y) (apply-generic 'div x y))

  (define (equ? x y) (apply-generic 'equ? x y))
  (define (zero? x) (apply-generic 'zero? x))

  (define (exp x y) (apply-generic 'exp x y))

  (define (install-scheme-number-package)
    (define (tag x)
      (attach-tag 'scheme-number x))
    (put 'add '(scheme-number scheme-number)
	 (lambda (x y) (tag (+ x y))))
    (put 'sub '(scheme-number scheme-number)
	 (lambda (x y) (tag (- x y))))
    (put 'mul '(scheme-number scheme-number)
	 (lambda (x y) (tag (* x y))))
    (put 'div '(scheme-number scheme-number)
	 (lambda (x y) (tag (/ x y))))
    (put 'make 'scheme-number
	 (lambda (x) (tag x)))
    (put 'equ? '(scheme-number scheme-number)
	 (lambda (x y) (= x y)))
    (put 'zero? '(scheme-number)
	  (lambda (x) (= 0 x)))
    (put 'exp '(scheme-number scheme-number)
	  (lambda (x y) (tag (expt x y))))

    'done)

  (define (make-scheme-number n)
    ((get 'make 'scheme-number) n))

  (define (install-rational-package)
    (define (numer x) (car x))
    (define (denom x) (cdr x))
    (define (make-rat n d)
      (let ((g (gcd n d)))
	(cons (/ n g) (/ d g))))
    (define (add-rat x y)
      (make-rat (+ (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (sub-rat x y)
      (make-rat (- (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (mul-rat x y)
      (make-rat (* (numer x) (numer y))
		(* (denom x) (denom y))))
    (define (div-rat x y)
      (make-rat (* (numer x) (denom y))
		(* (denom x) (numer y))))

    (define (tag x) (attach-tag 'rational x))
    (put 'add '(rational rational)
	 (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
	 (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
	 (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
	 (lambda (x y) (tag (div-rat x y))))

    (put 'make 'rational
	 (lambda (n d) (tag (make-rat n d))))
    (put 'equ? '(rational rational)
	 (lambda (x y) (= 0 (numer (sub-rat x y)))))
    (put 'zero? '(rational) (lambda (x) (= 0 (numer x))))
    'done)

  (define (make-rational n d)
    ((get 'make 'rational) n d))

  (define (install-rectangular-package)

    (define (real-part z) (car z))
    (define (imag-part z) (cdr z))
    (define (make-from-real-imag x y) (cons x y))
    (define (magnitude z)
      (sqrt (+ (square (real-part z))
	       (square (imag-part z)))))
    (define (angle z)
      (atan (imag-part z) (real-part z)))
    (define (make-from-mag-ang r a)
      (cons (* r (cos a)) (* r (sin a))))

    (define (tag x) (attach-tag 'rectangular x))
    (put 'real-part '(rectangular) real-part)
    (put 'imag-part '(rectangular) imag-part)
    (put 'magnitude '(rectangular) magnitude)
    (put 'angle '(rectangular) angle)
    (put 'make-from-real-imag 'rectangular
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'rectangular
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-polar-package)

    (define (magnitude z) (car z))
    (define (angle z) (cdr z))
    (define (make-from-mag-ang r a) (cons r a))
    (define (real-part z)
      (* (magnitude z) (cos (angle z))))
    (define (imag-part z)
      (* (magnitude z) (sin (angle z))))
    (define (make-from-real-imag x y)
      (cons (sqrt (+ (square x) (square y)))
	    (atan y x)))

    (define (tag x) (attach-tag 'polar x))
    (put 'real-part '(polar) real-part)
    (put 'imag-part '(polar) imag-part)
    (put 'magnitude '(polar) magnitude)
    (put 'angle '(polar) angle)
    (put 'make-from-real-imag 'polar
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'polar
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-complex-package)
    (define (make-from-real-imag x y)
      ((get 'make-from-real-imag 'rectangular) x y))
    (define (make-from-mag-ang r a)
      ((get 'make-from-mag-ang 'polar) r a))
    (define (add-complex z1 z2)
      (make-from-real-imag (+ (real-part z1) (real-part z2))
			   (+ (imag-part z1) (imag-part z2))))
    (define (sub-complex z1 z2)
      (make-from-real-imag (- (real-part z1) (real-part z2))
			   (- (imag-part z1) (imag-part z2))))
    (define (mul-complex z1 z2)
      (make-from-mag-ang (* (magnitude z1) (magnitude z2))
			 (+ (angle z1) (angle z2))))
    (define (div-complex z1 z2)
      (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
			 (- (angle z1) (angle z2))))
    (define (tag z) (attach-tag 'complex z))
    (put 'add '(complex complex)
	 (lambda (z1 z2) (tag (add-complex z1 z2))))
    (put 'sub '(complex complex)
	 (lambda (z1 z2) (tag (sub-complex z1 z2))))
    (put 'mul '(complex complex)
	 (lambda (z1 z2) (tag (mul-complex z1 z2))))
    (put 'div '(complex complex)
	 (lambda (z1 z2) (tag (div-complex z1 z2))))
    (put 'make-from-real-imag 'complex
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'complex
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    (put 'equ? '(complex complex)
	 (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
		      (= 0 (imag-part (sub-complex x y))))))
    (put 'equ? '(rectangular polar) equ?)
    (put 'equ? '(polar rectangular) equ?)
    (put 'zero? '(complex)
	 (lambda (x) (equ? (tag x) (tag (make-from-real-imag 0 0)))))
    'done)

  (define (make-complex-from-real-imag x y)
    ((get 'make-from-real-imag 'complex) x y))

  (define (make-complex-from-mag-ang r a)
    ((get 'make-from-mag-ang 'complex) r a))



  (install-rectangular-package)
  (install-polar-package)
  (install-rational-package)
  (install-scheme-number-package)
  (install-complex-package)

(show #t " " (displayed (exp (make-scheme-number 2) (make-scheme-number 2))) "\n")
(show #t " " (displayed (exp (make-complex-from-mag-ang 2 0) 
                             (make-complex-from-mag-ang 2 0))))
#+end_src

#+RESULTS:
:  (scheme-number . 4)
: Exception: {Exception #19 user "No method for these types" ((exp (complex complex))) #f #f}

This seems correct. There may be a problem when the function is actually
defined for some types that the given ones are coerce-able to, but the system
doesn't try that.

**** c

#+begin_src scheme :exports both :results output
  (define false #f)
  (define true  #t)
  (define (make-table)
    (let ((local-table (list '*table*)))
      (define (lookup key-1 key-2)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (cdr record)
		    false))
	      false)))
      (define (insert! key-1 key-2 value)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (set-cdr! record value)
		    (set-cdr! subtable
			      (cons (cons key-2 value)
				    (cdr subtable)))))
	      (set-cdr! local-table
			(cons (list key-1
				    (cons key-2 value))
			      (cdr local-table)))))
	'ok)
      (define (dispatch m)
	(cond ((eq? m 'lookup-proc) lookup)
	      ((eq? m 'insert-proc!) insert!)
	      (else (error "Unknown operation -- TABLE" m))))
      dispatch))

  (define operation-table (make-table))
  (define get (operation-table 'lookup-proc))
  (define put (operation-table 'insert-proc!))

  (define coercion-table (make-table))
  (define get-coercion (coercion-table 'lookup-proc))
  (define put-coercion (coercion-table 'insert-proc!))

  (define (attach-tag type-tag contents)
    (cons type-tag contents))

  (define (type-tag datum)
    (if (pair? datum)
	(car datum)
	(error "Bad tagged datum -- TYPE-TAG" datum)))

  (define (contents datum)
    (if (pair? datum)
	(cdr datum)
	(error "Bad tagged datum -- CONTENTS" datum)))

  (define (rectangular? z)
    (eq? (type-tag z) 'rectangular))

  (define (polar? z)
    (eq? (type-tag z) 'polar))

  (define (apply-generic op . args)
    (let ((type-tags (map type-tag args)))
	 (let ((proc (get op type-tags)))
	   (if proc
	       (apply proc (map contents args))
	       (if (and (= (length args) 2) (not (eq? (car type-tags) (cadr type-tags))))
		   (let ((type1 (car type-tags))
			 (type2 (cadr type-tags))
			 (a1 (car args))
			 (a2 (cadr args)))
		     (let ((t1->t2 (get-coercion type1 type2))
			   (t2->t1 (get-coercion type2 type1)))
		       (cond (t1->t2
			      (apply-generic op (t1->t2 a1) a2))
			     (t2->t1
			      (apply-generic op a1 (t2->t1 a2)))
			     (else
			      (error "No method for these types"
				     (list op type-tags))))))
		   (error "No method for these types"
			  (list op type-tags)))))))


  (define (real-part z) (apply-generic 'real-part z))
  (define (imag-part z) (apply-generic 'imag-part z))
  (define (magnitude z) (apply-generic 'magnitude z))
  (define (angle z) (apply-generic 'angle z))

  (define (add x y) (apply-generic 'add x y))
  (define (sub x y) (apply-generic 'sub x y))
  (define (mul x y) (apply-generic 'mul x y))
  (define (div x y) (apply-generic 'div x y))

  (define (equ? x y) (apply-generic 'equ? x y))
  (define (zero? x) (apply-generic 'zero? x))

  (define (exp x y) (apply-generic 'exp x y))

  (define (install-scheme-number-package)
    (define (tag x)
      (attach-tag 'scheme-number x))
    (put 'add '(scheme-number scheme-number)
	 (lambda (x y) (tag (+ x y))))
    (put 'sub '(scheme-number scheme-number)
	 (lambda (x y) (tag (- x y))))
    (put 'mul '(scheme-number scheme-number)
	 (lambda (x y) (tag (* x y))))
    (put 'div '(scheme-number scheme-number)
	 (lambda (x y) (tag (/ x y))))
    (put 'make 'scheme-number
	 (lambda (x) (tag x)))
    (put 'equ? '(scheme-number scheme-number)
	 (lambda (x y) (= x y)))
    (put 'zero? '(scheme-number)
	  (lambda (x) (= 0 x)))
    (put 'exp '(scheme-number scheme-number)
	  (lambda (x y) (tag (expt x y))))

    'done)

  (define (make-scheme-number n)
    ((get 'make 'scheme-number) n))

  (define (install-rational-package)
    (define (numer x) (car x))
    (define (denom x) (cdr x))
    (define (make-rat n d)
      (let ((g (gcd n d)))
	(cons (/ n g) (/ d g))))
    (define (add-rat x y)
      (make-rat (+ (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (sub-rat x y)
      (make-rat (- (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (mul-rat x y)
      (make-rat (* (numer x) (numer y))
		(* (denom x) (denom y))))
    (define (div-rat x y)
      (make-rat (* (numer x) (denom y))
		(* (denom x) (numer y))))

    (define (tag x) (attach-tag 'rational x))
    (put 'add '(rational rational)
	 (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
	 (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
	 (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
	 (lambda (x y) (tag (div-rat x y))))

    (put 'make 'rational
	 (lambda (n d) (tag (make-rat n d))))
    (put 'equ? '(rational rational)
	 (lambda (x y) (= 0 (numer (sub-rat x y)))))
    (put 'zero? '(rational) (lambda (x) (= 0 (numer x))))
    'done)

  (define (make-rational n d)
    ((get 'make 'rational) n d))

  (define (install-rectangular-package)

    (define (real-part z) (car z))
    (define (imag-part z) (cdr z))
    (define (make-from-real-imag x y) (cons x y))
    (define (magnitude z)
      (sqrt (+ (square (real-part z))
	       (square (imag-part z)))))
    (define (angle z)
      (atan (imag-part z) (real-part z)))
    (define (make-from-mag-ang r a)
      (cons (* r (cos a)) (* r (sin a))))

    (define (tag x) (attach-tag 'rectangular x))
    (put 'real-part '(rectangular) real-part)
    (put 'imag-part '(rectangular) imag-part)
    (put 'magnitude '(rectangular) magnitude)
    (put 'angle '(rectangular) angle)
    (put 'make-from-real-imag 'rectangular
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'rectangular
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-polar-package)

    (define (magnitude z) (car z))
    (define (angle z) (cdr z))
    (define (make-from-mag-ang r a) (cons r a))
    (define (real-part z)
      (* (magnitude z) (cos (angle z))))
    (define (imag-part z)
      (* (magnitude z) (sin (angle z))))
    (define (make-from-real-imag x y)
      (cons (sqrt (+ (square x) (square y)))
	    (atan y x)))

    (define (tag x) (attach-tag 'polar x))
    (put 'real-part '(polar) real-part)
    (put 'imag-part '(polar) imag-part)
    (put 'magnitude '(polar) magnitude)
    (put 'angle '(polar) angle)
    (put 'make-from-real-imag 'polar
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'polar
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-complex-package)
    (define (make-from-real-imag x y)
      ((get 'make-from-real-imag 'rectangular) x y))
    (define (make-from-mag-ang r a)
      ((get 'make-from-mag-ang 'polar) r a))
    (define (add-complex z1 z2)
      (make-from-real-imag (+ (real-part z1) (real-part z2))
			   (+ (imag-part z1) (imag-part z2))))
    (define (sub-complex z1 z2)
      (make-from-real-imag (- (real-part z1) (real-part z2))
			   (- (imag-part z1) (imag-part z2))))
    (define (mul-complex z1 z2)
      (make-from-mag-ang (* (magnitude z1) (magnitude z2))
			 (+ (angle z1) (angle z2))))
    (define (div-complex z1 z2)
      (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
			 (- (angle z1) (angle z2))))
    (define (tag z) (attach-tag 'complex z))
    (put 'add '(complex complex)
	 (lambda (z1 z2) (tag (add-complex z1 z2))))
    (put 'sub '(complex complex)
	 (lambda (z1 z2) (tag (sub-complex z1 z2))))
    (put 'mul '(complex complex)
	 (lambda (z1 z2) (tag (mul-complex z1 z2))))
    (put 'div '(complex complex)
	 (lambda (z1 z2) (tag (div-complex z1 z2))))
    (put 'make-from-real-imag 'complex
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'complex
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    (put 'equ? '(complex complex)
	 (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
		      (= 0 (imag-part (sub-complex x y))))))
    (put 'equ? '(rectangular polar) equ?)
    (put 'equ? '(polar rectangular) equ?)
    (put 'zero? '(complex)
	 (lambda (x) (equ? (tag x) (tag (make-from-real-imag 0 0)))))
    'done)

  (define (make-complex-from-real-imag x y)
    ((get 'make-from-real-imag 'complex) x y))

  (define (make-complex-from-mag-ang r a)
    ((get 'make-from-mag-ang 'complex) r a))



  (install-rectangular-package)
  (install-polar-package)
  (install-rational-package)
  (install-scheme-number-package)
  (install-complex-package)

(show #t " " (displayed (exp (make-scheme-number 2) (make-scheme-number 2))))


#+end_src

#+RESULTS:
:  (scheme-number . 4)

*** DONE Exercise 2.82 three-argument-coercion
    CLOSED: [2019-10-15 Tue 21:40]
I am copying the whole "algebra" mess, because I already lost track of which
functions are needed for the tests to work. Bad practice, don't do so.

#+begin_src scheme :exports both :results output :noweb-ref generic-arithmetic-packages-multidispatch
  (define false #f)
  (define true  #t)
  (define (make-table)
    (let ((local-table (list '*table*)))
      (define (lookup key-1 key-2)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (cdr record)
		    false))
	      false)))
      (define (insert! key-1 key-2 value)
	(let ((subtable (assoc key-1 (cdr local-table))))
	  (if subtable
	      (let ((record (assoc key-2 (cdr subtable))))
		(if record
		    (set-cdr! record value)
		    (set-cdr! subtable
			      (cons (cons key-2 value)
				    (cdr subtable)))))
	      (set-cdr! local-table
			(cons (list key-1
				    (cons key-2 value))
			      (cdr local-table)))))
	'ok)
      (define (dispatch m)
	(cond ((eq? m 'lookup-proc) lookup)
	      ((eq? m 'insert-proc!) insert!)
	      (else (error "Unknown operation -- TABLE" m))))
      dispatch))

  (define operation-table (make-table))
  (define get (operation-table 'lookup-proc))
  (define put (operation-table 'insert-proc!))

  (define coercion-table (make-table))
  (define get-coercion (coercion-table 'lookup-proc))
  (define put-coercion (coercion-table 'insert-proc!))

  (define (attach-tag type-tag contents)
    (cons type-tag contents))

  (define (type-tag datum)
    (if (pair? datum)
	(car datum)
	(error "Bad tagged datum -- TYPE-TAG" datum)))

  (define (contents datum)
    (if (pair? datum)
	(cdr datum)
	(error "Bad tagged datum -- CONTENTS" datum)))

  (define (rectangular? z)
    (eq? (type-tag z) 'rectangular))

  (define (polar? z)
    (eq? (type-tag z) 'polar))


  (define (real-part z) (apply-generic 'real-part z))
  (define (imag-part z) (apply-generic 'imag-part z))
  (define (magnitude z) (apply-generic 'magnitude z))
  (define (angle z) (apply-generic 'angle z))

  (define (add x y) (apply-generic 'add x y))
  (define (sub x y) (apply-generic 'sub x y))
  (define (mul x y) (apply-generic 'mul x y))
  (define (div x y) (apply-generic 'div x y))

  (define (equ? x y) (apply-generic 'equ? x y))
  (define (zero? x) (apply-generic 'zero? x))

  (define (exp x y) (apply-generic 'exp x y))

  (define (install-scheme-number-package)
    (define (tag x)
      (attach-tag 'scheme-number x))
    (put 'add '(scheme-number scheme-number)
	 (lambda (x y) (tag (+ x y))))
    (put 'sub '(scheme-number scheme-number)
	 (lambda (x y) (tag (- x y))))
    (put 'mul '(scheme-number scheme-number)
	 (lambda (x y) (tag (* x y))))
    (put 'div '(scheme-number scheme-number)
	 (lambda (x y) (tag (/ x y))))
    (put 'make 'scheme-number
	 (lambda (x) (tag x)))
    (put 'equ? '(scheme-number scheme-number)
	 (lambda (x y) (= x y)))
    (put 'zero? '(scheme-number)
	  (lambda (x) (= 0 x)))
    (put 'exp '(scheme-number scheme-number)
	  (lambda (x y) (tag (expt x y))))

    'done)

  (define (make-scheme-number n)
    ((get 'make 'scheme-number) n))

  (define (install-rational-package)
    (define (numer x) (car x))
    (define (denom x) (cdr x))
    (define (make-rat n d)
      (let ((g (gcd n d)))
	(cons (/ n g) (/ d g))))
    (define (add-rat x y)
      (make-rat (+ (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (sub-rat x y)
      (make-rat (- (* (numer x) (denom y))
		   (* (numer y) (denom x)))
		(* (denom x) (denom y))))
    (define (mul-rat x y)
      (make-rat (* (numer x) (numer y))
		(* (denom x) (denom y))))
    (define (div-rat x y)
      (make-rat (* (numer x) (denom y))
		(* (denom x) (numer y))))

    (define (tag x) (attach-tag 'rational x))
    (put 'add '(rational rational)
	 (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
	 (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
	 (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
	 (lambda (x y) (tag (div-rat x y))))

    (put 'make 'rational
	 (lambda (n d) (tag (make-rat n d))))
    (put 'equ? '(rational rational)
	 (lambda (x y) (= 0 (numer (sub-rat x y)))))
    (put 'zero? '(rational) (lambda (x) (= 0 (numer x))))
    'done)

  (define (make-rational n d)
    ((get 'make 'rational) n d))

  (define (install-rectangular-package)

    (define (real-part z) (car z))
    (define (imag-part z) (cdr z))
    (define (make-from-real-imag x y) (cons x y))
    (define (magnitude z)
      (sqrt (+ (square (real-part z))
	       (square (imag-part z)))))
    (define (angle z)
      (atan (imag-part z) (real-part z)))
    (define (make-from-mag-ang r a)
      (cons (* r (cos a)) (* r (sin a))))

    (define (tag x) (attach-tag 'rectangular x))
    (put 'real-part '(rectangular) real-part)
    (put 'imag-part '(rectangular) imag-part)
    (put 'magnitude '(rectangular) magnitude)
    (put 'angle '(rectangular) angle)
    (put 'make-from-real-imag 'rectangular
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'rectangular
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-polar-package)

    (define (magnitude z) (car z))
    (define (angle z) (cdr z))
    (define (make-from-mag-ang r a) (cons r a))
    (define (real-part z)
      (* (magnitude z) (cos (angle z))))
    (define (imag-part z)
      (* (magnitude z) (sin (angle z))))
    (define (make-from-real-imag x y)
      (cons (sqrt (+ (square x) (square y)))
	    (atan y x)))

    (define (tag x) (attach-tag 'polar x))
    (put 'real-part '(polar) real-part)
    (put 'imag-part '(polar) imag-part)
    (put 'magnitude '(polar) magnitude)
    (put 'angle '(polar) angle)
    (put 'make-from-real-imag 'polar
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'polar
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    'done)

  (define (install-complex-package)
    (define (make-from-real-imag x y)
      ((get 'make-from-real-imag 'rectangular) x y))
    (define (make-from-mag-ang r a)
      ((get 'make-from-mag-ang 'polar) r a))
    (define (add-complex z1 z2)
      (make-from-real-imag (+ (real-part z1) (real-part z2))
			   (+ (imag-part z1) (imag-part z2))))
    (define (sub-complex z1 z2)
      (make-from-real-imag (- (real-part z1) (real-part z2))
			   (- (imag-part z1) (imag-part z2))))
    (define (mul-complex z1 z2)
      (make-from-mag-ang (* (magnitude z1) (magnitude z2))
			 (+ (angle z1) (angle z2))))
    (define (div-complex z1 z2)
      (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
			 (- (angle z1) (angle z2))))
    (define (tag z) (attach-tag 'complex z))
    (put 'add '(complex complex)
	 (lambda (z1 z2) (tag (add-complex z1 z2))))
    (put 'sub '(complex complex)
	 (lambda (z1 z2) (tag (sub-complex z1 z2))))
    (put 'mul '(complex complex)
	 (lambda (z1 z2) (tag (mul-complex z1 z2))))
    (put 'div '(complex complex)
	 (lambda (z1 z2) (tag (div-complex z1 z2))))
    (put 'make-from-real-imag 'complex
	 (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'complex
	 (lambda (r a) (tag (make-from-mag-ang r a))))
    (put 'equ? '(complex complex)
	 (lambda (x y) (and (= 0 (real-part (sub-complex x y)))
		      (= 0 (imag-part (sub-complex x y))))))
    (put 'equ? '(rectangular polar) equ?)
    (put 'equ? '(polar rectangular) equ?)
    (put 'zero? '(complex)
	 (lambda (x) (equ? (tag x) (tag (make-from-real-imag 0 0)))))
    'done)

  (define (make-complex-from-real-imag x y)
    ((get 'make-from-real-imag 'complex) x y))

  (define (make-complex-from-mag-ang r a)
    ((get 'make-from-mag-ang 'complex) r a))

  (install-rectangular-package)
  (install-polar-package)
  (install-rational-package)
  (install-scheme-number-package)
  (install-complex-package)

#+end_src

#+RESULTS:
:  (scheme-number . 4)

#+begin_src scheme :exports both :results output :noweb-ref apply-generic-many-args
  (define (apply-generic op . args)
    (define (all-argtypes-same? . args)
      (let ((type (type-tag (car args))))
	(accumulate (lambda (x y) (and x y)) #t (map (lambda (x) (eq? type x)) args))))
    (define (coercion-if-exists? type arg-tags)
      (let ((coercion-list (map (lambda (x) 
                             (if (eq? type x)
                                 identity
                                 (get-coercion x type))) arg-tags)))
	(if (accumulate (lambda (x y) (and x y)) #t coercion-list)
	    coercion-list
	    #f)))
    (let ((type-tags (map type-tag args)))
	 (let ((proc (get op type-tags)))
	   (if proc
	       (apply proc (map contents args))
	       (if (and (>= (length args) 2) (not (all-argtypes-same? args)))
		   (let types-loop ((types type-tags))
		     (let ((list-of-coercion-functions
			    (coercion-if-exists? (car types) type-tags)))
		       (if list-of-coercion-functions
			   (apply apply-generic (cons op (map (lambda (fun arg) (fun arg))
						  list-of-coercion-functions
						  args)))
		       (if (not (null? (cdr types)))
                           (types-loop (cdr types))
                           (error "Even coercions failed. No method for these types.")))))
		   (error "No method for these types"
			  (list op type-tags)))))))
(define (scheme-number->complex n)
    (make-complex-from-real-imag (contents n) 0))
  (put-coercion 'scheme-number
		'complex
		scheme-number->complex)

(put 'max3-magnitude '(complex complex complex) (lambda (z1 z2 z3)
   (max (magnitude z1) (magnitude z2) (magnitude z3))))
(define (max3-magnitude x1 x2 x3) (apply-generic 'max3-magnitude x1 x2 x3))
(define (identity x) x)
#+end_src

#+begin_src scheme :exports both :results output
<<accumulate>>
<<generic-arithmetic-packages-multidispatch>>
<<alyssa-complex-suggestion>>
<<apply-generic-many-args>>
(show #t " " (displayed 
               (max3-magnitude 
                  (make-scheme-number 1) 
                  (make-scheme-number 2)
                  (make-complex-from-real-imag 3 0))))
#+end_src

#+RESULTS:
:  3

Well, this solution works, but is not perfect. Indeed, we can promote the
numbers to one of the arguments, but this implementation would fail if the
types are coerce-able, but the operation is not implemented.

*** DONE Exercise 2.83 Numeric Tower and (raise)
    CLOSED: [2019-10-16 Wed 14:53]

This exercise has a problem: the name of the ~(raise)~ function coincides
with the R7RS' built-in name for an operation to raise exceptions. Therefore,
I have to name my operation ~raise-type~.

#+begin_src scheme :exports both :results output
(define numeric-tower (list 'integer 'rational 'scheme-number 'complex))

(define (higher-type x)
   (define (find-higher-type x types)
      (cond ((or (null? types) (null? (cdr types))) (error "No type higher than given" x))
            ((eq? x (car types)) (cadr types))
            (else (find-higher-type x (cdr types))))))

(define (integer->rational x)
  (make-rational integer 1))

(define (rational->scheme-number x)
  (/ (numer x) (denom x)))
(put-coercion 'integer 'rational integer->rational)
(put-coercion 'rational 'scheme-number rational->scheme-number)

(define (raise-type x) ((get-coercion (type-tag x) (higher-type (type-tag x))) x))

#+end_src

*** TODO Exercise 2.84 Using ~raise~ (~raise-type~) in ~apply-generic~

This exercise is also extremely confusing. Scheme-number, I guess, can
effectively be considered "real", so "rational" numbers should be lower in
the hierarchy than "scheme-number"s. But what about integers? We never had
any operations concerning integers. 

In this exercise I will try to implement the following strategy:
 1. Modify ~type-tag~ to return ~'integer~ for scheme integers.
 2. Will not implement any operations for ~'integer~'s, because those will be
    covered by the ~'rational~ class.

#+begin_src scheme :exports both :results output :noweb-ref generic-integer-only-operation

(define (remainder-integer a b)
   (when (or (not (integer a)) (not (integer b)))
       (error "Arguments must be integers" a b))
   (remainder a b))

(put 'remainder '(integer integer) remainder-integer)
(define (remainder-generalized a b) (apply-generic 'remainder a b))

#+end_src

#+RESULTS:
: Output: {Exception #19 user "undefined variable" (put) #<procedure #f> (#f . 8)}



*** TODO Exercise 2.85

*** TODO Exercise 2.86

*** TODO Exercise 2.87

*** TODO Exercise 2.88

*** TODO Exercise 2.89

*** TODO Exercise 2.90

*** TODO Exercise 2.91

*** TODO Exercise 2.92

*** TODO Exercise 2.93

*** TODO Exercise 2.94

*** TODO Exercise 2.95

*** TODO Exercise 2.96

*** TODO Exercise 2.97

** TODO Chapter 3: Modularity, Objects and State [0/82]


*** TODO Exercise 3.1

*** TODO Exercise 3.2

*** TODO Exercise 3.3

*** TODO Exercise 3.4

*** TODO Exercise 3.5

*** TODO Exercise 3.6

*** TODO Exercise 3.7

*** TODO Exercise 3.8

*** TODO Exercise 3.9

*** TODO Exercise 3.10

*** TODO Exercise 3.11

*** TODO Exercise 3.12

*** TODO Exercise 3.13

*** TODO Exercise 3.14

*** TODO Exercise 3.15

*** TODO Exercise 3.16

*** TODO Exercise 3.17

*** TODO Exercise 3.18

*** TODO Exercise 3.19

*** TODO Exercise 3.20

*** TODO Exercise 3.21

*** TODO Exercise 3.22

*** TODO Exercise 3.23


*** Remark Table operations
Actually, these table operations are first required in the chapter 2,
Exercise-2.73. In order to avoid look-aheads, I am introducing this
pseudo-chapter so that the appropriate code could be tangled in.

#+begin_src scheme :exports both :results value :noweb-ref put-and-get
     (define (make-table)
       (let ((local-table (list '*table*)))
         (define (lookup key-1 key-2)
           (let ((subtable (assoc key-1 (cdr local-table))))
             (if subtable
                 (let ((record (assoc key-2 (cdr subtable))))
                   (if record
                       (cdr record)
                       false))
                 false)))
         (define (insert! key-1 key-2 value)
           (let ((subtable (assoc key-1 (cdr local-table))))
             (if subtable
                 (let ((record (assoc key-2 (cdr subtable))))
                   (if record
                       (set-cdr! record value)
                       (set-cdr! subtable
                                 (cons (cons key-2 value)
                                       (cdr subtable)))))
                 (set-cdr! local-table
                           (cons (list key-1
                                       (cons key-2 value))
                                 (cdr local-table)))))
           'ok)
         (define (dispatch m)
           (cond ((eq? m 'lookup-proc) lookup)
                 ((eq? m 'insert-proc!) insert!)
                 (else (error "Unknown operation -- TABLE" m))))
         dispatch))

     (define operation-table (make-table))
     (define get (operation-table 'lookup-proc))
     (define put (operation-table 'insert-proc!))
     (define coercion-table (make-table))
     (define get-coercion (coercion-table 'lookup-proc))
     (define put-coercion (coercion-table 'insert-proc!))
     
#+end_src

#+RESULTS:
: ok

*** TODO Exercise 3.24
*** TODO Exercise 3.25

*** TODO Exercise 3.26

*** TODO Exercise 3.27

*** TODO Exercise 3.28

*** TODO Exercise 3.29

*** TODO Exercise 3.30

*** TODO Exercise 3.31

*** TODO Exercise 3.32

*** TODO Exercise 3.33

*** TODO Exercise 3.34

*** TODO Exercise 3.35

*** TODO Exercise 3.36

*** TODO Exercise 3.37

*** TODO Exercise 3.38

*** TODO Exercise 3.39

*** TODO Exercise 3.40

*** TODO Exercise 3.41

*** TODO Exercise 3.42

*** TODO Exercise 3.43

*** TODO Exercise 3.44

*** TODO Exercise 3.45

*** TODO Exercise 3.46

*** TODO Exercise 3.47

*** TODO Exercise 3.48

*** TODO Exercise 3.49

*** TODO Exercise 3.50

*** TODO Exercise 3.51

*** TODO Exercise 3.52

*** TODO Exercise 3.53

*** TODO Exercise 3.54

*** TODO Exercise 3.55

*** TODO Exercise 3.56

*** TODO Exercise 3.57

*** TODO Exercise 3.58

*** TODO Exercise 3.59

*** TODO Exercise 3.60

*** TODO Exercise 3.61

*** TODO Exercise 3.62

*** TODO Exercise 3.63

*** TODO Exercise 3.64

*** TODO Exercise 3.65

*** TODO Exercise 3.66

*** TODO Exercise 3.67

*** TODO Exercise 3.68

*** TODO Exercise 3.69

*** TODO Exercise 3.70

*** TODO Exercise 3.71

*** TODO Exercise 3.72

*** TODO Exercise 3.73

*** TODO Exercise 3.74

*** TODO Exercise 3.75

*** TODO Exercise 3.76

*** TODO Exercise 3.77

*** TODO Exercise 3.78

*** TODO Exercise 3.79

*** TODO Exercise 3.80

*** TODO Exercise 3.81

*** TODO Exercise 3.82

** TODO Chapter 4: Metalinguistic Abstraction [0/79]

*** TODO Exercise 4.1

*** TODO Exercise 4.2

*** TODO Exercise 4.3

*** TODO Exercise 4.4

*** TODO Exercise 4.5

*** TODO Exercise 4.6

*** TODO Exercise 4.7

*** TODO Exercise 4.8

*** TODO Exercise 4.9

*** TODO Exercise 4.10

*** TODO Exercise 4.11

*** TODO Exercise 4.12

*** TODO Exercise 4.13

*** TODO Exercise 4.14

*** TODO Exercise 4.15

*** TODO Exercise 4.16

*** TODO Exercise 4.17

*** TODO Exercise 4.18

*** TODO Exercise 4.19

*** TODO Exercise 4.20

*** TODO Exercise 4.21

*** TODO Exercise 4.22

*** TODO Exercise 4.23

*** TODO Exercise 4.24

*** TODO Exercise 4.25

*** TODO Exercise 4.26

*** TODO Exercise 4.27

*** TODO Exercise 4.28

*** TODO Exercise 4.29

*** TODO Exercise 4.30

*** TODO Exercise 4.31

*** TODO Exercise 4.32

*** TODO Exercise 4.33

*** TODO Exercise 4.34

*** TODO Exercise 4.35

*** TODO Exercise 4.36

*** TODO Exercise 4.37

*** TODO Exercise 4.38

*** TODO Exercise 4.39

*** TODO Exercise 4.40

*** TODO Exercise 4.41

*** TODO Exercise 4.42

*** TODO Exercise 4.43

*** TODO Exercise 4.44

*** TODO Exercise 4.45

*** TODO Exercise 4.46

*** TODO Exercise 4.47

*** TODO Exercise 4.48

*** TODO Exercise 4.49

*** TODO Exercise 4.50

*** TODO Exercise 4.51

*** TODO Exercise 4.52

*** TODO Exercise 4.53

*** TODO Exercise 4.54

*** TODO Exercise 4.55

*** TODO Exercise 4.56

*** TODO Exercise 4.57

*** TODO Exercise 4.58

*** TODO Exercise 4.59

*** TODO Exercise 4.60

*** TODO Exercise 4.61

*** TODO Exercise 4.62

*** TODO Exercise 4.63

*** TODO Exercise 4.64

*** TODO Exercise 4.65

*** TODO Exercise 4.66

*** TODO Exercise 4.67

*** TODO Exercise 4.68

*** TODO Exercise 4.69

*** TODO Exercise 4.70

*** TODO Exercise 4.71

*** TODO Exercise 4.72

*** TODO Exercise 4.73

*** TODO Exercise 4.74

*** TODO Exercise 4.75

*** TODO Exercise 4.76

*** TODO Exercise 4.77

*** TODO Exercise 4.78

*** TODO Exercise 4.79

** TODO Chapter 5: Computing with Register Machines [0/52]

*** TODO Exercise 5.1

*** TODO Exercise 5.2

*** TODO Exercise 5.3

*** TODO Exercise 5.4

*** TODO Exercise 5.5

*** TODO Exercise 5.6

*** TODO Exercise 5.7

*** TODO Exercise 5.8

*** TODO Exercise 5.9

*** TODO Exercise 5.10

*** TODO Exercise 5.11

*** TODO Exercise 5.12

*** TODO Exercise 5.13

*** TODO Exercise 5.14

*** TODO Exercise 5.15

*** TODO Exercise 5.16

*** TODO Exercise 5.17

*** TODO Exercise 5.18

*** TODO Exercise 5.19

*** TODO Exercise 5.20

*** TODO Exercise 5.21

*** TODO Exercise 5.22

*** TODO Exercise 5.23

*** TODO Exercise 5.24

*** TODO Exercise 5.25

*** TODO Exercise 5.26

*** TODO Exercise 5.27

*** TODO Exercise 5.28

*** TODO Exercise 5.29

*** TODO Exercise 5.30

*** TODO Exercise 5.31

*** TODO Exercise 5.32

*** TODO Exercise 5.33

*** TODO Exercise 5.34

*** TODO Exercise 5.35

*** TODO Exercise 5.36

*** TODO Exercise 5.37

*** TODO Exercise 5.38

*** TODO Exercise 5.39

*** TODO Exercise 5.40

*** TODO Exercise 5.41

*** TODO Exercise 5.42

*** TODO Exercise 5.43

*** TODO Exercise 5.44

*** TODO Exercise 5.45

*** TODO Exercise 5.46

*** TODO Exercise 5.47

*** TODO Exercise 5.48

*** TODO Exercise 5.49

*** TODO Exercise 5.50

*** TODO Exercise 5.51

*** TODO Exercise 5.52

* Footnotes

[fn:1] This exercise took me 7 hours.


#  LocalWords:  vec vect
